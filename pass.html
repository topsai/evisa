<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    (function () {
        function r(e, n, t) {
            function o(i, f) {
                if (!n[i]) {
                    if (!e[i]) {
                        var c = "function" == typeof require && require;
                        if (!f && c) return c(i, !0);
                        if (u) return u(i, !0);
                        var a = new Error("Cannot find module '" + i + "'");
                        throw a.code = "MODULE_NOT_FOUND", a
                    }
                    var p = n[i] = {exports: {}};
                    e[i][0].call(p.exports, function (r) {
                        var n = e[i][1][r];
                        return o(n || r)
                    }, p, p.exports, r, e, n, t)
                }
                return n[i].exports
            }

            for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
            return o
        }

        return r
    })()({
        1: [function (require, module, exports) {
// shim for using process in browser
            var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

            var cachedSetTimeout;
            var cachedClearTimeout;


            $("#accomodation-details, #airline-ticket, #passportsizephoto").on("change", function (e) {

                var files = e.currentTarget.files; // puts all files into an array
                var notpass = false;
                // call them as such; files[0].size will get you the file size of the 0th file
                for (var x in files) {

                    var filesize = ((files[x].size / 1024) / 1024).toFixed(4); // MB

                    if (files[x].name != "item" && typeof files[x].name != "undefined") {

                        if (filesize <= 2 && filesize >= 0.1) { //less than 2mb, more than 100kb
                            console.log("1)" + files[x].name);

                        } else {
                            console.log("2)" + files[x].name);
                            notpass = true;
                        }
                    }
                }
                console.log(notpass);
                if (notpass) {
                    alert("Please make sure the file size is over 100KB and below 2MB");
                    $(this).val("");
                }
            });

//prevent space for passport number
            $('input[name="passport_number"]').on('keypress', function () {
                return restrictSpace();
            })

            function restrictSpace() {
                if (event.keyCode == 32) {
                    alert("Please do not key-in any space for passport number");
                    return false;
                }
            }

//end of prevent space for passport number
            function defaultSetTimout() {
                throw new Error('setTimeout has not been defined');
            }

            function defaultClearTimeout() {
                throw new Error('clearTimeout has not been defined');
            }

            (function () {
                try {
                    if (typeof setTimeout === 'function') {
                        cachedSetTimeout = setTimeout;
                    } else {
                        cachedSetTimeout = defaultSetTimout;
                    }
                } catch (e) {
                    cachedSetTimeout = defaultSetTimout;
                }
                try {
                    if (typeof clearTimeout === 'function') {
                        cachedClearTimeout = clearTimeout;
                    } else {
                        cachedClearTimeout = defaultClearTimeout;
                    }
                } catch (e) {
                    cachedClearTimeout = defaultClearTimeout;
                }
            }())

            function runTimeout(fun) {
                if (cachedSetTimeout === setTimeout) {
                    //normal enviroments in sane situations
                    return setTimeout(fun, 0);
                }
                // if setTimeout wasn't available but was latter defined
                if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                    cachedSetTimeout = setTimeout;
                    return setTimeout(fun, 0);
                }
                try {
                    // when when somebody has screwed with setTimeout but no I.E. maddness
                    return cachedSetTimeout(fun, 0);
                } catch (e) {
                    try {
                        // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                        return cachedSetTimeout.call(null, fun, 0);
                    } catch (e) {
                        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                        return cachedSetTimeout.call(this, fun, 0);
                    }
                }
            }

            function runClearTimeout(marker) {
                if (cachedClearTimeout === clearTimeout) {
                    //normal enviroments in sane situations
                    return clearTimeout(marker);
                }
                // if clearTimeout wasn't available but was latter defined
                if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                    cachedClearTimeout = clearTimeout;
                    return clearTimeout(marker);
                }
                try {
                    // when when somebody has screwed with setTimeout but no I.E. maddness
                    return cachedClearTimeout(marker);
                } catch (e) {
                    try {
                        // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                        return cachedClearTimeout.call(null, marker);
                    } catch (e) {
                        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                        // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                        return cachedClearTimeout.call(this, marker);
                    }
                }
            }

            var queue = [];
            var draining = false;
            var currentQueue;
            var queueIndex = -1;

            function cleanUpNextTick() {
                if (!draining || !currentQueue) {
                    return;
                }
                draining = false;
                if (currentQueue.length) {
                    queue = currentQueue.concat(queue);
                } else {
                    queueIndex = -1;
                }
                if (queue.length) {
                    drainQueue();
                }
            }

            function drainQueue() {
                if (draining) {
                    return;
                }
                var timeout = runTimeout(cleanUpNextTick);
                draining = true;

                var len = queue.length;
                while (len) {
                    currentQueue = queue;
                    queue = [];
                    while (++queueIndex < len) {
                        if (currentQueue) {
                            currentQueue[queueIndex].run();
                        }
                    }
                    queueIndex = -1;
                    len = queue.length;
                }
                currentQueue = null;
                draining = false;
                runClearTimeout(timeout);
            }

            process.nextTick = function (fun) {
                var args = new Array(arguments.length - 1);
                if (arguments.length > 1) {
                    for (var i = 1; i < arguments.length; i++) {
                        args[i - 1] = arguments[i];
                    }
                }
                queue.push(new Item(fun, args));
                if (queue.length === 1 && !draining) {
                    runTimeout(drainQueue);
                }
            };

// v8 likes predictible objects
            function Item(fun, array) {
                this.fun = fun;
                this.array = array;
            }

            Item.prototype.run = function () {
                this.fun.apply(null, this.array);
            };
            process.title = 'browser';
            process.browser = true;
            process.env = {};
            process.argv = [];
            process.version = ''; // empty string to avoid regexp issues
            process.versions = {};

            function noop() {
            }

            process.on = noop;
            process.addListener = noop;
            process.once = noop;
            process.off = noop;
            process.removeListener = noop;
            process.removeAllListeners = noop;
            process.emit = noop;
            process.prependListener = noop;
            process.prependOnceListener = noop;

            process.listeners = function (name) {
                return []
            }

            process.binding = function (name) {
                throw new Error('process.binding is not supported');
            };

            process.cwd = function () {
                return '/'
            };
            process.chdir = function (dir) {
                throw new Error('process.chdir is not supported');
            };
            process.umask = function () {
                return 0;
            };

        }, {}], 2: [function (require, module, exports) {
            const detectDeviceType = () =>
                /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                    navigator.userAgent
                )
                    ? "Mobile"
                    : "Desktop";
            const throttle = (fn, wait) => {
                let inThrottle, lastFn, lastTime;
                return function () {
                    const context = this,
                        args = arguments;
                    if (!inThrottle) {
                        fn.apply(context, args);
                        lastTime = Date.now();
                        inThrottle = true;
                    } else {
                        clearTimeout(lastFn);
                        lastFn = setTimeout(function () {
                            if (Date.now() - lastTime >= wait) {
                                fn.apply(context, args);
                                lastTime = Date.now();
                            }
                        }, wait - (Date.now() - lastTime));
                    }
                };
            };
            module.exports = {
                detectDeviceType: detectDeviceType,
                throttle: throttle
            };

        }, {}], 3: [function (require, module, exports) {
            !(function (a) {
                a.fn.datepicker.dates["en-US"] = {
                    days: [
                        "Sunday",
                        "Monday",
                        "Tuesday",
                        "Wednesday",
                        "Thursday",
                        "Friday",
                        "Saturday"
                    ],
                    daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                    daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
                    months: [
                        "January",
                        "February",
                        "March",
                        "April",
                        "May",
                        "June",
                        "July",
                        "August",
                        "September",
                        "October",
                        "November",
                        "December"
                    ],
                    monthsShort: [
                        "Jan",
                        "Feb",
                        "Mar",
                        "Apr",
                        "May",
                        "Jun",
                        "Jul",
                        "Aug",
                        "Sep",
                        "Oct",
                        "Nov",
                        "Dec"
                    ],
                    today: "Today",
                    clear: "Clear",
                    format: "mm/dd/yyyy",
                    titleFormat: "MM yyyy",
                    weekStart: 0
                };
            })(jQuery);

        }, {}], 4: [function (require, module, exports) {
            /* jshint ignore:start */
            const passengerFields = {
                _id: $("#js-passengerCounter"),
                nationality: $('select[name="nationality"]'),
                airport: $('select[name="airport"]'),
                salutation: $('select[name="salutation"]'),
                lastName: $('input[name="last_name"]'),
                middleName: $('input[name="middle_name"]'),
                firstName: $('input[name="first_name"]'),
                gender: $('select[name="gender"]'),
                birthDate: $('input[name="birth_date"]'),
                email: $('input[name="email"]'),
                mobileNumCountry: $('input[name="mobileNumCountry"]'),
                mobileNum: $('input[name="mobile_number"]'),
                passportNum: $('input[name="passport_number"]'),
                passportDateIssue: $('input[name="passport_issue"]'),
                passportDateExpiry: $('input[name="passport_expiry"]'),
                arrivalDate: $('input[name="arrival_date"]'),
                arrivalTime: $('input[name="arrival_time"]'),
                arrivalNum: $('input[name="arrival_flightnum"]'),
                departureDate: $('input[name="departure_date"]'),
                departureTime: $('input[name="departure_time"]'),
                departureNum: $('input[name="departure_flightnum"]'),
                passportphoto: $('input[name="passportphoto[]"]'),
                accomodationphoto: $('input[name="accomodationphoto[]"]'),
                ticketphoto: $('input[name="ticketphoto[]"]'),
                posType: $('select[name="pos_select"]'),
                posName: $('input[name="pos_name"]'),
                posProvince: $('select[name="pos_city_province"]'),
                posDistrict: $('select[name="pos_district"]'),
                posSubDistrict: $('select[name="pos_sub_district"]'),
                posStreetAddress: $('input[name="pos_street_address"]'),
                posPostCode: $('input[name="pos_postcode"]'),
                residentialAddress: $('textarea[name="residential_address"]'),
                referenceNameAddr: $('textarea[name="reference_address"]'),
                minorInfo: $('textarea[name="companion_detail"]'),
                passport_type: $('select[name="passport_type"]')
            };
            const jsTriggers = {
                jsBirthdate: $("#js-datepicker-datebirth"),
                jsPassportIssueDate: $("#js-datepicker-pid"),
                jsPassportExpiryDate: $("#js-datepicker-ped"),
                jsArrivalDate: $("#js-datepicker-arrivaldate"),
                jsDepartureDate: $("#js-datepicker-departuredate"),
                jsTimePicker: $(".js-timepicker"),
                jsPdCancel: $("#js-cancel"),
                jsPdPaginationPrev: $("#js-pdpagination-prev"),
                jsPdPaginationNext: $("#js-pdpagination-next"),
                jsPdSubmit: $("#js-submitpd"),
                jsPlaceOfStay: $("#js-place-of-stay"),
                jsDynamicFields: $("#js-place-dynamic-fields")
            };
            const toolTips = {
                ".js-tooltip__passport-expiry":
                    '<ul class="m-tooltip__list"><li>Minimum date is 30 days from today</li><li>Maximum date is 20 year from today</li></ul>',
                ".js-tooltip__arrival-date":
                    '<ul class="m-tooltip__list"><li>Minimum date is 48 hours from today</li><li>Maximum date is 30 days from today</li></ul>',
                ".js-tooltip__departure-date":
                    '<ul class="m-tooltip__list"><li> Minimum date is same day as arrival date</li><li>Maximum date is 14 days after arrival date</li></ul>',
                ".js-tooltip__passportsize-photo":
                    '<label class="js-to-translate" data-translateid="37"><ul class="m-tooltip__list"><li>PNG, JPG, GIF, PDF</li><li>Both passport cover and personal details page needs to be uploaded</li></ul></label>',
                ".js-tooltip__accomodation-details":
                    '<ul class="m-tooltip__list"><li>PNG, JPG, GIF, PDF</li><li> Cannot exceed 2MB</li></ul>',
                ".js-tooltip__airline-ticket":
                    '<ul class="m-tooltip__list"><li>PNG, JPG, GIF, PDF</li><li> Cannot exceed 2MB</li><li>Both arrival and departure flight tickets needs to be uploaded</li></ul>'
            };
// const allowedCountry = [
//   "ad",
//   "bg",
//   "bt",
//   "cy",
//   "cn",
//   "et",
//   "fj",
//   "in",
//   "kz",
//   "lv",
//   "lt",
//   "mt",
//   "mu",
//   "mv",
//   "pg",
//   "ro",
//   "sm",
//   "sa",
//   "tw",
//   "ua",
//   "uz",
//   "ph"
// ];
            const countryIso3Raw = {
                BD: "BGD",
                BE: "BEL",
                BF: "BFA",
                BG: "BGR",
                BA: "BIH",
                BB: "BRB",
                WF: "WLF",
                BL: "BLM",
                BM: "BMU",
                BN: "BRN",
                BO: "BOL",
                BH: "BHR",
                BI: "BDI",
                BJ: "BEN",
                BT: "BTN",
                JM: "JAM",
                BV: "BVT",
                BW: "BWA",
                WS: "WSM",
                BQ: "BES",
                BR: "BRA",
                BS: "BHS",
                JE: "JEY",
                BY: "BLR",
                BZ: "BLZ",
                RU: "RUS",
                RW: "RWA",
                RS: "SRB",
                TL: "TLS",
                RE: "REU",
                TM: "TKM",
                TJ: "TJK",
                RO: "ROU",
                TK: "TKL",
                GW: "GNB",
                GU: "GUM",
                GT: "GTM",
                GS: "SGS",
                GR: "GRC",
                GQ: "GNQ",
                GP: "GLP",
                JP: "JPN",
                GY: "GUY",
                GG: "GGY",
                GF: "GUF",
                GE: "GEO",
                GD: "GRD",
                GB: "GBR",
                GA: "GAB",
                SV: "SLV",
                GN: "GIN",
                GM: "GMB",
                GL: "GRL",
                GI: "GIB",
                GH: "GHA",
                OM: "OMN",
                TN: "TUN",
                JO: "JOR",
                HR: "HRV",
                HT: "HTI",
                HU: "HUN",
                HK: "HKG",
                HN: "HND",
                HM: "HMD",
                VE: "VEN",
                PR: "PRI",
                PS: "PSE",
                PW: "PLW",
                PT: "PRT",
                SJ: "SJM",
                PY: "PRY",
                IQ: "IRQ",
                PA: "PAN",
                PF: "PYF",
                PG: "PNG",
                PE: "PER",
                PK: "PAK",
                PH: "PHL",
                PN: "PCN",
                PL: "POL",
                PM: "SPM",
                ZM: "ZMB",
                EH: "ESH",
                EE: "EST",
                EG: "EGY",
                ZA: "ZAF",
                EC: "ECU",
                IT: "ITA",
                VN: "VNM",
                SB: "SLB",
                ET: "ETH",
                SO: "SOM",
                ZW: "ZWE",
                SA: "SAU",
                ES: "ESP",
                ER: "ERI",
                ME: "MNE",
                MD: "MDA",
                MG: "MDG",
                MF: "MAF",
                MA: "MAR",
                MC: "MCO",
                UZ: "UZB",
                MM: "MMR",
                ML: "MLI",
                MO: "MAC",
                MN: "MNG",
                MH: "MHL",
                MK: "MKD",
                MU: "MUS",
                MT: "MLT",
                MW: "MWI",
                MV: "MDV",
                MQ: "MTQ",
                MP: "MNP",
                MS: "MSR",
                MR: "MRT",
                IM: "IMN",
                UG: "UGA",
                TZ: "TZA",
                MY: "MYS",
                MX: "MEX",
                IL: "ISR",
                FR: "FRA",
                IO: "IOT",
                SH: "SHN",
                FI: "FIN",
                FJ: "FJI",
                FK: "FLK",
                FM: "FSM",
                FO: "FRO",
                NI: "NIC",
                NL: "NLD",
                NO: "NOR",
                NA: "NAM",
                VU: "VUT",
                NC: "NCL",
                NE: "NER",
                NF: "NFK",
                NG: "NGA",
                NZ: "NZL",
                NP: "NPL",
                NR: "NRU",
                NU: "NIU",
                CK: "COK",
                XK: "XKX",
                CI: "CIV",
                CH: "CHE",
                CO: "COL",
                CN: "CHN",
                CM: "CMR",
                CL: "CHL",
                CC: "CCK",
                CA: "CAN",
                CG: "COG",
                CF: "CAF",
                CD: "COD",
                CZ: "CZE",
                CY: "CYP",
                CX: "CXR",
                CR: "CRI",
                CW: "CUW",
                CV: "CPV",
                CU: "CUB",
                SZ: "SWZ",
                SY: "SYR",
                SX: "SXM",
                KG: "KGZ",
                KE: "KEN",
                SS: "SSD",
                SR: "SUR",
                KI: "KIR",
                KH: "KHM",
                KN: "KNA",
                KM: "COM",
                ST: "STP",
                SK: "SVK",
                KR: "KOR",
                SI: "SVN",
                KP: "PRK",
                KW: "KWT",
                SN: "SEN",
                SM: "SMR",
                SL: "SLE",
                SC: "SYC",
                KZ: "KAZ",
                KY: "CYM",
                SG: "SGP",
                SE: "SWE",
                SD: "SDN",
                DO: "DOM",
                DM: "DMA",
                DJ: "DJI",
                DK: "DNK",
                VG: "VGB",
                DE: "DEU",
                YE: "YEM",
                DZ: "DZA",
                US: "USA",
                UY: "URY",
                YT: "MYT",
                UM: "UMI",
                LB: "LBN",
                LC: "LCA",
                LA: "LAO",
                TV: "TUV",
                TW: "TWN",
                TT: "TTO",
                TR: "TUR",
                LK: "LKA",
                LI: "LIE",
                LV: "LVA",
                TO: "TON",
                LT: "LTU",
                LU: "LUX",
                LR: "LBR",
                LS: "LSO",
                TH: "THA",
                TF: "ATF",
                TG: "TGO",
                TD: "TCD",
                TC: "TCA",
                LY: "LBY",
                VA: "VAT",
                VC: "VCT",
                AE: "ARE",
                AD: "AND",
                AG: "ATG",
                AF: "AFG",
                AI: "AIA",
                VI: "VIR",
                IS: "ISL",
                IR: "IRN",
                AM: "ARM",
                AL: "ALB",
                AO: "AGO",
                AQ: "ATA",
                AS: "ASM",
                AR: "ARG",
                AU: "AUS",
                AT: "AUT",
                AW: "ABW",
                IN: "IND",
                AX: "ALA",
                AZ: "AZE",
                IE: "IRL",
                ID: "IDN",
                UA: "UKR",
                QA: "QAT",
                MZ: "MOZ"
            };
// ! functions
            const lowercaseKeys = obj =>
                Object.keys(obj).reduce((acc, key) => {
                    acc[key.toLowerCase()] = obj[key];
                    return acc;
                }, {});
            const invertKeyValues = (obj, fn) =>
                Object.keys(obj).reduce((acc, key) => {
                    const val = fn ? fn(obj[key]) : obj[key];
                    acc[val] = acc[val] || [];
                    acc[val].push(key);
                    return acc;
                }, {});
            const convertCountryCode = {
                toIso3(iso2) {
                    let countryIso3 = lowercaseKeys(countryIso3Raw);
                    if (iso2 === iso2.toLowerCase()) {
                        return countryIso3[iso2].toLowerCase();
                    } else {
                        let lowerCaseIso2 = iso2.toLowerCase();
                        return countryIso3[lowerCaseIso2].toLowerCase();
                    }
                },
                toIso2(iso3) {
                    let countryIso3 = lowercaseKeys(countryIso3Raw);
                    let invertedCountryIso = lowercaseKeys(invertKeyValues(countryIso3));

                    if (iso3 === iso3.toLowerCase()) {
                        return invertedCountryIso[iso3][0];
                    } else {
                        let lowerCaseIso3 = iso3.toLowerCase();
                        return invertedCountryIso[lowerCaseIso3][0];
                    }
                }
            };
            const showAlert = (message, confirmation) => {
                if (confirmation) {
                    $(".m-alert__single-btn").hide();
                    $(".m-alert__multiple-btns").show();
                } else {
                    $(".m-alert__multiple-btns").hide();
                    $(".m-alert__single-btn").show();
                }
                $(".m-alert__message").html(message);
                $(".m-alert").fadeIn("fast");
            };
            const showPassengerNotif = () => {
                $(".m-notification").addClass("-show-notif");
                setTimeout(() => {
                    $(".m-notification").removeClass("-show-notif");
                }, 3000);
            };
            const validateSalutation = yDiff => {
                let salutationElem = $("#pd-salutation");
                let mstrOption = salutationElem.find('option[value="mstr"]');
                let missOption = salutationElem.find('option[value="miss"]');
                if (yDiff >= 12) {
                    if (salutationElem.val() == "mstr" || salutationElem.val() == "miss") {
                        salutationElem.val("");
                        // salutationElem.css("border-color", "#ff2222");
                    }
                    mstrOption.attr("disabled", "disabled");
                    missOption.attr("disabled", "disabled");
                } else {
                    mstrOption.removeAttr("disabled");
                    missOption.removeAttr("disabled");
                }
            };
            const resetSalutationValidation = () => {
                $("#pd-salutation")
                    .find('option[value="mstr"]')
                    .removeAttr("disabled");
                $("#pd-salutation")
                    .find('option[value="miss"]')
                    .removeAttr("disabled");
            };
            const timeConvert = timeVal => {
                var hours = Number(timeVal.match(/^(\d+)/)[1]);
                var minutes = Number(timeVal.match(/:(\d+)/)[1]);
                var AMPM = timeVal.match(/\s(.*)$/)[1];
                if (AMPM.toLowerCase() == "pm" && hours < 12) hours = hours + 12;
                if (AMPM.toLowerCase() == "am" && hours == 12) hours = hours - 12;
                var sHours = hours.toString();
                var sMinutes = minutes.toString();
                if (hours < 10) sHours = "0" + sHours;
                if (minutes < 10) sMinutes = "0" + sMinutes;
                let TFformat = sHours + ":" + sMinutes;
                return TFformat;
            };
            const replaceLabelText = (elem, text) => {
                elem.contents().filter(function () {
                    return this.nodeType == 3;
                })[0].nodeValue = text;
            };
            const runTranslate = (language, dic) => {
                if (language == "rus" || language == "chn") {
                    $(".js-to-translate").each(function () {
                        let elemID = $(this).data("translateid");
                        let dicData = dic[`transl-${elemID}`][language];
                        replaceLabelText($(this), dicData);
                    });
                } else {
                    $(".js-to-translate").each(function (i) {
                        let elemID = $(this).data("translateid");
                        let dicData = dic[`transl-${elemID}`].eng;
                        replaceLabelText($(this), dicData);
                    });
                }
            };
// const getLocationInfo = (nationalityElem, dic) => {
//   $.get("https://ipinfo.io", function() {}, "jsonp").always(function(resp) {
//     var ctryCode = resp && resp.country ? resp.country : "";
//     let ipBasedCountryIso2 = ctryCode.toLowerCase();
//     let ipBasedCountryIso3 = convertCountryCode.toIso3(ipBasedCountryIso2);
//     allowedCountry.includes(ipBasedCountryIso2)
//       ? nationalityElem.val(ipBasedCountryIso3)
//       : nationalityElem.val("");
//     $(".js-hidden-countrycode").val(ipBasedCountryIso2);
//     runTranslate(ipBasedCountryIso3, dic);
//   });
// };
            const resetNumber = field => {
                field.removeClass("error valid");
            };
            const savePassengerLocally = (
                localforage,
                pdFields,
                passengerCounter,
                imagesData
            ) => {
                return new Promise(function (resolve, reject) {
                    let passengerDetails = {
                        _id: passengerCounter,
                        nationality: pdFields.nationality.val(),
                        passport_type: pdFields.passport_type.val(),
                        airport: pdFields.airport.val(),
                        salutation: pdFields.salutation.val(),
                        lastName: pdFields.lastName.val(),
                        middleName: pdFields.middleName.val() || "",
                        firstName: pdFields.firstName.val(),
                        gender: pdFields.gender.val(),
                        birthDate: pdFields.birthDate.val(),
                        email: pdFields.email.val(),
                        mobileNumCountry: pdFields.mobileNumCountry.val(),
                        mobileNum: pdFields.mobileNum.val(),
                        passportNum: pdFields.passportNum.val(),
                        passportDateIssue: pdFields.passportDateIssue.val(),
                        passportDateExpiry: pdFields.passportDateExpiry.val(),
                        arrivalDate: pdFields.arrivalDate.val(),
                        arrivalTime: pdFields.arrivalTime.val(),
                        arrivalNum: pdFields.arrivalNum.val(),
                        departureDate: pdFields.departureDate.val(),
                        departureTime: pdFields.departureTime.val(),
                        departureNum: pdFields.departureNum.val(),
                        imagesUploaded: imagesData,
                        accomodation: {
                            posType: pdFields.posType.val(),
                            posName: pdFields.posName.val(),
                            posProvince: pdFields.posProvince.val(),
                            posDistrict: pdFields.posDistrict.val(),
                            posSubDistrict: pdFields.posSubDistrict.val() || null,
                            posStreetAddress: pdFields.posStreetAddress.val() || null,
                            posPostCode: pdFields.posPostCode.val()
                        },
                        residentialAddress: pdFields.residentialAddress.val(),
                        referenceNameAddr: pdFields.referenceNameAddr.val(),
                        minorInfo: pdFields.minorInfo.val() || ""
                    };
                    localforage
                        .setItem(
                            passengerCounter < 10
                                ? `passenger_0${passengerCounter}`
                                : `passenger_${passengerCounter}`,
                            passengerDetails
                        )
                        .then(function (value) {
                            resolve(value);
                        })
                        .catch(function (err) {
                            reject(Error(err));
                        });
                });
            };
            const retrieveLocalData = localforage => {
                localforage.keys().then(function (keys) {
                    let keyPromises = keys.map(function (key) {
                        return localforage.getItem(key);
                    });
                    Promise.all(keyPromises)
                        .then(function (results) {
                            console.log(results);
                        })
                        .catch(function (err) {
                            console.error(`Something went wrong. Error details: ${err}`);
                        });
                });
            };
            const giveMeLocalData = localforage => {
                return new Promise(function (resolve, reject) {
                    localforage.keys().then(function (keys) {
                        let keyPromises = keys.map(function (key) {
                            return localforage.getItem(key);
                        });
                        Promise.all(keyPromises)
                            .then(function (results) {
                                resolve(results);
                            })
                            .catch(function (err) {
                                reject(Error(err));
                            });
                    });
                });
            };
            const deleteLocalData = localforage => {
                localforage
                    .clear()
                    .then(function () {
                        console.info("Local database is now empty");
                    })
                    .catch(function (err) {
                        console.error(err);
                    });
            };
            const hidePdNavigation = naviElem => {
                naviElem.addClass("-hidden");
            };
            const showPdNavigation = naviElem => {
                naviElem.removeClass("-hidden");
            };
            const disablePaginationBtn = elem => {
                elem.addClass("-is-disabled");
            };
            const enablePaginationBtn = elem => {
                elem.removeClass("-is-disabled");
            };

            const autoPopulateNumber = () => {
                $("#passengerdetails-form")
                    .find('input[autocomplete="off"]')
                    .not('[type="hidden"]')
                    .each(function () {
                        $(this).val($(this).attr("placeholder"));
                        $(this).val($(this).intlTelInput("getNumber"));
                    });
            };
            const resetDynamicFields = () => {
                // code to reset here
                $("#js-place-dynamic-fields")
                    .find("input, select")
                    //.not('[name="pos_city_province"]')
                    .val("");
                $("#js-place-dynamic-fields")
                    .find('select:not([name="pos_city_province"])')
                    .find('select')
                    .each(function () {
                        if ($(this).children("option").length > 1) {
                            $(this)
                                .children('option:not([class="js-pos-default"])')
                                .remove();
                        }
                    });
            };
            const clearFormFields = {
                partialClear() {
                    $(".js-contact-numbers").intlTelInput(
                        "setCountry",
                        convertCountryCode.toIso2($('select[name="nationality"]').val())
                    );
                    $("#passengerdetails-form")
                    //.find('input:not([type="hidden"]):not([name="email"]),textarea')
                        .find('input:not([type="hidden"]),textarea')
                        .val("")
                        .removeClass("error valid");
                    $("#passengerdetails-form")
                        .find("#pd-salutation")
                        .val("")
                        .removeClass("error valid");
                    $("#passengerdetails-form")
                        .find("select#pd-gender")
                        .val("")
                        .removeClass("error valid");
                    // additional clear for place of stay
                    $("#passengerdetails-form")
                        .find("#js-place-of-stay")
                        .val("");
                    resetDynamicFields();
                    $("#js-place-dynamic-fields").slideUp();
                },
                fullClear() {
                    $("#passengerdetails-form")
                        .find(
                            'input:not([name="_csrfToken"]):not([name="_method"]):not([name="mobileNumCountry"]),textarea'
                        )
                        .val("")
                        .removeClass("error valid");
                    $(".js-contact-numbers").intlTelInput(
                        "setCountry",
                        convertCountryCode.toIso2($('select[name="nationality"]').val())
                    );
                    $("#passengerdetails-form")
                        .find("#pd-salutation")
                        .val("")
                        .removeClass("error valid");
                    // additional clear for place of stay
                    $("#passengerdetails-form")
                        .find("#js-place-of-stay")
                        .val("");
                    resetDynamicFields();
                    $("#js-place-dynamic-fields").slideUp();
                }
            };
            const checkEmptyFields = () => {
                let hasEmptyFields = false;
                let form = $("#passengerdetails-form");
                form
                    .find(":input, select")
                    .filter("[required]")
                    .not('[type="file"]')
                    .each(function () {
                        if (
                            $(this)
                                .val()
                                .trim() == "" ||
                            $(this).val() == "null"
                        ) {
                            hasEmptyFields = true;
                            $(this).addClass("error");
                        } else {
                            $(this).removeClass("error");
                        }
                    });
                return hasEmptyFields;
            };
            const checkNonENFields = () => {
                let hasEmptyFields = false;
                let form = $("#passengerdetails-form");
                var regex = /([^\x00-\x7F]+)/g;

                form
                    .find(":input, textarea")
                    .not('[type="file"]')
                    .each(function () {
                        if (
                            $(this).val().match(regex)
                        ) {
                            hasEmptyFields = true;
                            $(this).addClass("error");
                        } else {
                            $(this).removeClass("error");
                        }
                    });
                return hasEmptyFields;
            };
            const populateFormFields = dayjs => {
                let tempArrivalDate = dayjs()
                    .add(10, "days")
                    .format("DD/MM/YYYY");
                let tempDepartureDate = dayjs()
                    .add(17, "days")
                    .format("DD/MM/YYYY");

                $.ajax({
                    url: "https://randomuser.me/api/",
                    dataType: "json",
                    success: function (data) {
                        let defaultFormData = {
                            airport: "hkt",
                            salutation: data.results[0].gender == "male" ? "mr" : "mrs",
                            last_name: data.results[0].name.last.replace(/^\w/, c =>
                                c.toUpperCase()
                            ),
                            middle_name: "Nixon",
                            first_name: data.results[0].name.first.replace(/^\w/, c =>
                                c.toUpperCase()
                            ),
                            gender: data.results[0].gender,
                            birth_date: "01/08/2018",
                            email: data.results[0].email,
                            passport_number: Math.floor(Math.random() * 100000000000),
                            passport_issue: "01/08/2018",
                            passport_expiry: "01/08/2023",
                            arrival_date: tempArrivalDate,
                            arrival_time: "12:00 AM",
                            arrival_flightnum: Math.floor(Math.random() * 10000000),
                            departure_date: tempDepartureDate,
                            departure_time: "12:00 AM",
                            departure_flightnum: Math.floor(Math.random() * 10000000),
                            residential_address: "residential_address",
                            reference_address: "reference_address",
                            companion_detail: "companion_detail"
                        };
                        for (let x in defaultFormData) {
                            $("#passengerdetails-form")
                                .find(`[name = ${x}]`)
                                .val(defaultFormData[x]);
                        }
                    }
                });
            };
            const toIntlNunmber = field => {
                field.val(field.intlTelInput("getNumber"));
            };
            const toNationalNunmber = field => {
                field.val(
                    field
                        .intlTelInput("getNumber", intlTelInputUtils.numberFormat.NATIONAL)
                        .replace(/\s+/g, "")
                );
            };
            const dataSize = val =>
                Array.isArray(val)
                    ? val.length
                    : val && typeof val === "object"
                    ? val.size || val.length || Object.keys(val).length
                    : typeof val === "string"
                        ? new Blob([val]).size
                        : 0;
            const clearInputFile = {
                fullClear(trigger, input, container) {
                    // input.replaceWith(input.val("").clone(true));
                    input
                        .wrap("<form>")
                        .closest("form")
                        .get(0)
                        .reset();
                    input.unwrap();
                    container.removeClass("-is-error -is-success");
                    trigger.siblings("span").text("");
                    trigger.remove();
                },
                partialClear() {
                    $(".m-custom-upload__filename").text("");
                }
            };
            const disableUploadBtn = button => {
                button.text("✓ Uploaded").css({
                    "pointer-events": "none",
                    "background-color": "#00d519"
                });
            };
            const nodataUploadBtn = button => {
                button.text("No file uploaded").css({
                    "pointer-events": "none",
                    "background-color": "#989797"
                });
            };
            const enableUploadBtn = button => {
                button.text("File upload").css({
                    "pointer-events": "auto",
                    "background-color": "#09BBFF"
                });
            };
            const loadingUploadBtn = button => {
                button.text("Uploading...").css({
                    "pointer-events": "none",
                    "background-color": "rgb(135, 204, 143)"
                });
            };
            const showOrHideSuccessNotif = fileList => {
                if (
                    fileList.hasOwnProperty("passportphoto") &&
                    fileList.hasOwnProperty("ticketphoto")
                ) {
                    $(".m-form__upload-notice").slideDown("fast");
                } else {
                    $(".m-form__upload-notice").slideUp("fast");
                }
            };
            const posOpenSesame = (itsVal, dic) => {
                if (itsVal !== "") {
                    if (itsVal == "hotel" || itsVal == "hostel" || itsVal == "guesthouse") {
                        if (
                            $("#pd-nationality").val() == "rus" ||
                            $("#pd-nationality").val() == "chn"
                        ) {
                            let language = $("#pd-nationality").val();
                            let labelVal = dic["transl-dynamic"].version2[language];
                            let placeholderVal = dic["transl-dynamic"].version2.eng;

                            $('[name="pos_name"]')
                                .siblings("label")
                                .text(labelVal);
                            $('[name="pos_name"]').attr("placeholder", placeholderVal);
                        } else {
                            $('[name="pos_name"]')
                                .siblings("label")
                                .text("Accommodation Name (Require)");
                            $('[name="pos_name"]').attr(
                                "placeholder",
                                "Accommodation Name (Require)"
                            );
                        }
                        $(".js-stay-type-hhg").show();
                        // .children("input, select")
                        // .attr("required", true);
                        $(".js-stay-type-ppd").hide();
                        // .children("input, select")
                        // .removeAttr("required");
                    } else {
                        if (
                            $("#pd-nationality").val() == "rus" ||
                            $("#pd-nationality").val() == "chn"
                        ) {
                            let language = $("#pd-nationality").val();
                            let labelVal = dic["transl-dynamic"].version1[language];
                            let placeholderVal = dic["transl-dynamic"].version1.eng;

                            $('[name="pos_name"]')
                                .siblings("label")
                                .text(labelVal);
                            $('[name="pos_name"]').attr("placeholder", placeholderVal);
                        } else {
                            $('[name="pos_name"]')
                                .siblings("label")
                                .text("Owner’s Name/Property Name (Require)");
                            $('[name="pos_name"]').attr(
                                "placeholder",
                                "Owner’s Name/Property Name (Require)"
                            );
                        }
                        $(".js-stay-type-ppd").show();
                        // .children("input, select")
                        // .attr("required", true);
                        $(".js-stay-type-hhg").hide();
                        // .children("input, select")
                        // .removeAttr("required");
                    }
                    $("#js-place-dynamic-fields").slideDown();
                } else {
                    $("#js-place-dynamic-fields").slideUp();
                }
            };
            const displayPrevPassengerData = (data, fields) => {
                for (let field in fields) {
                    if (
                        field == "passportphoto" ||
                        field == "accomodationphoto" ||
                        field == "ticketphoto"
                    ) {
                        let numOfPhotos =
                            data.imagesUploaded[field] === undefined
                                ? -1
                                : data.imagesUploaded[field].length;
                        numOfPhotos > 1
                            ? fields[field]
                                .next(".m-custom-upload__filename")
                                .text(`${numOfPhotos} files`)
                            : numOfPhotos == -1
                            ? fields[field].next(".m-custom-upload__filename").text("N/A")
                            : fields[field]
                                .next(".m-custom-upload__filename")
                                .text(data.imagesUploaded[field][0]);
                    } else if (field == "mobileNumCountry") {
                        fields[field].val(data[field]);
                        fields[field]
                            .siblings($(".intl-tel-input"))
                            .children($(".js-contact-numbers"))
                            .intlTelInput("setCountry", data[field]);
                    } else if (field.startsWith("pos")) {
                        let dataValue = data.accomodation[field];
                        if (field == "posType") {
                            posOpenSesame(data.accomodation[field]);
                        }
                        if (
                            fields[field].is("select") &&
                            field !== "posType" &&
                            field !== "posProvince"
                        ) {
                            fields[field]
                                .prepend(
                                    `<option value="${data.accomodation[field]}">${
                                        data.accomodation[field]
                                        }</option>`
                                )
                                .val(dataValue);
                        } else {
                            fields[field].val(dataValue === null ? "" : data.accomodation[field]);
                        }
                    } else {
                        fields[field].val(data[field]);
                    }
                }
            };
            const disableBrowseFile = isTrue => {
                if (isTrue) {
                    $(".m-custom-upload").addClass("-is-disabled");
                } else {
                    $(".m-custom-upload").removeClass("-is-disabled");
                }
            };
            const disableFlagSelect = isTrue => {
                if (isTrue) {
                    $(".flag-container").addClass("-is-disabled");
                } else {
                    $(".flag-container").removeClass("-is-disabled");
                }
            };
            const disableAllFields = (isTrue, formFields) => {
                if (isTrue) {
                    if (!$("#passengerdetails-form").hasClass("-is-disabled")) {
                        $("#passengerdetails-form").addClass("-is-disabled");
                        for (let field in formFields) {
                            if (formFields[field].is("[readonly]")) {
                                // do nothing
                                formFields[field].data("default-readonly", "true");
                            } else {
                                formFields[field].attr("readonly", "readonly");
                            }
                            formFields[field].attr("disabled", "disabled");
                        }
                    }
                } else {
                    if ($("#passengerdetails-form").hasClass("-is-disabled")) {
                        $("#passengerdetails-form").removeClass("-is-disabled");
                        for (let field in formFields) {
                            if (formFields[field].data("default-readonly") == "true") {
                                // do nothing
                            } else {
                                formFields[field].removeAttr("readonly");
                            }
                            formFields[field].removeAttr("disabled");
                        }
                    }
                }
            };
            const scrollTop = () => {
                $("body,html").animate(
                    {
                        scrollTop: 0
                    },
                    500
                );
            };
            const cleanInputValue = () => {
                let form = $("#passengerdetails-form");
                form.find('input:not([type="file"]), textarea, select').each(function () {
                    let cleanVal = DOMPurify.sanitize($(this).val(), {
                        USE_PROFILES: {html: false}
                    });
                    $(this).val(cleanVal);
                });
            };
            const inputFileErrorHandling = imagesNameContainer => {
                $(".m-custom-upload")
                    .not(".-optional")
                    .css("border-color", "#ff2222");
                for (let imgName in imagesNameContainer) {
                    $(`input[data-images-name=${imgName}]`)
                        .parents(".m-custom-upload")
                        .css("border-color", "#d3d2d2");
                }
            };
            const uploadImages = (btn, fd, fn) => {

                $.ajax({
                    url: "/images/upload",
                    data: fd._blob ? fd._blob() : fd,
                    type: "POST",
                    processData: false,
                    contentType: false,
                    dataType: "json",
                    success: function (e) {
                        console.log(e);
                        fn(e);
                        return e;
                    },
                    error: function (e) {
                        console.dir(e);
                        showAlert("Something went wrong. Please try again.", false);
                        enableUploadBtn(btn);
                    },
                    beforeSend: function (xhr) {
                        xhr.setRequestHeader("X-CSRF-Token", $("input[name='_csrfToken']").val());
                    }
                });
            };
            const removeError = () => {
                $(':input[class~="error"], select[class~="error"]').removeClass("error");
                $(".m-custom-upload").css("border-color", "#d3d2d2");
            };
            const validateEmail = email => {
                var regex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
                return regex.test(email);
            };
            const changeSubmitText = (text, button, disabled) => {
                button.text(text);
                if (disabled) {
                    button.css("pointer-events", "none");
                } else {
                    button.css("pointer-events", "auto");
                }
            };
            const hasAllRequiredMedia = fileList => {
                if (
                    fileList.hasOwnProperty("passportphoto") &&
                    fileList.hasOwnProperty("ticketphoto") &&
                    fileList.hasOwnProperty("accomodationphoto")
                ) {
                    return true;
                } else {
                    return false;
                }
            };
            const getUniqueData = arr => [...new Set(arr)];
            const dynamicOption = (elem, arrayOfData, ...elemsToClear) => {
                for (let elemToClear of elemsToClear) {
                    if (elemToClear.children("option").length > 1) {
                        elemToClear.children('option:not([class="js-pos-default"])').remove();
                    }
                }
                let uniqueArrayOfData = getUniqueData(arrayOfData);
                for (let specificData of uniqueArrayOfData) {
                    elem.append(`
    <option value="${specificData}">${specificData}</option>
    `);
                }
            };
            const resizeImage = settings => {
                let file = settings.file;
                let maxSize = settings.maxSize;
                let reader = new FileReader();
                let image = new Image();
                let canvas = document.createElement("canvas");
                let dataURItoBlob = function (dataURI) {
                    let bytes =
                        dataURI.split(",")[0].indexOf("base64") >= 0
                            ? atob(dataURI.split(",")[1])
                            : unescape(dataURI.split(",")[1]);
                    let mime = dataURI
                        .split(",")[0]
                        .split(":")[1]
                        .split(";")[0];
                    let max = bytes.length;
                    let ia = new Uint8Array(max);
                    for (let i = 0; i < max; i++) ia[i] = bytes.charCodeAt(i);
                    return new Blob([ia], {type: mime});
                };
                let resize = function () {
                    let width = image.width;
                    let height = image.height;
                    if (width > height) {
                        if (width > maxSize) {
                            height *= maxSize / width;
                            width = maxSize;
                        }
                    } else {
                        if (height > maxSize) {
                            width *= maxSize / height;
                            height = maxSize;
                        }
                    }
                    canvas.width = width;
                    canvas.height = height;
                    canvas.getContext("2d").drawImage(image, 0, 0, width, height);
                    let dataUrl = canvas.toDataURL("image/jpeg");
                    return dataURItoBlob(dataUrl);
                };
                return new Promise(function (ok, no) {
                    // console.log(file.type);
                    if (!file.type.match(/image.*/)) {
                        no(new Error("Not an image"));
                        return;
                    }
                    reader.onload = function (readerEvent) {
                        image.onload = function () {
                            return ok(resize());
                        };
                        image.src = readerEvent.target.result;
                    };
                    reader.readAsDataURL(file);
                });
            };
            const iterateUploadedFile = async (input, formData) => {
                let itemArr = Array.from(input[0].files);
                for (let item of itemArr) {
                    let dataToAppend = item.type.match(/image.*/)
                        ? await resizeImage({
                            file: item,
                            maxSize: 2000
                        })
                        : item;
                    formData.append(input.attr("name"), dataToAppend);
                }
                return new Promise((resolve, reject) => {
                    resolve(formData);
                    reject(new Error("Something went wrong"));
                });
            };
            const isValidNumber = mobilenum => mobilenum.intlTelInput("isValidNumber");
            const queryPassenger = (id, cf) => {
                $.ajax({
                    url: "/get-passenger",
                    data: {passenger_id: id, stage: "verifier", raw: true},
                    type: "POST",
                    dataType: "json",
                    success: s => {
                        if (s.id) {
                            // console.log(s);
                            cf(s);
                        }
                    },
                    error: (request, status, error) => {
                        console.log("TCL: error", error);
                        console.log("TCL: status", status);
                        console.log("TCL: request", request);
                        showAlert(
                            "Sorry! There's an error while loading your application. Please try refreshing the page.",
                            false
                        );
                        $(".m-form").remove();
                    },
                    beforeSend: function (xhr) {
                        xhr.setRequestHeader("X-CSRF-Token", $("input[name='_csrfToken']").val());
                    }
                });
            };
            const noFileState = elem => {
                elem.css({
                    "pointer-events": "none",
                    "background-color": "#989797"
                });
                elem.text("No previously uploaded file");
            };
            const timePickerButtonIsDisable = (disable, btn) => {
                if (disable) {
                    btn.css("pointer-events", "none");
                } else {
                    btn.css("pointer-events", "auto");
                }
            };
            const hasCorrectNumOfFile = (fileSet, config) => {
                // let msgLabel = {
                //   passportphoto: "Passport Details",
                //   ticketphoto: "Airline Ticket",
                //   accomodationphoto: "Accommodation Details"
                // };
                let val = true;
                let raw = [];
                for (let file in fileSet) {
                    let fileSize = dataSize(fileSet[file]);
                    if (fileSize < config[file].min) {
                        val = false;
                        raw.push(file);
                    }
                }
                return {
                    val,
                    raw
                };
            };
            const fileConditionLogic = (resultFull, mediaUploadConfig) => {
                let message;
                if (dataSize(resultFull.raw) > 1) {
                    resultFull.raw.forEach(function (y) {
                        $(`[name = "${y}[]"]`)
                            .parent()
                            .removeClass("-is-success")
                            .addClass("-is-error");
                    });
                    let html = resultFull.raw.map(x => {
                        return `<li>${mediaUploadConfig[x].err_msg}</li>`;
                    });
                    message = `<ul>${html.join("")}</ul>`;
                } else {
                    $(`[name = "${resultFull.raw[0]}[]"]`)
                        .parent()
                        .removeClass("-is-success")
                        .addClass("-is-error");
                    let singleInput = resultFull.raw;
                    message = `<ul><li>${mediaUploadConfig[singleInput].err_msg}</li></ul>`;
                }
                showAlert(message, false);
            };
            module.exports = {
                passengerFields,
                jsTriggers,
                toolTips,
                convertCountryCode,
                validateSalutation,
                resetSalutationValidation,
                timeConvert,
                resetNumber,
                savePassengerLocally,
                retrieveLocalData,
                giveMeLocalData,
                deleteLocalData,
                hidePdNavigation,
                showPdNavigation,
                disablePaginationBtn,
                enablePaginationBtn,
                uploadImages,
                autoPopulateNumber,
                clearFormFields,
                checkEmptyFields,
                checkNonENFields,
                populateFormFields,
                toIntlNunmber,
                toNationalNunmber,
                dataSize,
                clearInputFile,
                disableUploadBtn,
                nodataUploadBtn,
                enableUploadBtn,
                loadingUploadBtn,
                showOrHideSuccessNotif,
                posOpenSesame,
                displayPrevPassengerData,
                disableBrowseFile,
                disableFlagSelect,
                disableAllFields,
                scrollTop,
                cleanInputValue,
                inputFileErrorHandling,
                showAlert,
                showPassengerNotif,
                removeError,
                validateEmail,
                changeSubmitText,
                hasAllRequiredMedia,
                getUniqueData,
                dynamicOption,
                resetDynamicFields,
                resizeImage,
                iterateUploadedFile,
                replaceLabelText,
                runTranslate,
                isValidNumber,
                queryPassenger,
                noFileState,
                timePickerButtonIsDisable,
                hasCorrectNumOfFile,
                fileConditionLogic
            };
            /* jshint ignore:start */

        }, {}], 5: [function (require, module, exports) {
// TODO: [ ] remove functions for testing
            const localforage = require("localforage");
            const dayjs = require("dayjs");
            const Tooltip = require("tooltip.js");
            const browser = require("browser-detect");
            const adblockDetect = require("adblock-detect");
            const queryString = require("query-string");
            require("weakmap-polyfill");
            require("formdata-polyfill");
            require("../lib/datepicker-setups");
// const Noty = require("noty");
            const pLib = require("../lib/passenger-utils.js");
            const {detectDeviceType, throttle} = require("../lib/common-utils");
// const thailand = require("../lib/thailand.json");
            let thailand;
// const dic = require("../lib/translation.json");
            let dic;
            let mediaUploadConfig;
            $(
                (function (w) {
                    // ! DECLARATION
                    let provinceSelect = $('[name="pos_city_province"]');
                    let districtSelect = $('[name="pos_district"]');
                    let subDistrictSelect = $('[name="pos_sub_district"]');
                    let postCodeInput = $('[name="pos_postcode"]');
                    let browserInfo = browser();
                    let imagesNameContainer = {};
                    let maxSizeLimit = 2000000; //2MB
                    let pdArrayIndexSubtrahend = 0;
                    let paginationBtn = $(".a-paginationbtn");
                    let mobileInput = $("#pd-mobilenum");
                    let allowedCountry;
                    // clear localstorage
                    pLib.deleteLocalData(localforage);
                    console.log(
                        `Hi mom! I'm on ${detectDeviceType()} using ${browserInfo.name}`
                    );
                    adblockDetect(function (adblockDetected) {
                        if (adblockDetected) {
                            console.log("Ad blocker is detected!");
                        } else {
                            console.log("No Ad blocker detected!");
                        }
                    });
                    const {
                        jsBirthdate,
                        jsPassportIssueDate,
                        jsPassportExpiryDate,
                        jsArrivalDate,
                        jsDepartureDate,
                        jsTimePicker,
                        jsPdCancel,
                        jsPdPaginationPrev,
                        jsPdPaginationNext,
                        jsPdSubmit,
                        jsPlaceOfStay,
                        jsDynamicFields
                    } = pLib.jsTriggers;
                    //  ! GET EXTERNAL JSON FILE
                    $.getJSON("/js/lib/translation.json", function (data) {
                        dic = data;
                    }).fail(function (err) {
                        console.error(err);
                    });
                    $.getJSON("/js/lib/mediauploadconfig.json", function (data) {
                        mediaUploadConfig = data;
                    }).fail(function (err) {
                        console.error(err);
                    });
                    // #region forRevisePage
                    // ! QUERY PASSENGER DATA IF PASSENGER ID IS GIVEN
                    function bindformdata() {
                        if (
                            $(".m-form").data("passenger-query-id") &&
                            $(".m-form").data("passenger-query-id") !== "undefined"
                        ) {
                            let passengerId = $(".m-form").data("passenger-query-id");
                            // clean browser storage
                            localforage
                                .clear()
                                .then(function () {
                                    console.log("Database is now empty.");
                                })
                                .catch(function (err) {
                                    console.log(err);
                                });
                            pLib.queryPassenger(passengerId, function (pInfo) {
                                console.table(pInfo);
                                // ! VIEW IMAGE
                                // show images
                                // $(".js-view-image-file").on("click", function() {
                                //   let clickedButton = $(this);
                                //   let btnOffset =
                                //     clickedButton.offset().left -
                                //     clickedButton.closest(".l-form-grid__customwidth").offset().left;
                                //   let halfBtnW = clickedButton.outerWidth() / 2;
                                //   let numOfImage = $(".m-image-viewer").children("img").length;
                                //   let numOfCanvas = $(".m-image-viewer").children("canvas").length;
                                //   if (numOfImage == 0 && numOfCanvas == 0) {
                                //     $(".m-image-viewer__arrow").css("transition-delay", "0.3s");
                                //   } else {
                                //     $(".m-image-viewer__arrow").css("transition-delay", "0s");
                                //     $(".m-image-viewer")
                                //       .children("img, canvas")
                                //       .remove();
                                //   }
                                //   let dataFile = JSON.parse(clickedButton.attr("data-fileimage"));

                                //   for (let img of dataFile) {
                                //     let fileExtension = img.slice(
                                //       (Math.max(0, img.lastIndexOf(".")) || Infinity) + 1
                                //     );
                                //     if (fileExtension == "pdf") {
                                //       $(".m-image-viewer").prepend(`
                                //   <canvas id="${img}"></canvas>
                                //   `);
                                //       // render pdf
                                //       pdfjsLib
                                //         .getDocument(`/images/passengers/${img}`)
                                //         .promise.then(function(pdf) {
                                //           pdf.getPage(1).then(function(page) {
                                //             let scale = 1;
                                //             let viewport = page.getViewport(scale);

                                //             let canvas = document.getElementById(img);
                                //             let context = canvas.getContext("2d");
                                //             canvas.height = viewport.height;
                                //             canvas.width = viewport.width;

                                //             let renderContext = {
                                //               canvasContext: context,
                                //               viewport: viewport
                                //             };
                                //             page.render(renderContext).then(function() {
                                //               console.log("Page rendered!");
                                //             });
                                //           });
                                //         })
                                //         .catch(function(err) {
                                //           console.log(err);
                                //         });
                                //     } else {
                                //       $(".m-image-viewer").prepend(`
                                //   <img style="display:none;" src="/images/passengers/${img}" alt="${img}">
                                //   `);
                                //     }
                                //   }
                                //   $(".m-image-viewer")
                                //     .children("img, canvas")
                                //     .fadeIn(300);
                                //   $(".m-image-viewer").slideDown(300);
                                //   let haldCloseH =
                                //     $(".m-image-viewer")
                                //       .children(".m-image-viewer__close")
                                //       .outerHeight() / 2;
                                //   let halfArrowW = $(".m-image-viewer__arrow").outerWidth() / 2;
                                //   let arrowPosition = btnOffset + halfBtnW - halfArrowW;
                                //   $(".m-image-viewer__arrow").css(
                                //     "transform",
                                //     `translateX(${arrowPosition}px)`
                                //   );
                                //   $(".m-image-viewer__close").css("bottom", -Math.abs(haldCloseH));
                                //   // reposition viewer when in mobile
                                //   if (browserInfo.mobile) {
                                //     let clickedBtnParent = clickedButton.parent();
                                //     $("#js-image-viwer-wrapper").insertAfter(clickedBtnParent);
                                //   }
                                // });
                                // hide images
                                // $(".m-image-viewer__close").on("click", function() {
                                //   $(this)
                                //     .parent(".m-image-viewer")
                                //     .slideUp(300);
                                //   $(this)
                                //     .siblings("img, canvas")
                                //     .fadeOut(300, function() {
                                //       $(this).remove();
                                //     });
                                // });

                                // ! prepopulate fornm data
                                console.log(pInfo);
                                for (let dataKey in pInfo) {
                                    if ($(`[data-key-name="${dataKey}"]`).length) {
                                        if (dataKey == "gender" || dataKey == "salutation") {
                                            $(`[data-key-name="${dataKey}"]`).val(
                                                pInfo[dataKey].toLowerCase()
                                            );
                                        } else if (dataKey == "mobile_country" && pInfo[dataKey] !== "") {
                                            mobileInput.intlTelInput("setCountry", pInfo[dataKey]);
                                        } else if (dataKey == "nationality") {
                                            $(`[data-key-name="${dataKey}"]`).attr(
                                                "data-nationality-val",
                                                pInfo[dataKey]
                                            );
                                            $(`[data-key-name="${dataKey}"]`).val(pInfo[dataKey]);
                                        } else if (
                                            dataKey == "birth_date" ||
                                            dataKey == "passport_issue" ||
                                            dataKey == "passport_expiry" ||
                                            dataKey == "arrival_date" ||
                                            dataKey == "departure_date"
                                        ) {
                                            $(`[data-key-name="${dataKey}"]`).datepicker(
                                                "setDate",
                                                pInfo[dataKey]
                                            );
                                        } else if (
                                            dataKey == "arrival_time" ||
                                            dataKey == "departure_time"
                                        ) {
                                            $(`[data-key-name="${dataKey}"]`).timepicker(
                                                "setTime",
                                                pInfo[dataKey]
                                            );
                                        } else {
                                            $(`[data-key-name="${dataKey}"]`).val(pInfo[dataKey]);
                                        }
                                    } else if (dataKey == "accomodation") {
                                        pLib.posOpenSesame(pInfo[dataKey].type, dic);
                                        for (let accomKey in pInfo[dataKey]) {
                                            if (accomKey == "city" && pInfo[dataKey][accomKey] !== "") {
                                                // populate district options
                                                let currentSelectedProvince = pInfo[dataKey][accomKey];
                                                let defaultDistricts = [];
                                                for (let index in thailand) {
                                                    if (thailand[index].province == currentSelectedProvince) {
                                                        defaultDistricts.push(thailand[index].district);
                                                    }
                                                }
                                                pLib.dynamicOption(
                                                    districtSelect,
                                                    defaultDistricts,
                                                    districtSelect
                                                );
                                            } else if (
                                                accomKey == "district" &&
                                                pInfo[dataKey][accomKey] !== ""
                                            ) {
                                                let selectedDistrict = pInfo[dataKey][accomKey];
                                                let subDistricts = [];
                                                for (let index in thailand) {
                                                    if (thailand[index].district == selectedDistrict) {
                                                        subDistricts.push(thailand[index].subDistrict);
                                                    }
                                                }
                                                pLib.dynamicOption(
                                                    subDistrictSelect,
                                                    subDistricts,
                                                    subDistrictSelect
                                                );
                                            }
                                            console.log("pInfo[dataKey][accomKey]  " + pInfo[dataKey][accomKey]);

                                            $(`[data-key-name="accomodation_${accomKey}"]`).val(
                                                pInfo[dataKey][accomKey]
                                            );
                                            $('select[data-key-name="accomodation_${accomKey}"]').find('option[value="' + pInfo[dataKey][accomKey] + '"]').attr('selected', 'selected');
                                        }
                                    } else if (dataKey == "images") {
                                        for (let imageGroup in pInfo[dataKey]) {
                                            let arr = pInfo[dataKey][imageGroup];
                                            let arrayOfFileName = arr.map(imgData => {
                                                return imgData.name;
                                            });
                                            imagesNameContainer[imageGroup] = arrayOfFileName;
                                            // arr.forEach(function(imgData) {
                                            //   imagesNameContainer[imageGroup] = imgData.name;
                                            // });
                                            $(`.js-view-image-file[data-image-set="${imageGroup}"]`).attr(
                                                `data-fileimage`,
                                                JSON.stringify(arrayOfFileName)
                                            );
                                        }
                                    }
                                }
                                // clear departure date fields and time portions when the arrival date is before the current date + 1 day
                                let formatedData = pInfo.arrival_date.split("/");
                                let dateFormatToUse = `${formatedData[2]}-${formatedData[1]}-${
                                    formatedData[0]
                                    }`;

                                console.log(dayjs(dateFormatToUse).isBefore(dayjs().add(1, "day")));
                                // if (dayjs(dateFormatToUse).isBefore(dayjs().add(1, "day"))) {
                                // $(`[data-key-name="departure_date"]`).datepicker("clearDates");
                                // $(".js-timepicker").val("");
                                // }
                                $(".js-view-image-file").each(function () {
                                    if ($(this).attr("data-fileimage") === undefined) {
                                        pLib.noFileState($(this));
                                    } else {
                                        let imageFileData = JSON.parse($(this).attr("data-fileimage"));
                                        let imageGroup = $(this).attr("data-image-set");
                                        let baseUrl = "/viewimage";
                                        let parameters = queryString.stringify({
                                            fileset: imageGroup,
                                            filename: imageFileData
                                        });
                                        let fullUrl = `${baseUrl}?${parameters}`;
                                        $(this).attr("href", fullUrl);
                                    }
                                });
                                // submit updated application
                                $("#js-updatepd").on(
                                    "click",
                                    throttle(function (e) {
                                        e.preventDefault();
                                        let selfBtn = $(this);
                                        pLib.cleanInputValue();
                                        //trim all textfield before submit
                                        $("#passengerdetails-form").find('input[type=text], textarea').each(function () {
                                            this.value = $(this).val().trim();
                                        });
                                        // check if there's empty required fields
                                        if (pLib.checkEmptyFields()) {
                                            pLib.showAlert(
                                                "Please fill out all required fields in English",
                                                false
                                            );
                                            // watch for changes in error filds
                                            $(':input[class~="error"], select[class~="error"]').change(
                                                function () {
                                                    $(this).removeClass("error");
                                                }
                                            );
                                        } else if (pLib.checkNonENFields()) {
                                            pLib.showAlert(
                                                "Please fill out all required fields in English",
                                                false
                                            );
                                            // watch for changes in error filds
                                            $(':input[class~="error"], select[class~="error"]').change(
                                                function () {
                                                    $(this).removeClass("error");
                                                }
                                            );
                                        } else if (!pLib.validateEmail($('input[name="email"]').val())) {
                                            pLib.showAlert("Please provide a valid email address", false);
                                            //check if user uploaded all 3 needed files
                                        } else if (!pLib.hasAllRequiredMedia(imagesNameContainer)) {
                                            pLib.inputFileErrorHandling(imagesNameContainer);
                                            pLib.showAlert("Upload media files not uploaded", false);
                                        } else if (
                                            !pLib.hasCorrectNumOfFile(imagesNameContainer, mediaUploadConfig)
                                                .val
                                        ) {
                                            let fullResult = pLib.hasCorrectNumOfFile(
                                                imagesNameContainer,
                                                mediaUploadConfig
                                            );
                                            pLib.fileConditionLogic(fullResult, mediaUploadConfig);
                                        } else if (!pLib.isValidNumber(mobileInput)) {
                                            pLib.showAlert("Invalid mobile number", false);
                                            mobileInput.addClass("error");
                                        } else {


                                            /*
		var arrdate=$("#js-datepicker-arrivaldate").val();
		var arrrestddate=$("#hdncurrentdate").val();

		var arrtime=$(".arrivaltime-js-timepicker").val();
		var arrrestdtime=$("#hdncurrenttime1").val();
			var arrobj=arrtime.split(' ');
			var arrhmobj=arrobj[0].split(':');
			var arrrestdhmobj=arrrestdtime.split(':');
			var arrh=arrhmobj[0];
			var arrm=arrhmobj[1];
			var arrrestdh=arrrestdhmobj[0];
			var arrrestdm=arrrestdhmobj[1];
			//arrrestdh= parseInt(arrrestdh)+12;
			if(arrobj[1]=="PM"){
				arrh= parseInt(arrh)==12?parseInt(0):parseInt(arrh);
				arrh=parseInt(arrh)+12;
				if(parseInt(arrh)>24){
					arrh=parseInt(arrh)-24;
					arrdate = arrdate + 1;
					arrobj[1]="AM";
				}
			}
			if(arrobj[1]=="AM"){
				arrh= parseInt(arrh)==12?parseInt(0):parseInt(arrh);
			}
			else{
				arrh= parseInt(arrh);
			}
			var arrrestddateVal = parseInt(arrrestddate.split('/')[0]);
			//if((parseInt(arrdate.split('/')[0])-1)==(parseInt(arrrestddate.split('/')[0]))){
				arrrestdh= 12+parseInt(arrrestdh);
				if(parseInt(arrrestdh)>24){
					arrrestdh=parseInt(arrrestdh)-24;
					arrrestddateVal = arrrestddateVal + 1;
				}
			//}

			if((arrdate.split('/')[1]==arrrestddate.split('/')[1]) && (arrdate.split('/')[2]==arrrestddate.split('/')[2]) && (arrrestddateVal >= arrdate.split('/')[0])){
			if((arrrestddateVal > arrdate.split('/')[0]) || (parseInt(arrh)<parseInt(arrrestdh)) ||((parseInt(arrh)==parseInt(arrrestdh)) && (parseInt(arrm)<parseInt(arrrestdm)))){
				 pLib.showAlert("Please select arrival date and time is after 12 hours from now",false);
				 return false;
			}
			}
			*/
                                            var arrdate = $("#js-datepicker-arrivaldate").val();
                                            var arrtime = $(".arrivaltime-js-timepicker").val();

                                            var arrdatearray = arrdate.split("/");

                                            var arrdatenewdate = arrdatearray[1] + '/' + arrdatearray[0] + '/' + arrdatearray[2];

                                            var arrdatetime = new Date(arrdatenewdate + " " + arrtime);
                                            var mindatetime = new Date().addHours(12);
                                            if (arrdatetime < mindatetime) {
                                                //pLib.showAlert("Please select arrival date and time is after 12 hours from now",false);
                                                //return false;
                                            }

                                            // submit validation
                                            pLib.changeSubmitText("Please wait...", selfBtn, true);
                                            // convert mobile and tel number to international format
                                            pLib.toIntlNunmber(mobileInput);
                                            pLib
                                                .savePassengerLocally(
                                                    localforage,
                                                    pLib.passengerFields,
                                                    passengerCounter,
                                                    imagesNameContainer
                                                )
                                                .then(function (value) {
                                                    console.log(`Passenger ${passengerCounter} info saved`);
                                                    console.table(value);
                                                    passengerCounter += 1;
                                                    passengerFormCounter.val(passengerCounter);
                                                    // grab all data from browser storage
                                                    pLib
                                                        .giveMeLocalData(localforage)
                                                        .then(function (d) {
                                                            console.log(d);
                                                            // ! ajax request to update application
                                                            $.ajax({
                                                                url: "/revised/" + passengerId,
                                                                data: {p: d},
                                                                type: "POST",
                                                                dataType: "json",
                                                                success: s => {
                                                                    console.dir(s);
                                                                    if (s.revised) {
                                                                        pLib.deleteLocalData(localforage);
                                                                        // clear fields
                                                                        // ! FORM RESETS
                                                                        pLib.clearFormFields.partialClear();
                                                                        // reset upload file
                                                                        $('input[type="file"]').each(function () {
                                                                            let input = $(this);
                                                                            let trigger = input.siblings(".js-remove-file");
                                                                            let container = input.closest(".m-custom-upload");
                                                                            pLib.clearInputFile.fullClear(
                                                                                trigger,
                                                                                input,
                                                                                container
                                                                            );
                                                                        });
                                                                        // clear images container
                                                                        for (const prop of Object.getOwnPropertyNames(
                                                                            imagesNameContainer
                                                                        )) {
                                                                            delete imagesNameContainer[prop];
                                                                        }
                                                                        // enable upload file button
                                                                        pLib.enableUploadBtn($(".a-upload-btn"));
                                                                        //hide upload notification
                                                                        pLib.showOrHideSuccessNotif(imagesNameContainer);
                                                                        // ! END FORM RESETS
                                                                        location.href = "/revised-successfully";
                                                                    }


                                                                    if (s.error == 'arrival_date_error') {
                                                                        pLib.showAlert(
                                                                            s.message,
                                                                            false
                                                                        );
                                                                        pLib.changeSubmitText("Continue", selfBtn, false);

                                                                        let IdLastPassengerSaved = passengerCounter - 1;
                                                                        let itemToRemove =
                                                                            IdLastPassengerSaved < 10
                                                                                ? `passenger_0${IdLastPassengerSaved}`
                                                                                : `passenger_${IdLastPassengerSaved}`;
                                                                        // remove last item added in browser storage if ajax request fails
                                                                        localforage
                                                                            .removeItem(itemToRemove)
                                                                            .then(function () {
                                                                                passengerCounter -= 1;
                                                                                passengerFormCounter.val(passengerCounter);
                                                                            })
                                                                            .catch(function (err) {
                                                                                console.log(err);
                                                                            });
                                                                    }
                                                                    /*
							if(s.error == 'arrival_over_departure_error'){
								pLib.showAlert(
								  "Please make sure the departure date and time is less than arrival date and time",
								  false
								);
								pLib.changeSubmitText("Continue", selfBtn, false);

								let IdLastPassengerSaved = passengerCounter - 1;
								let itemToRemove =
								  IdLastPassengerSaved < 10
									? `passenger_0${IdLastPassengerSaved}`
									: `passenger_${IdLastPassengerSaved}`;
								// remove last item added in browser storage if ajax request fails
								localforage
								  .removeItem(itemToRemove)
								  .then(function() {
									passengerCounter -= 1;
									passengerFormCounter.val(passengerCounter);
								  })
								  .catch(function(err) {
									console.log(err);
								  });
							}
							*/
                                                                },
                                                                error: (request, status, error) => {
                                                                    console.log("TCL: error", error);
                                                                    console.log("TCL: status", status);
                                                                    console.log("TCL: request", request);
                                                                    console.log(passengerCounter);
                                                                    let IdLastPassengerSaved = passengerCounter - 1;
                                                                    let itemToRemove =
                                                                        IdLastPassengerSaved < 10
                                                                            ? `passenger_0${IdLastPassengerSaved}`
                                                                            : `passenger_${IdLastPassengerSaved}`;
                                                                    // remove last item added in browser storage if ajax request fails
                                                                    localforage
                                                                        .removeItem(itemToRemove)
                                                                        .then(function () {
                                                                            passengerCounter -= 1;
                                                                            passengerFormCounter.val(passengerCounter);
                                                                        })
                                                                        .catch(function (err) {
                                                                            console.log(err);
                                                                        });
                                                                    pLib.showAlert(
                                                                        "Something went wrong. Please try again.",
                                                                        false
                                                                    );
                                                                    pLib.changeSubmitText("Save", selfBtn, false);
                                                                    pLib.toNationalNunmber(mobileInput);
                                                                },
                                                                beforeSend: function (xhr) {
                                                                    xhr.setRequestHeader(
                                                                        "X-CSRF-Token",
                                                                        $("input[name='_csrfToken']").val()
                                                                    );
                                                                }
                                                            });
                                                        })
                                                        .catch(function (err) {
                                                            console.error(
                                                                `Something went wrong. Error details: ${err}`
                                                            );
                                                            pLib.showAlert(
                                                                "Something went wrong. Please try again.",
                                                                false
                                                            );
                                                            pLib.toNationalNunmber(mobileInput);
                                                        });
                                                });
                                        }
                                    }, 5000)
                                );
                                // $("#passengerdetails-form").submit(e =>
                                //   $("[data-key-name]").each(function() {
                                //     let el = $(this);
                                //     let key = $(el).data("key-name");
                                //     let akey = key.split("_");
                                //     akey.shift();
                                //     akey = akey.join("_");
                                //     $(el).attr(
                                //       "name",
                                //       key.indexOf("accomodation") !== -1
                                //         ? "accomodation[" + akey + "]"
                                //         : key
                                //     );
                                //   })
                                // );
                            });
                        }
                    }

                    // #endregion forRevisePage
                    // // ! AUTO POPULATE NATIONALITY AND NUMBER COUNTRY CODE BASE ON IP ADDRESS
                    // pLib.getLocationInfo(pLib.passengerFields.nationality, dic);
                    //! TOOLTIPS
                    for (let toolTip in pLib.toolTips) {
                        new Tooltip(document.querySelector(toolTip), {
                            placement: "top-start",
                            title: pLib.toolTips[toolTip],
                            trigger: detectDeviceType() == "Mobile" ? "click" : "hover",
                            html: true,
                            template:
                                '<div class="tooltip m-tooltip" role="tooltip"><div class="tooltip-arrow m-tooltip__arrow"></div><div class="tooltip-inner m-tooltip__inner"></div></div>'
                        });
                    }
                    // ! CUSTOM INPUT FILE FOR IMAGE UPLOAD

                    $('.m-form__images input[type="file"]').change(function () {
                        let numOfFiles = $(this)[0].files.length;
                        let thisClosebtn = $(this).siblings(".js-remove-file");
                        let files = $(this)[0].files[0].name;
                        let cleanFilename = files.replace(/\.[^/.]+$/, "");
                        let numOfClosebtn = thisClosebtn.length;
                        let fileList = $(this)[0].files;
                        let fileListArr = Array.from(fileList);
                        // console.log(fileListArr);
                        let aboveMaxSize = false;
                        let notImage = false;
                        let itsButton = $(this)
                            .closest(".m-custom-upload")
                            .siblings("button");
                        // enable upload button
                        pLib.enableUploadBtn(itsButton);
                        // let totalFileSize = 0;
                        // check for each file size
                        for (let file of fileListArr) {
                            if (file.size > maxSizeLimit) {
                                aboveMaxSize = true;
                            }
                            if (!file.type.match(/image.*/ && !file.type === "application/pdf")) {
                                notImage = true;
                            }
                        }
                        // check total file size
                        // for (let file of fileList) {
                        //   totalFileSize += file.size;
                        // }
                        // totalFileSize > maxSizeLimit ? (aboveMaxSize = true) : (aboveMaxSize = false);
                        if (aboveMaxSize && notImage) {
                            $(this)
                                .closest(".m-custom-upload")
                                .removeClass("-is-success")
                                .addClass("-is-error");
                        } else {
                            $(this)
                                .closest(".m-custom-upload")
                                .removeClass("-is-error")
                                .addClass("-is-success");
                        }

                        if (numOfFiles > 1) {
                            $(this)
                                .next("span")
                                .text(`${numOfFiles} files`);
                        } else {
                            $(this)
                                .next("span")
                                .text(cleanFilename);
                        }
                        if (numOfClosebtn > 0) {
                            thisClosebtn.remove();
                        }
                        $(this).next("span").after(`
    <a class="js-remove-file" href="#">X</a>
    `);
                    });
                    // remove file when x is click
                    $(document).on("click", ".js-remove-file", function () {
                        let trigger = $(this);
                        let input = trigger.siblings("input[type=file]");
                        let container = trigger.closest(".m-custom-upload");
                        let fileDeleted = input.data("images-name");
                        pLib.clearInputFile.fullClear(trigger, input, container);
                        pLib.enableUploadBtn(container.siblings("button"));
                        // remove files in imageNameContainer
                        if (imagesNameContainer.hasOwnProperty(fileDeleted)) {
                            delete imagesNameContainer[fileDeleted];
                            console.log(pLib.dataSize(imagesNameContainer));
                            pLib.showOrHideSuccessNotif(imagesNameContainer);
                        }
                    });
                    // reset file display when browse is click
                    $('.m-form__images input[type="file"] ~ label').on("click", function () {
                        let trigger = $(this).siblings(".js-remove-file");
                        let input = $(this).siblings("input[type=file]");
                        let container = $(this).closest(".m-custom-upload");
                        let fileDeleted = input.data("images-name");
                        // remove files in imageNameContainer
                        if (imagesNameContainer.hasOwnProperty(fileDeleted)) {
                            delete imagesNameContainer[fileDeleted];
                            pLib.showOrHideSuccessNotif(imagesNameContainer);
                        }
                        pLib.clearInputFile.fullClear(trigger, input, container);
                        pLib.enableUploadBtn(container.siblings("button"));
                    });
                    //! DATE PICKER
                    // date of birth
                    jsBirthdate.datepicker({
                        todayHighlight: true,
                        autoclose: true,
                        startView: 2,
                        format: "dd/mm/yyyy",
                        startDate: "-110y",
                        endDate: "+1m",
                        language: "en-US"
                    });
                    // passport issue date
                    jsPassportIssueDate.datepicker({
                        todayHighlight: true,
                        autoclose: true,
                        format: "dd/mm/yyyy",
                        endDate: "+0d",
                        language: "en-US"
                    });
                    // passport expiry date
                    jsPassportExpiryDate.datepicker({
                        todayHighlight: true,
                        autoclose: true,
                        format: "dd/mm/yyyy",
                        startDate: "+31d",
                        endDate: "+20y",
                        language: "en-US"
                    });
                    // passport issue and expiry date validation
                    // * set default expiry date +5 year from issue date
                    // * expiry date cannot be earlier than issue date
                    jsPassportIssueDate.change(function () {
                        let passportIssue = $(this).datepicker("getDate");
                        let passportExpiryShould = dayjs(passportIssue).add(5, "years").$d;
                        jsPassportExpiryDate.datepicker("setDate", passportExpiryShould);

                        let jsPassportExpiryDatemin = jsPassportExpiryDate.datepicker("getDate");
                        let jsArrivalDateMin = jsArrivalDate.datepicker("getDate");
                        if (jsPassportExpiryDatemin == null) {
                            var cdate = new Date();
                            let ddm = dayjs(cdate).add(31, "days").$d;
                            jsPassportExpiryDate.datepicker("setStartDate", ddm);
                        } else if (jsPassportExpiryDatemin < jsArrivalDateMin) {
                            jsPassportExpiryDate.val("");
                        } else {
                            if (jsArrivalDateMin != null) {
                                let departureDateMax = dayjs(jsArrivalDateMin).add(31, "days").$d;
                                if (jsPassportExpiryDatemin == null || jsPassportExpiryDatemin < departureDateMax) {
                                    jsPassportExpiryDate.val("");
                                }
                                var cdate = new Date();
                                if (cdate < departureDateMax) {
                                    jsPassportExpiryDate.datepicker("setStartDate", departureDateMax);
                                }
                            }
                        }

                    });
                    // * remove expiry date mindate when issue date is open
                    jsPassportIssueDate.datepicker().on("show", function () {
                        // jsPassportExpiryDate.datepicker("setStartDate", "-300y");
                        //console.log("datepicker open");
                    });
                    jsPassportExpiryDate.datepicker().on("show", function () {
                        let jsPassportIssueDateMin = jsPassportIssueDate.datepicker("getDate");
                        if (jsPassportIssueDateMin != null && jsPassportIssueDateMin != "" && jsPassportIssueDateMin != undefined) {
                            let departureDateMax = dayjs(jsPassportIssueDateMin).add(31, "days").$d;
                            var cdate = new Date();
                            if (cdate < departureDateMax) {
                                jsPassportExpiryDate.datepicker("setStartDate", departureDateMax);
                            }
                        }
                        console.log("datepicker open");
                    });
                    var currday = new Date();
                    var nov15th = new Date("15 Nov 2018")
                    var diffdays = Math.round((nov15th - currday) / (1000 * 60 * 60 * 24)) + 1;
                    console.log("nov15th  " + nov15th + " currday  " + currday + " islessthan " + Math.round((nov15th - currday) / (1000 * 60 * 60 * 24)));
                    diffdays = (diffdays < 1) ? 1 : diffdays;
                    var fdiffdays = "+" + diffdays + "d";
                    // arrivaldate date
                    jsArrivalDate.datepicker({
                        todayHighlight: true,
                        autoclose: true,
                        format: "dd/mm/yyyy",
                        startDate: fdiffdays,
                        endDate: "+30D",
                        startView: 0,
                        language: "en-US"
                    });
                    jsArrivalDate.change(function () {
                        let arrivalDate = $(this).datepicker("getDate");
                        jsDepartureDate.datepicker("setDate", arrivalDate);
                        $(".js-timepicker").val("");
                    });
                    jsArrivalDate.datepicker().on("show", function () {
                        jsDepartureDate.datepicker("setStartDate", "-12h");
                        jsDepartureDate.datepicker("setEndDate", "+10y");
                    });
                    jsArrivalDate.datepicker().on("hide", function () {
                        let departureDateMin = $(this).datepicker("getDate");
                        console.log(departureDateMin);
                        if (departureDateMin != null) {
                            let departureDateMax = dayjs(departureDateMin).add(14, "days").$d;
                            jsDepartureDate.datepicker("setStartDate", departureDateMin);
                            jsDepartureDate.datepicker("setEndDate", departureDateMax);

                            let jsPassportExpiryDatemin = jsPassportExpiryDate.datepicker("getDate");
                            console.log("jsPassportExpiryDatemin  " + jsPassportExpiryDatemin);
                            if (departureDateMin != null) {
                                departureDateMax = dayjs(departureDateMin).add(31, "days").$d;
                                console.log("jsPassportExpiryDatemin  " + jsPassportExpiryDatemin + "  departureDateMax  " + departureDateMax);
                                if (jsPassportExpiryDatemin != null && jsPassportExpiryDatemin < departureDateMax) {
                                    jsPassportExpiryDate.val("");
                                }

                                var cdate = new Date();
                                if (cdate < departureDateMax) {
                                    jsPassportExpiryDate.datepicker("setStartDate", departureDateMax);
                                }
                            }
                        }
                    });
                    //departure date
                    jsDepartureDate.datepicker({
                        autoclose: true,
                        format: "dd/mm/yyyy",
                        startView: 0,
                        language: "en-US"
                    });

                    // ! TIME PICKER
                    $(".js-timepicker").timepicker({
                        disableFocus: true,
                        minuteStep: 1,
                        defaultTime: false,
                        showInputs: false,
                        showMeridian: false
                    });
                    // set default value to departure time
                    $('[name="arrival_time"]')
                        .timepicker()
                        .on("changeTime.timepicker", function (e) {
                            pLib.timePickerButtonIsDisable(
                                false,
                                $('[data-action="toggleMeridian"]')
                            );
                            let hourDiff = 1;
                            let dtDefaultHour =
                                e.time.hours + hourDiff > 12 ? 1 : e.time.hours + hourDiff;
                            let dtDefaultMinute = e.time.minutes;
                            let dtDefaultMeridian;
                            if (dtDefaultHour == 12) {
                                dtDefaultMeridian = e.time.meridian == "AM" ? "PM" : "AM";
                            } else {
                                dtDefaultMeridian = e.time.meridian;
                            }
                            $('[name="departure_time"]').timepicker(
                                "setTime",
                                `${dtDefaultHour}:${dtDefaultMinute} ${dtDefaultMeridian}`
                            );
                        });
                    // ! Time validation
                    $('[name="departure_time"]')
                        .timepicker()
                        .on("show.timepicker", function (e) {
                            let arrivalDate = jsArrivalDate.datepicker("getDate");
                            let departureDate = jsDepartureDate.datepicker("getDate");
                            let isTheSameDate = dayjs(arrivalDate).isSame(dayjs(departureDate));
                            // validate time if the same date
                            if (isTheSameDate) {
                                let arrivalMeridian = $('[name="arrival_time"]').data("timepicker")
                                    .meridian;
                                if (arrivalMeridian == "PM") {
                                    pLib.timePickerButtonIsDisable(
                                        true,
                                        $('[data-action="toggleMeridian"]')
                                    );
                                } else {
                                    pLib.timePickerButtonIsDisable(
                                        false,
                                        $('[data-action="toggleMeridian"]')
                                    );
                                }
                            } else {
                                // reset all timepicker buttons
                                pLib.timePickerButtonIsDisable(
                                    false,
                                    $('[data-action="toggleMeridian"]')
                                );
                            }
                        });
                    $('[name="departure_time"]')
                        .timepicker()
                        .on("changeTime.timepicker", function (e) {
                            let arrivalDate = jsArrivalDate.datepicker("getDate");
                            let departureDate = jsDepartureDate.datepicker("getDate");
                            let isTheSameDate = dayjs(arrivalDate).isSame(dayjs(departureDate));
                            // validate time if the same date
                            if (isTheSameDate) {
                                let arrivalHour = $('[name="arrival_time"]').data("timepicker").hour;
                                let arrivalMinute = $('[name="arrival_time"]').data("timepicker")
                                    .minute;
                                let arrivalMeridian = $('[name="arrival_time"]').data("timepicker")
                                    .meridian;
                                if (e.time.meridian == arrivalMeridian) {
                                    if (arrivalMeridian == "PM") {
                                        if (e.time.hours == 11) {
                                            pLib.timePickerButtonIsDisable(
                                                true,
                                                $('[data-action="incrementHour"]')
                                            );
                                            if (e.time.minutes == 59) {
                                                pLib.timePickerButtonIsDisable(
                                                    true,
                                                    $('[data-action="incrementMinute"]')
                                                );
                                            } else {
                                                pLib.timePickerButtonIsDisable(
                                                    false,
                                                    $('[data-action="incrementMinute"]')
                                                );
                                            }
                                        } else {
                                            pLib.timePickerButtonIsDisable(
                                                false,
                                                $('[data-action="incrementHour"]')
                                            );
                                        }
                                    }
                                    // condition for disabling hour button
                                    if (e.time.hours == arrivalHour) {
                                        pLib.timePickerButtonIsDisable(
                                            true,
                                            $('[data-action="decrementHour"]')
                                        );
                                        if (e.time.minutes <= arrivalMinute) {
                                            pLib.timePickerButtonIsDisable(
                                                true,
                                                $('[data-action="decrementMinute"]')
                                            );
                                        } else {
                                            pLib.timePickerButtonIsDisable(
                                                true,
                                                $('[data-action="decrementMinute"]')
                                            );
                                        }
                                    } else {
                                        pLib.timePickerButtonIsDisable(
                                            false,
                                            $('[data-action="decrementHour"]')
                                        );
                                    }
                                } else {
                                    pLib.timePickerButtonIsDisable(
                                        false,
                                        $('[data-action="decrementHour"]')
                                    );
                                    pLib.timePickerButtonIsDisable(
                                        false,
                                        $('[data-action="decrementMinute"]')
                                    );
                                    if (
                                        e.time.hours < arrivalHour ||
                                        (e.time.hours == arrivalHour && e.time.minutes < arrivalMinute)
                                    ) {
                                        // disable channging meridian
                                        pLib.timePickerButtonIsDisable(
                                            true,
                                            $('[data-action="toggleMeridian"]')
                                        );
                                    } else {
                                        // enablemeridian
                                        pLib.timePickerButtonIsDisable(
                                            false,
                                            $('[data-action="toggleMeridian"]')
                                        );
                                    }
                                }
                            } else {
                                // reset all timepicker button
                                pLib.timePickerButtonIsDisable(
                                    false,
                                    $('[data-action="toggleMeridian"]')
                                );
                                pLib.timePickerButtonIsDisable(
                                    false,
                                    $('[data-action="incrementMinute"]')
                                );
                                pLib.timePickerButtonIsDisable(
                                    false,
                                    $('[data-action="decrementMinute"]')
                                );
                                pLib.timePickerButtonIsDisable(
                                    false,
                                    $('[data-action="incrementHour"]')
                                );
                                pLib.timePickerButtonIsDisable(
                                    false,
                                    $('[data-action="decrementHour"]')
                                );
                            }
                        });
                    // jsTimePicker.timepicker().on("hide.timepicker", function(e) {
                    //   let theTime = e.time.value;
                    //   let theTimeTf = pLib.timeConvert(theTime);
                    //   let arvlDate = $("#js-datepicker-arrivaldate").datepicker("getDate");
                    //   // let formatedArrivalDate = moment(arvlDate).format("YYYY-MM-DD");
                    // });
                    // ! VALIDATING SALUTATION
                    jsBirthdate.add("#js-datepicker-arrivaldate").on("change", function () {
                        let dateOfBirth = jsBirthdate.datepicker("getDate");
                        let dateOfArrival = jsArrivalDate.datepicker("getDate");
                        if (dateOfBirth != null && dateOfArrival != null) {
                            let birthArrivalDiff = dayjs(dateOfArrival).diff(dateOfBirth, "years");
                            pLib.validateSalutation(birthArrivalDiff);
                        }
                    });
                    // ! MOBILE AND TELEPHONE NUMBER LIBRARY
                    let countryData = $.fn.intlTelInput.getCountryData();
                    let addressDropdown = $("#pd-nationality");
                    let bothNumberInput = $(".js-telmobile-input");
                    // initialise plugin for mobile num
                    mobileInput.intlTelInput({
                        initialCountry: "auto",
                        geoIpLookup: function (callback) {
                            $.get("https://ipinfo.io", function () {
                            }, "jsonp").always(function (
                                resp
                            ) {
                                var countryCode = resp && resp.country ? resp.country : "";
                                callback(countryCode);
                            });
                        },
                        utilsScript: "/js/vendor/utils.js",
                        autoPlaceholder: "aggressive"
                    });
                    // populate the country dropdown
                    $.when(
                        $.getJSON("/js/lib/allowedCountry.json", function (data) {
                            allowedCountry = data;
                        })
                    ).then(function () {
                        let aCArray = [];
                        for (let code in allowedCountry) {
                            aCArray.push(code);
                        }
                        $.each(countryData, function (i, country) {
                            let thisIso2 = country.iso2;

                            if (aCArray.includes(thisIso2)) {
                                let thisIso3 = pLib.convertCountryCode.toIso3(thisIso2);
                                addressDropdown.append(
                                    $("<option></option>")
                                        .attr({
                                            value: thisIso3,
                                            "data-iso2": thisIso2
                                        })
                                        .text(allowedCountry[thisIso2].label)
                                );
                            }
                        });
                        if (typeof addressDropdown.data("nationality-val") !== "undefined") {
                            addressDropdown.val(addressDropdown.data("nationality-val")).trigger('change');
                        }
                    });
                    // listen to the address dropdown for changes
                    addressDropdown.change(function () {
                        let selectedCountry = pLib.convertCountryCode.toIso2($(this).val());
                        mobileInput.intlTelInput("setCountry", selectedCountry);
                    });
                    // validate number input on blur
                    bothNumberInput.blur(function () {
                        pLib.resetNumber($(this));
                        if ($.trim($(this).val())) {
                            if ($(this).intlTelInput("isValidNumber")) {
                                $(this).addClass("valid");
                                // convert number to international format
                                // pLib.toIntlNunmber($(this));
                            } else {
                                $(this).addClass("error");
                            }
                        }
                    });
                    // remove error/valid class when changecountry, keyup, change
                    bothNumberInput.on("keyup change countrychange", function () {
                        pLib.resetNumber($(this));
                    });
                    // change number country code when flag is change
                    mobileInput.on("countrychange", function (e, countryData) {
                        $('input[name="mobileNumCountry"]').val(countryData.iso2);
                    });
                    // ! SAVING, RETRIEVING, AND DELETING PASSENGER'S INFO LOCALLY
                    // configuration
                    localforage.config({
                        driver: [localforage.INDEXEDDB, localforage.LOCALSTORAGE],
                        name: "passengerDetails",
                        storeName: "passengerDetails"
                    });
                    // initialize passenger counters
                    let passengerCounter;
                    let passengerFormCounter = $("#js-passengerCounter");
                    let passengerNavigation = $(".m-passenger-pagination");
                    // check if there are saved data locally
                    localforage
                        .length()
                        .then(function (l) {
                            // set the initial value of the counters
                            passengerCounter = l + 1;
                            passengerFormCounter.val(passengerCounter);
                            // hide form pagination when there's no passenger info saved locally
                            if (l == 0) {
                                pLib.hidePdNavigation(passengerNavigation);
                            }
                        })
                        .catch(function (err) {
                            console.error(`Failed to check saved data locally. More info: ${err}`);
                            pLib.showAlert("Failed to check saved data locally.", false);
                        });
                    //* save items
                    $("#js-addpassenger").on("click", function () {
                        console.log(passengerCounter);
                        console.log(passengerFormCounter.val());
                        // check form counter : helps determine if the user came from prev passenger navigation state
                        if (passengerFormCounter.val() != passengerCounter) {
                            // revert all the dom default behaviour
                            pLib.disableAllFields(false, pLib.passengerFields);
                            pLib.disableFlagSelect(false);
                            pLib.disableBrowseFile(false);
                            pLib.enableUploadBtn($(".a-upload-btn"));
                            pLib.clearFormFields.fullClear();
                            pLib.clearInputFile.partialClear();
                            // set correct form counter value
                            passengerFormCounter.val(passengerCounter);
                            // reset pagination counter
                            pdArrayIndexSubtrahend = 0;
                            // disable next button
                            pLib.disablePaginationBtn(jsPdPaginationNext);
                            // smooth scroll to top
                            pLib.scrollTop();
                            // enable prev button
                            pLib.enablePaginationBtn($("#js-pdpagination-prev"));
                        } else {
                            pLib.cleanInputValue();
                            // check empty fields
                            if (pLib.checkEmptyFields()) {
                                pLib.showAlert(
                                    "Please fill out all required fields in English",
                                    false
                                );
                                // watch for changes in error filds
                                $(':input[class~="error"], select[class~="error"]').change(
                                    function () {
                                        $(this).removeClass("error");
                                    }
                                );
                            } else if (pLib.checkNonENFields()) {
                                pLib.showAlert(
                                    "Please fill out all required fields in English",
                                    false
                                );
                                // watch for changes in error filds
                                $(':input[class~="error"], select[class~="error"]').change(
                                    function () {
                                        $(this).removeClass("error");
                                    }
                                );
                            } else if (!pLib.validateEmail($('input[name="email"]').val())) {
                                pLib.showAlert("Please provide a valid email address", false);
                            } else if (!pLib.hasAllRequiredMedia(imagesNameContainer)) {
                                pLib.inputFileErrorHandling(imagesNameContainer);

                                pLib.showAlert("Upload media files not uploaded", false);
                            } else if (
                                !pLib.hasCorrectNumOfFile(imagesNameContainer, mediaUploadConfig).val
                            ) {
                                let fullResult = pLib.hasCorrectNumOfFile(
                                    imagesNameContainer,
                                    mediaUploadConfig
                                );
                                pLib.fileConditionLogic(fullResult, mediaUploadConfig);
                            } else if (!pLib.isValidNumber(mobileInput)) {
                                pLib.showAlert("Invalid mobile number", false);
                                mobileInput.addClass("error");
                            } else {
                                $.ajax({
                                    url: "/checkIfDateError",
                                    data: {
                                        arrival_date: $('input[name="arrival_date"]').val(),
                                        arrival_time: $('input[name="arrival_time"]').val(),
                                        departure_date: $('input[name="departure_date"]').val(),
                                        departure_time: $('input[name="departure_time"]').val(),
                                        hourToCheck: '48'
                                    },
                                    type: "POST",
                                    dataType: "json",
                                    success: s => {
                                        if (s.error == 'arrival_date_error') {
                                            pLib.showAlert(
                                                s.message,
                                                false
                                            );
                                            return false;

                                            /*
					else if(s.msg == 'arrival_over_departure_error'){
						pLib.showAlert(
						   "Please make sure the departure date and time is less than arrival date and time",
						   false
						);
						return false;
					*/
                                        } else {

                                            // TODO : [] client-side validation
                                            // convert mobile and tel number to international format
                                            pLib.toIntlNunmber(mobileInput);
                                            console.log(imagesNameContainer);
                                            console.log(pLib.dataSize(imagesNameContainer));
                                            console.log(
                                                `Passenger form counter is ${passengerFormCounter.val()}`
                                            );
                                            pLib
                                                .savePassengerLocally(
                                                    localforage,
                                                    pLib.passengerFields,
                                                    passengerCounter,
                                                    imagesNameContainer
                                                )
                                                .then(function (value) {
                                                    console.log(`Passenger ${passengerCounter} info saved`);
                                                    console.table(value);
                                                    passengerCounter += 1;
                                                    passengerFormCounter.val(passengerCounter);
                                                    if (passengerCounter == 2) {
                                                        pLib.showPdNavigation(passengerNavigation);
                                                    }
                                                    // clear fields
                                                    pLib.clearFormFields.partialClear();
                                                    // clear input file
                                                    $('input[type="file"]').each(function () {
                                                        let input = $(this);
                                                        let trigger = input.siblings(".js-remove-file");
                                                        let container = input.closest(".m-custom-upload");
                                                        pLib.clearInputFile.fullClear(trigger, input, container);
                                                    });
                                                    // clear image name data
                                                    for (const prop of Object.getOwnPropertyNames(
                                                        imagesNameContainer
                                                    )) {
                                                        delete imagesNameContainer[prop];
                                                    }
                                                    // hide upload success notification
                                                    pLib.showOrHideSuccessNotif(imagesNameContainer);
                                                    // enable upload button
                                                    pLib.enableUploadBtn($(".a-upload-btn"));
                                                    // enable browse file
                                                    pLib.disableBrowseFile(false);
                                                    // smooth scroll to top
                                                    pLib.scrollTop();
                                                    // show notification
                                                    // reset salutation
                                                    pLib.resetSalutationValidation();
                                                    pLib.showPassengerNotif();
                                                })
                                                .catch(function (err) {
                                                    pLib.showAlert(
                                                        "Something went wrong. Please review your data and try again",
                                                        false
                                                    );
                                                    pLib.toNationalNunmber(mobileInput);
                                                    console.error(`Something went wrong. Error details: ${err}`);
                                                });

                                        }
                                    },
                                    error: (request, status, error) => {
                                        pLib.showAlert(
                                            "Something is wrong with arrival date and time",
                                            false
                                        );
                                        return false;
                                    }
                                });
                            }
                        }
                    });

                    //* retrieve items - pagination
                    const navigatePassenger = (btnId, thisBtn) => {
                        // remove error class
                        pLib.removeError();
                        // disable browse file
                        pLib.disableBrowseFile(true);

                        // disable flag select
                        pLib.disableFlagSelect(true);
                        // disable all fields
                        pLib.disableAllFields(true, pLib.passengerFields);
                        localforage.keys().then(function (keys) {
                            // console.log(passengerCounter);
                            let promises = keys.map(function (key) {
                                return localforage.getItem(key);
                            });
                            Promise.all(promises)
                                .then(function (results) {
                                    let currentPassenger =
                                        passengerCounter - 1 - pdArrayIndexSubtrahend;
                                    let lastPassengerSaved = passengerCounter - 1;
                                    if (btnId == "js-pdpagination-prev") {
                                        // when prev button is click
                                        console.log("Previous passenger data");
                                        console.log(`The currentPassenger is ${currentPassenger}`);
                                        console.log(`The subtrahend is ${pdArrayIndexSubtrahend}`);
                                        console.table(results[currentPassenger - 1]);
                                        pLib.displayPrevPassengerData(
                                            results[currentPassenger - 1],
                                            pLib.passengerFields
                                        );
                                        // console.log(currentPassenger);
                                        if (currentPassenger != 0) {
                                            pdArrayIndexSubtrahend++;
                                            console.log(
                                                `The subtrahend when currentPassenger is not 0 is ${pdArrayIndexSubtrahend}`
                                            );
                                        }
                                        // disable prev button
                                        if (currentPassenger == 1) {
                                            pLib.disablePaginationBtn(thisBtn);
                                        }
                                        //enabled next utton
                                        if (currentPassenger < lastPassengerSaved) {
                                            pLib.enablePaginationBtn(jsPdPaginationNext);
                                        }
                                    } else {
                                        // when next button is click
                                        console.log("Next passenger data");
                                        console.log(`The currentPassenger is ${currentPassenger}`);
                                        console.log(`The subtrahend is ${pdArrayIndexSubtrahend}`);
                                        console.table(results[currentPassenger + 1]);
                                        pLib.displayPrevPassengerData(
                                            results[currentPassenger + 1],
                                            pLib.passengerFields
                                        );
                                        if (currentPassenger < lastPassengerSaved - 1) {
                                            pdArrayIndexSubtrahend--;
                                            console.log(
                                                `The subtrahend when currentPassenger is not 0 is ${pdArrayIndexSubtrahend}`
                                            );
                                        }
                                        // disable next button
                                        if (currentPassenger + 2 == lastPassengerSaved) {
                                            pLib.disablePaginationBtn(thisBtn);
                                        }
                                        // enable prev button
                                        if (currentPassenger >= 0) {
                                            pLib.enablePaginationBtn(jsPdPaginationPrev);
                                        }
                                    }
                                    // disbale upload buton when user navigates
                                    $(".m-custom-upload").each(function () {
                                        if (
                                            $(this)
                                                .children(".m-custom-upload__filename")
                                                .text() !== "N/A"
                                        ) {
                                            pLib.disableUploadBtn($(this).siblings(".a-upload-btn"));
                                        } else {
                                            pLib.nodataUploadBtn($(this).siblings(".a-upload-btn"));
                                        }
                                    });
                                })
                                .catch(function (err) {
                                    console.error(`Something went wrong. Error details: ${err}`);
                                    pLib.showAlert("Something went wrong. Please try again.", false);
                                });
                        });
                    };
                    paginationBtn.on("click", function () {
                        let btnId = $(this).attr("id");
                        let thisBtn = $(this);
                        let acceptConfirmation = true;

                        // check if user has incomplete form
                        if (passengerFormCounter.val() == passengerCounter) {
                            // let confirmation = confirm(
                            //   "Changes you made in the current form will not be saved when you start navigating to previous passengers."
                            // );
                            pLib.showAlert(
                                "Changes you made in the current form will not be saved when you start navigating to previous passengers.",
                                true
                            );
                            // confirmation == true
                            //   ? (acceptConfirmation = true)
                            //   : (acceptConfirmation = false);
                            $("#js-confirm-true")
                                .off()
                                .on("click", function () {
                                    console.log("confirm clicked");
                                    navigatePassenger(btnId, thisBtn);
                                    $(".m-alert").hide();
                                });
                        } else {
                            navigatePassenger(btnId, thisBtn);
                        }
                    });
                    //* retrieve all passenger info saved in local

                    //* delete items
                    $(jsPdCancel).on("click", function () {
                        pLib.deleteLocalData(localforage);
                    });
                    // ! HANDLE IMAGE UPLOAD
                    $(".a-upload-btn").each(function () {
                        // w.Iarray = [];
                        $(this).on("click", function (e) {
                            let selfBtn = $(this);
                            e.preventDefault();
                            let f = $(this)
                                .prev()
                                .find('input[type="file"]');
                            // check if user select a file to upload
                            let inputFileList = f[0].files;
                            let inputFileListArr = Array.from(inputFileList);
                            let fileLength = inputFileList.length;
                            let aboveMaxSize = false;
                            let notImage = false;
                            // check for each file size
                            for (let file of inputFileListArr) {
                                if (file.size > maxSizeLimit) {
                                    aboveMaxSize = true;
                                }
                                if (!file.type.match(/image.*/) && file.type != "application/pdf") {
                                    notImage = true;
                                }
                            }
                            if (fileLength == 0) {
                                pLib.showAlert("Upload media files not uploaded", false);
                            } else if (notImage && aboveMaxSize) {
                                pLib.showAlert(
                                    "The selected document is beyond file size limit",
                                    false
                                );
                            } else if (notImage) {
                                pLib.showAlert(
                                    "Only image file formats are allowed in this field",
                                    false
                                );
                            } else {
                                pLib.loadingUploadBtn(selfBtn);
                                let fd = new FormData();
                                pLib.iterateUploadedFile(f, fd).then(function (formD) {
                                    pLib.uploadImages(selfBtn, formD, e => {
                                        console.log("TCL: e", e);
                                        for (let v in e) {
                                            // w.Iarray[v] = e[v];
                                            imagesNameContainer[v] = e[v];
                                            console.log(`${v} - Image uploaded`);
                                            // modify upload button
                                            pLib.disableUploadBtn(selfBtn);
                                            pLib.showOrHideSuccessNotif(imagesNameContainer);
                                        }
                                    });
                                });
                            }
                        });
                    });

                    // ! For testing: Populate form fields - except file upload
                    $("#js-populatefields").on("click", function () {
                        pLib.populateFormFields(dayjs);
                        pLib.autoPopulateNumber();
                    });
                    // ! SUBMIT PASSENGER INFO
                    jsPdSubmit.on(
                        "click",
                        throttle(function (e) {
                            e.preventDefault();
                            let selfBtn = $(this);

                            //trim all textfield before submit
                            $("#passengerdetails-form").find('input[type=text], textarea').each(function () {
                                this.value = $(this).val().trim();
                            });
                            // check if user came from navigation state
                            if (passengerFormCounter.val() == passengerCounter) {
                                pLib.cleanInputValue();

                                // check if there's empty required fields
                                if (pLib.checkEmptyFields()) {
                                    pLib.showAlert(
                                        "Please fill out all required fields in English",
                                        false
                                    );
                                    // watch for changes in error filds
                                    $(':input[class~="error"], select[class~="error"]').change(
                                        function () {
                                            $(this).removeClass("error");
                                        }
                                    );
                                } else if (pLib.checkNonENFields()) {
                                    pLib.showAlert(
                                        "Please fill out all required fields in English",
                                        false
                                    );
                                    // watch for changes in error filds
                                    $(':input[class~="error"], select[class~="error"]').change(
                                        function () {
                                            $(this).removeClass("error");
                                        }
                                    );
                                } else if (!pLib.validateEmail($('input[name="email"]').val())) {
                                    pLib.showAlert("Please provide a valid email address", false);
                                    //check if user uploaded all 3 needed files
                                } else if (!pLib.hasAllRequiredMedia(imagesNameContainer)) {
                                    pLib.inputFileErrorHandling(imagesNameContainer);
                                    pLib.showAlert("Upload media files not uploaded", false);
                                } else if (
                                    !pLib.hasCorrectNumOfFile(imagesNameContainer, mediaUploadConfig)
                                        .val
                                ) {
                                    let fullResult = pLib.hasCorrectNumOfFile(
                                        imagesNameContainer,
                                        mediaUploadConfig
                                    );
                                    pLib.fileConditionLogic(fullResult, mediaUploadConfig);
                                } else if (!pLib.isValidNumber(mobileInput)) {
                                    pLib.showAlert("Invalid mobile number", false);
                                    mobileInput.addClass("error");
                                } else {

                                    /*
		var arrdate=$("#js-datepicker-arrivaldate").val();
		var arrrestddate=$("#hdncurrentdate").val();

		var arrtime=$(".arrivaltime-js-timepicker").val();
		var arrrestdtime=$("#hdncurrenttime1").val();
			var arrobj=arrtime.split(' ');
			var arrhmobj=arrobj[0].split(':');
			var arrrestdhmobj=arrrestdtime.split(':');
			var arrh=arrhmobj[0];
			var arrm=arrhmobj[1];
			var arrrestdh=arrrestdhmobj[0];
			var arrrestdm=arrrestdhmobj[1];
			//arrrestdh= parseInt(arrrestdh)+12;
			if(arrobj[1]=="PM"){
				arrh= parseInt(arrh)==12?parseInt(0):parseInt(arrh);
				arrh=parseInt(arrh)+12;
			}
			if(arrobj[1]=="AM"){
				arrh= parseInt(arrh)==12?parseInt(0):parseInt(arrh);
			}else{
				arrh= parseInt(arrh);
			}

			var arrrestddateVal = (parseInt(arrrestddate.split('/')[0]));
			arrrestdh= 48+parseInt(arrrestdh);
			if(parseInt(arrrestdh)>48){
				arrrestdh=parseInt(arrrestdh)-48;
				arrrestddateVal = arrrestddateVal + 2;
			}


			if((arrdate.split('/')[1]==arrrestddate.split('/')[1]) && (arrdate.split('/')[2]==arrrestddate.split('/')[2]) && (arrdate.split('/')[0] <= arrrestddateVal )){

				if((arrdate.split('/')[0] < arrrestddateVal) || (parseInt(arrh)<parseInt(arrrestdh)) ||((parseInt(arrh)==parseInt(arrrestdh)) && (parseInt(arrm)<parseInt(arrrestdm)))){
					 pLib.showAlert("Please select arrival date and time is after 48 hours from now",false);
					 return false;
				}
			}
			*/

                                    var arrdate = $("#js-datepicker-arrivaldate").val();
                                    var arrtime = $(".arrivaltime-js-timepicker").val();

                                    var arrdatearray = arrdate.split("/");

                                    var arrdatenewdate = arrdatearray[1] + '/' + arrdatearray[0] + '/' + arrdatearray[2];

                                    var arrdatetime = new Date(arrdatenewdate + " " + arrtime);
                                    var mindatetime = new Date().addHours(48);
                                    if (arrdatetime < mindatetime) {
                                        //pLib.showAlert("Please select arrival date and time is after 48 hours from now",false);
                                        //return false;
                                    }

                                    // submit validation
                                    pLib.changeSubmitText("Please wait...", selfBtn, true);
                                    // convert mobile and tel number to international format
                                    pLib.toIntlNunmber(mobileInput);
                                    // check if its multiple application
                                    // localforage
                                    //   .length()
                                    //   .then(function(l) {
                                    // if (l == 0) {
                                    //   $('form[name="passenger-details-form"]').submit();
                                    //   console.log("Single Passenger");
                                    // } else {
                                    // validate and save latest form to browser storage
                                    pLib
                                        .savePassengerLocally(
                                            localforage,
                                            pLib.passengerFields,
                                            passengerCounter,
                                            imagesNameContainer
                                        )
                                        .then(function (value) {
                                            console.log(`Passenger ${passengerCounter} info saved`);
                                            console.table(value);
                                            passengerCounter += 1;
                                            passengerFormCounter.val(passengerCounter);

                                            // grab all data from browser storage
                                            pLib
                                                .giveMeLocalData(localforage)
                                                .then(function (d) {
                                                    console.log(d);
                                                    $.ajax({
                                                        url: "/ft",
                                                        data: {p: d},
                                                        type: "POST",
                                                        dataType: "json",
                                                        success: s => {
                                                            console.dir(s);
                                                            if (s.transaction) {
                                                                pLib.deleteLocalData(localforage);
                                                                // clear fields
                                                                // ! FORM RESETS
                                                                pLib.clearFormFields.partialClear();
                                                                // reset upload file
                                                                $('input[type="file"]').each(function () {
                                                                    let input = $(this);
                                                                    let trigger = input.siblings(".js-remove-file");
                                                                    let container = input.closest(".m-custom-upload");
                                                                    pLib.clearInputFile.fullClear(
                                                                        trigger,
                                                                        input,
                                                                        container
                                                                    );
                                                                });
                                                                // clear images container
                                                                for (const prop of Object.getOwnPropertyNames(
                                                                    imagesNameContainer
                                                                )) {
                                                                    delete imagesNameContainer[prop];
                                                                }
                                                                // enable upload file button
                                                                pLib.enableUploadBtn($(".a-upload-btn"));
                                                                //hide upload notification
                                                                pLib.showOrHideSuccessNotif(imagesNameContainer);
                                                                // ! END FORM RESETS
                                                                location.href = "confirm/" + s.transaction;
                                                            }

                                                            if (s.error == 'arrival_date_error') {
                                                                pLib.showAlert(
                                                                    s.message,
                                                                    false
                                                                );
                                                                pLib.changeSubmitText("Continue", selfBtn, false);

                                                                let IdLastPassengerSaved = passengerCounter - 1;
                                                                let itemToRemove =
                                                                    IdLastPassengerSaved < 10
                                                                        ? `passenger_0${IdLastPassengerSaved}`
                                                                        : `passenger_${IdLastPassengerSaved}`;
                                                                // remove last item added in browser storage if ajax request fails
                                                                localforage
                                                                    .removeItem(itemToRemove)
                                                                    .then(function () {
                                                                        passengerCounter -= 1;
                                                                        passengerFormCounter.val(passengerCounter);
                                                                    })
                                                                    .catch(function (err) {
                                                                        console.log(err);
                                                                    });
                                                            }
                                                            /*
						 if(s.error == 'arrival_over_departure_error'){
							pLib.showAlert(
							  "Please make sure the departure date and time is less than arrival date and time",
							  false
							);
							pLib.changeSubmitText("Continue", selfBtn, false);

							let IdLastPassengerSaved = passengerCounter - 1;
							let itemToRemove =
							  IdLastPassengerSaved < 10
								? `passenger_0${IdLastPassengerSaved}`
								: `passenger_${IdLastPassengerSaved}`;
							// remove last item added in browser storage if ajax request fails
							localforage
							  .removeItem(itemToRemove)
							  .then(function() {
								passengerCounter -= 1;
								passengerFormCounter.val(passengerCounter);
							  })
							  .catch(function(err) {
								console.log(err);
							  });

						}
						*/

                                                            if (s.error == 'duplicate') {
                                                                pLib.showAlert(
                                                                    "You have already applied for E-Visa on <br />Arrival on date : " + s.arrival_datetime + "<br />Application No. : " + s.application_number + "<br />You can check your application status on the Check Status page.<br />or<br />For more information, please contact us at : <a href='mailto:contact@evisathailand.com'>contact@evisathailand.com</a>",
                                                                    false
                                                                );
                                                                $('.m-alert__button-close').on('click', function () {
                                                                    window.open("/check?ap=" + s.application_number + "&pn=" + s.passport_number);
                                                                });
                                                                pLib.changeSubmitText("Continue", selfBtn, false);

                                                                let IdLastPassengerSaved = passengerCounter - 1;
                                                                let itemToRemove =
                                                                    IdLastPassengerSaved < 10
                                                                        ? `passenger_0${IdLastPassengerSaved}`
                                                                        : `passenger_${IdLastPassengerSaved}`;
                                                                // remove last item added in browser storage if ajax request fails
                                                                localforage
                                                                    .removeItem(itemToRemove)
                                                                    .then(function () {
                                                                        passengerCounter -= 1;
                                                                        passengerFormCounter.val(passengerCounter);
                                                                    })
                                                                    .catch(function (err) {
                                                                        console.log(err);
                                                                    });

                                                            }

                                                        },
                                                        error: (request, status, error) => {
                                                            console.log("TCL: error", error);
                                                            console.log("TCL: status", status);
                                                            console.log("TCL: request", request);
                                                            console.log(passengerCounter);
                                                            let IdLastPassengerSaved = passengerCounter - 1;
                                                            let itemToRemove =
                                                                IdLastPassengerSaved < 10
                                                                    ? `passenger_0${IdLastPassengerSaved}`
                                                                    : `passenger_${IdLastPassengerSaved}`;
                                                            // remove last item added in browser storage if ajax request fails
                                                            localforage
                                                                .removeItem(itemToRemove)
                                                                .then(function () {
                                                                    passengerCounter -= 1;
                                                                    passengerFormCounter.val(passengerCounter);
                                                                })
                                                                .catch(function (err) {
                                                                    console.log(err);
                                                                });
                                                            pLib.showAlert(
                                                                "Something went wrong. Please try again.",
                                                                false
                                                            );
                                                            pLib.changeSubmitText("Continue", selfBtn, false);
                                                            pLib.toNationalNunmber(mobileInput);
                                                        },
                                                        beforeSend: function (xhr) {
                                                            xhr.setRequestHeader(
                                                                "X-CSRF-Token",
                                                                $("input[name='_csrfToken']").val()
                                                            );
                                                        }
                                                    });
                                                })
                                                .catch(function (err) {
                                                    console.error(
                                                        `Something went wrong. Error details: ${err}`
                                                    );
                                                    pLib.showAlert(
                                                        "Something went wrong. Please try again.",
                                                        false
                                                    );
                                                    pLib.toNationalNunmber(mobileInput);
                                                });
                                        });
                                    // }
                                    // })
                                    // .catch(function(err) {
                                    //   console.error(`Something went wrong. Error details: ${err}`);
                                    // });
                                }
                            } else {
                                // send all data to the server
                                // grab all data from browser storage
                                pLib.changeSubmitText("Please wait...", selfBtn, true);
                                pLib
                                    .giveMeLocalData(localforage)
                                    .then(function (d) {
                                        console.log(d);
                                        $.ajax({
                                            url: "/ft",
                                            data: {p: d},
                                            type: "POST",
                                            dataType: "json",
                                            success: s => {
                                                console.dir(s);
                                                if (s.transaction) {
                                                    pLib.deleteLocalData(localforage);
                                                    // ! FORM RESETS
                                                    pLib.clearFormFields.partialClear();
                                                    // reset upload file
                                                    $('input[type="file"]').each(function () {
                                                        let input = $(this);
                                                        let trigger = input.siblings(".js-remove-file");
                                                        let container = input.closest(".m-custom-upload");
                                                        pLib.clearInputFile.fullClear(trigger, input, container);
                                                    });
                                                    // clear images container
                                                    for (const prop of Object.getOwnPropertyNames(
                                                        imagesNameContainer
                                                    )) {
                                                        delete imagesNameContainer[prop];
                                                    }
                                                    // enable upload file button
                                                    pLib.enableUploadBtn($(".a-upload-btn"));
                                                    //hide upload notification
                                                    pLib.showOrHideSuccessNotif(imagesNameContainer);
                                                    // ! END FORM RESETS
                                                    location.href = "confirm/" + s.transaction;
                                                }

                                                if (s.error == 'arrival_date_error') {
                                                    pLib.showAlert(
                                                        s.message,
                                                        false
                                                    );
                                                    pLib.changeSubmitText("Continue", selfBtn, false);

                                                    let IdLastPassengerSaved = passengerCounter - 1;
                                                    let itemToRemove =
                                                        IdLastPassengerSaved < 10
                                                            ? `passenger_0${IdLastPassengerSaved}`
                                                            : `passenger_${IdLastPassengerSaved}`;
                                                    // remove last item added in browser storage if ajax request fails
                                                    localforage
                                                        .removeItem(itemToRemove)
                                                        .then(function () {
                                                            passengerCounter -= 1;
                                                            passengerFormCounter.val(passengerCounter);
                                                        })
                                                        .catch(function (err) {
                                                            console.log(err);
                                                        });
                                                }
                                                /*
					if(s.error == 'arrival_over_departure_error'){
							pLib.showAlert(
							  "Please make sure the departure date and time is less than arrival date and time",
							  false
							);
							pLib.changeSubmitText("Continue", selfBtn, false);

							let IdLastPassengerSaved = passengerCounter - 1;
							let itemToRemove =
							  IdLastPassengerSaved < 10
								? `passenger_0${IdLastPassengerSaved}`
								: `passenger_${IdLastPassengerSaved}`;
							// remove last item added in browser storage if ajax request fails
							localforage
							  .removeItem(itemToRemove)
							  .then(function() {
								passengerCounter -= 1;
								passengerFormCounter.val(passengerCounter);
							  })
							  .catch(function(err) {
								console.log(err);
							  });
						}
					*/

                                                if (s.error == 'duplicate') {
                                                    pLib.showAlert(
                                                        "You have already applied for E-Visa on <br />Arrival on date : " + s.arrival_datetime + "<br />Application No. : " + s.application_number + "<br />You can check your application status on the Check Status page.<br />or<br />For more information, please contact us at : <a href='mailto:contact@evisathailand.com'>contact@evisathailand.com</a>",
                                                        false
                                                    );
                                                    $('.m-alert__button-close').on('click', function () {
                                                        window.open("/check?ap=" + s.application_number + "&pn=" + s.passport_number);
                                                    });
                                                    pLib.changeSubmitText("Continue", selfBtn, false);

                                                    let IdLastPassengerSaved = passengerCounter - 1;
                                                    let itemToRemove =
                                                        IdLastPassengerSaved < 10
                                                            ? `passenger_0${IdLastPassengerSaved}`
                                                            : `passenger_${IdLastPassengerSaved}`;
                                                    // remove last item added in browser storage if ajax request fails
                                                    localforage
                                                        .removeItem(itemToRemove)
                                                        .then(function () {
                                                            passengerCounter -= 1;
                                                            passengerFormCounter.val(passengerCounter);
                                                        })
                                                        .catch(function (err) {
                                                            console.log(err);
                                                        });

                                                }


                                            },
                                            error: (request, status, error) => {
                                                console.log("TCL: error", error);
                                                console.log("TCL: status", status);
                                                console.log("TCL: request", request);
                                                // console.dir(s);
                                                pLib.showAlert(
                                                    "Something went wrong. Please try again.",
                                                    false
                                                );
                                                pLib.changeSubmitText("Continue", selfBtn, false);
                                                pLib.toNationalNunmber(mobileInput);
                                            },
                                            beforeSend: function (xhr) {
                                                xhr.setRequestHeader(
                                                    "X-CSRF-Token",
                                                    $("input[name='_csrfToken']").val()
                                                );
                                            }
                                        });
                                    })
                                    .catch(function (err) {
                                        console.error(`Something went wrong. Error details: ${err}`);
                                        pLib.showAlert("Something went wrong. Please try again.", false);
                                        pLib.toNationalNunmber(mobileInput);
                                    });
                            }
                        }, 5000)
                    );
                    // ! ALERT and NOTIF
                    $(".m-alert__close, .m-alert button").on("click", function () {
                        $(".m-alert").fadeOut("fast");
                    });
                    $(".m-notification").on("click", function () {
                        $(this).removeClass("-show-notif");
                    });
                    // ios safari specific hack
                    if (browserInfo.mobile && browserInfo.name == "safari") {
                        $("meta[name=viewport]").remove();
                        $("head").append(
                            '<meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no, user-scalable=0">'
                        );
                    }
                    // ! PLACE OF STAY
                    // populate City/Province select fields
                    $.when(
                        $.getJSON("/js/lib/thailand.json", function (data) {
                            thailand = data;
                        })
                    ).then(function () {
                        let provinces = pLib.getUniqueData(thailand.map(item => item.province));
                        provinceSelect.append(`<option value=""  selected='selected'>Select</option>`);
                        for (let province of provinces) {
                            // if (provinceSelect.find("option").length == 0) {
                            // provinceSelect.append(`<option value="">Select</option>
                            // <option value="${province}" selected='selected'>${province}</option>
                            // `);
                            // } else {
                            provinceSelect.append(`
          <option value="${province}">${province}</option>
          `);
                            // }
                            //let option = new Option(province, province);
                            // option.selected = true;
                            // provinceSelect.append(option);
                        }
                        bindformdata();
                    });

                    // watch for changes in place of stay select
                    jsPlaceOfStay.on("change", function () {
                        pLib.resetDynamicFields();
                        // set district default value
                        let itsVal = $(this).val();
                        let currentSelectedProvince = provinceSelect.val();
                        if (currentSelectedProvince !== "") {
                            let defaultDistricts = [];
                            for (let index in thailand) {
                                if (thailand[index].province == currentSelectedProvince) {
                                    defaultDistricts.push(thailand[index].district);
                                }
                            }
                            pLib.dynamicOption(
                                districtSelect,
                                defaultDistricts,
                                districtSelect,
                                subDistrictSelect
                            );
                        }

                        pLib.posOpenSesame(itsVal, dic);
                    });
                    // watch for changes in city and populate district

                    provinceSelect.on("change", function () {
                        let selectedProvince = $(this).val();
                        let districts = [];
                        for (let index in thailand) {
                            if (thailand[index].province == selectedProvince) {
                                districts.push(thailand[index].district);
                            }
                        }
                        pLib.dynamicOption(
                            districtSelect,
                            districts,
                            districtSelect,
                            subDistrictSelect
                        );
                        // remove val of postcode, if ther's any
                        if (postCodeInput.val().trim() !== "") {
                            postCodeInput.val("");
                        }
                    });
                    // watch for changes in district and populate sub-district and postcode
                    districtSelect.on("change", function () {
                        let selectedDistrict = $(this).val();
                        let subDistricts = [];
                        let postCodes = [];
                        for (let index in thailand) {
                            if (thailand[index].district == selectedDistrict) {
                                subDistricts.push(thailand[index].subDistrict);
                                postCodes.push(thailand[index].postcode);
                            }
                        }
                        if (postCodeInput.hasClass("error")) {
                            postCodeInput.removeClass("error");
                        }

                        postCodeInput.val(pLib.getUniqueData(postCodes).toString());
                        pLib.dynamicOption(subDistrictSelect, subDistricts, subDistrictSelect);
                    });
                    // ! TRANSLATION
                    // console.log(dic["transl-1"]["rus"]);
                    $("#pd-nationality").on("change", function () {
                        let nationalityVal = $(this).val();
                        pLib.runTranslate(nationalityVal, dic);
                    });
                    // $(".js-to-translate").each(function(i) {
                    //   console.log(i);
                    // });
                    // ! Add * in all label with required fields
                    $('form[name="passenger-details-form"]')
                        .find("input, select, textarea")
                        .filter("[required]")
                        .each(function () {
                            $(this)
                                .siblings("label")
                                .addClass("is-required");
                        });
                    $(".m-form__images")
                        .find("label.js-to-translate")
                        .each(function () {
                            if (
                                !$(this)
                                    .text()
                                    .includes("optional")
                            ) {
                                $(this).addClass("is-required");
                            }
                        });
                    // ! TESTING
                    $("#js-testbutton").on("click", function () {
                        let validationResults = pLib.hasCorrectNumOfFile(
                            imagesNameContainer,
                            mediaUploadConfig
                        );
                        // validationResults.input.forEach(function(fileName){

                        // });
                        if (!validationResults.val) {
                            pLib.fileConditionLogic(validationResults, mediaUploadConfig);
                            // let message;
                            // if (pLib.dataSize(validationResults.raw) > 1) {
                            //   validationResults.raw.forEach(function(y) {
                            //     $(`[name = "${y}[]"]`)
                            //       .parent()
                            //       .removeClass("-is-success")
                            //       .addClass("-is-error");
                            //   });
                            //   let html = validationResults.raw.map(x => {
                            //     return `<li>Please upload ${
                            //       mediaUploadConfig[x].min
                            //     } or more files in ${validationResults.msgLabel[x]} </li>`;
                            //   });
                            //   message = `<ul>${html.join("")}</ul>`;
                            // } else {
                            //   $(`[name = "${validationResults.raw[0]}[]"]`)
                            //     .parent()
                            //     .removeClass("-is-success")
                            //     .addClass("-is-error");
                            //   let singleInput = validationResults.raw;
                            //   message = `<ul><li>Please upload ${
                            //     mediaUploadConfig[singleInput].min
                            //   } or more files in ${
                            //     validationResults.msgLabel[singleInput[0]]
                            //   }</li></ul>`;
                            // }
                            // pLib.showAlert(message, false);
                        } else {
                            pLib.showAlert('<span class="-red-text">Yay!<span>', false);
                        }

                        console.log(imagesNameContainer);
                        // let mobNume = $("#pd-mobilenum")
                        //   .intlTelInput("getNumber", intlTelInputUtils.numberFormat.NATIONAL)
                        //   .replace(/\s+/g, "");
                        // console.log(mobNume);
                    });

                    // temporary
                    $("#js-consoledata").on("click", function () {
                        pLib
                            .giveMeLocalData(localforage)
                            .then(function (d) {
                                console.log(d[0].imagesUploaded);
                                let imageData = JSON.stringify(d[0].imagesUploaded);
                                let imagesList = JSON.stringify(imagesNameContainer);
                                pLib.showAlert(imageData, false);
                            })
                            .catch(function (err) {
                                console.error(`Something went wrong. Error details: ${err}`);
                            });
                    });
                })(window)
            );

        }, {
            "../lib/common-utils": 2,
            "../lib/datepicker-setups": 3,
            "../lib/passenger-utils.js": 4,
            "adblock-detect": 6,
            "browser-detect": 7,
            "dayjs": 8,
            "formdata-polyfill": 10,
            "localforage": 11,
            "query-string": 13,
            "tooltip.js": 15,
            "weakmap-polyfill": 16
        }], 6: [function (require, module, exports) {
            (function (root, factory) {

                /* istanbul ignore next */
                if (typeof define === 'function' && define.amd) {
                    define([], factory);
                } else if (typeof module === 'object' && module.exports) {
                    module.exports = factory();
                } else {
                    root.adblockDetect = factory();
                }

            }(this, function () {

                function adblockDetect(callback, options) {

                    options = merge(adblockDetect.defaults, options || {});

                    var testNode = createNode(options.testNodeClasses, options.testNodeStyle);
                    var runsCounter = 0;
                    var adblockDetected = false;

                    var testInterval = setInterval(function () {

                        runsCounter++;
                        adblockDetected = isNodeBlocked(testNode);

                        if (adblockDetected || runsCounter === options.testRuns) {
                            clearInterval(testInterval);
                            testNode.parentNode && testNode.parentNode.removeChild(testNode);
                            callback(adblockDetected);
                        }

                    }, options.testInterval);

                }

                function createNode(testNodeClasses, testNodeStyle) {

                    var document = window.document;
                    var testNode = document.createElement('div');

                    testNode.innerHTML = '&nbsp;';
                    testNode.setAttribute('class', testNodeClasses);
                    testNode.setAttribute('style', testNodeStyle);

                    document.body.appendChild(testNode);

                    return testNode;

                }

                function isNodeBlocked(testNode) {

                    return testNode.offsetHeight === 0 ||
                        !document.body.contains(testNode) ||
                        testNode.style.display === 'none' ||
                        testNode.style.visibility === 'hidden'
                        ;

                }

                function merge(defaults, options) {

                    var obj = {};

                    for (var key in defaults) {
                        obj[key] = defaults[key];
                        options.hasOwnProperty(key) && (obj[key] = options[key]);
                    }

                    return obj;

                }

                adblockDetect.defaults = {
                    testNodeClasses: 'pub_300x250 pub_300x250m pub_728x90 text-ad textAd text_ad text_ads text-ads text-ad-links',
                    testNodeStyle: 'height: 10px !important; font-size: 20px; color: transparent; position: absolute; bottom: 0; left: -10000px;',
                    testInterval: 51,
                    testRuns: 4
                };

                return adblockDetect;

            }));

        }, {}], 7: [function (require, module, exports) {
            (function (process) {
                (function (global, factory) {
                    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
                        typeof define === 'function' && define.amd ? define(factory) :
                            (global.browserDetect = factory());
                }(this, (function () {
                    'use strict';

                    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

                    var __assign = Object.assign || function __assign(t) {
                        for (var s, i = 1, n = arguments.length; i < n; i++) {
                            s = arguments[i];
                            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                        }
                        return t;
                    };

                    var browsers = [
                        ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/],
                        ['opera', /Opera\/([0-9\.]+)(?:\s|$)/],
                        ['opera', /OPR\/([0-9\.]+)(:?\s|$)$/],
                        ['edge', /Edge\/([0-9\._]+)/],
                        ['ie', /Trident\/7\.0.*rv\:([0-9\.]+)\).*Gecko$/],
                        ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
                        ['ie', /MSIE\s(7\.0)/],
                        ['safari', /Version\/([0-9\._]+).*Safari/],
                        ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
                        ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/],
                        ['android', /Android\s([0-9\.]+)/],
                        ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/],
                        ['yandexbrowser', /YaBrowser\/([0-9\._]+)/],
                        ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/]
                    ];
                    var os = [
                        'Windows Phone',
                        'Android',
                        'CentOS',
                        {name: 'Chrome OS', pattern: 'CrOS'},
                        'Debian',
                        'Fedora',
                        'FreeBSD',
                        'Gentoo',
                        'Haiku',
                        'Kubuntu',
                        'Linux Mint',
                        'OpenBSD',
                        'Red Hat',
                        'SuSE',
                        'Ubuntu',
                        'Xubuntu',
                        'Cygwin',
                        'Symbian OS',
                        'hpwOS',
                        'webOS ',
                        'webOS',
                        'Tablet OS',
                        'Tizen',
                        'Linux',
                        'Mac OS X',
                        'Macintosh',
                        'Mac',
                        'Windows 98;',
                        'Windows '
                    ];
                    var osVersions = {
                        '10.0': '10',
                        '6.4': '10 Technical Preview',
                        '6.3': '8.1',
                        '6.2': '8',
                        '6.1': 'Server 2008 R2 / 7',
                        '6.0': 'Server 2008 / Vista',
                        '5.2': 'Server 2003 / XP 64-bit',
                        '5.1': 'XP',
                        '5.01': '2000 SP1',
                        '5.0': '2000',
                        '4.0': 'NT',
                        '4.90': 'ME'
                    };

                    var mobileRegExp = new RegExp(['(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|',
                        'compal|elaine|fennec|hiptop|iemobile|ip(hone|od|ad)|iris|kindle|lge |maemo|',
                        'midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)',
                        '\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|',
                        'wap|windows ce|xda|xiino'].join(''), 'i');
                    var mobilePrefixRegExp = new RegExp(['1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|',
                        'ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|',
                        'avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|',
                        'cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|',
                        'ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|',
                        'g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|',
                        'hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|',
                        'i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|',
                        'kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])',
                        '|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|',
                        'mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|',
                        'n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|',
                        'op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|',
                        'po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|',
                        'raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|',
                        'se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|k\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|',
                        'so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|',
                        'tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|',
                        'veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|',
                        'w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-'].join(''), 'i');

                    var Detector = /** @class */ (function () {
                        function Detector(userAgent, navigator, process) {
                            this.navigator = navigator;
                            this.process = process;
                            this.userAgent = userAgent
                                ? userAgent
                                : this.navigator ? (navigator.userAgent || navigator.vendor) : '';
                        }

                        Detector.prototype.detect = function () {
                            if (this.process && !this.userAgent) {
                                var version = this.process.version.slice(1).split('.').slice(0, 3);
                                var versionTail = Array.prototype.slice.call(version, 1).join('') || '0';
                                return {
                                    name: 'node',
                                    version: version.join('.'),
                                    versionNumber: parseFloat(version[0] + "." + versionTail),
                                    mobile: false,
                                    os: this.process.platform
                                };
                            }
                            if (!this.userAgent)
                                this.handleMissingError();
                            return __assign({}, this.checkBrowser(), this.checkMobile(), this.checkOs());
                        };
                        Detector.prototype.checkBrowser = function () {
                            var _this = this;
                            return browsers
                                .filter(function (definition) {
                                    return definition[1].test(_this.userAgent);
                                })
                                .map(function (definition) {
                                    var match = definition[1].exec(_this.userAgent);
                                    var version = match && match[1].split(/[._]/).slice(0, 3);
                                    var versionTails = Array.prototype.slice.call(version, 1).join('') || '0';
                                    if (version && version.length < 3)
                                        Array.prototype.push.apply(version, version.length === 1 ? [0, 0] : [0]);
                                    return {
                                        name: String(definition[0]),
                                        version: version.join('.'),
                                        versionNumber: Number(version[0] + "." + versionTails)
                                    };
                                })
                                .shift();
                        };
                        Detector.prototype.checkMobile = function () {
                            var agentPrefix = this.userAgent.substr(0, 4);
                            var mobile = mobileRegExp.test(this.userAgent) || mobilePrefixRegExp.test(agentPrefix);
                            return {mobile: mobile};
                        };
                        Detector.prototype.checkOs = function () {
                            var _this = this;
                            return os
                                .map(function (definition) {
                                    var name = definition.name || definition;
                                    var pattern = _this.getOsPattern(definition);
                                    return {
                                        name: name,
                                        pattern: pattern,
                                        value: RegExp("\\b" + pattern.replace(/([ -])(?!$)/g, '$1?') + "(?:x?[\\d._]+|[ \\w.]*)", 'i').exec(_this.userAgent)
                                    };
                                })
                                .filter(function (definition) {
                                    return definition.value;
                                })
                                .map(function (definition) {
                                    var os$$1 = definition.value[0] || '';
                                    var osSuffix;
                                    if (definition.pattern &&
                                        definition.name &&
                                        /^Win/i.test(os$$1) &&
                                        !/^Windows Phone /i.test(os$$1) &&
                                        (osSuffix = osVersions[os$$1.replace(/[^\d.]/g, '')]))
                                        os$$1 = "Windows " + osSuffix;
                                    if (definition.pattern && definition.name)
                                        os$$1 = os$$1.replace(RegExp(definition.pattern, 'i'), definition.name);
                                    os$$1 = os$$1
                                        .replace(/ ce$/i, ' CE')
                                        .replace(/\bhpw/i, 'web')
                                        .replace(/\bMacintosh\b/, 'Mac OS')
                                        .replace(/_PowerPC\b/i, ' OS')
                                        .replace(/\b(OS X) [^ \d]+/i, '$1')
                                        .replace(/\bMac (OS X)\b/, '$1')
                                        .replace(/\/(\d)/, ' $1')
                                        .replace(/_/g, '.')
                                        .replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, '')
                                        .replace(/\bx86\.64\b/gi, 'x86_64')
                                        .replace(/\b(Windows Phone) OS\b/, '$1')
                                        .replace(/\b(Chrome OS \w+) [\d.]+\b/, '$1')
                                        .split(' on ')[0]
                                        .trim();
                                    os$$1 = /^(?:webOS|i(?:OS|P))/.test(os$$1)
                                        ? os$$1
                                        : (os$$1.charAt(0).toUpperCase() + os$$1.slice(1));
                                    return {os: os$$1};
                                })
                                .shift();
                        };
                        Detector.prototype.getOsPattern = function (definition) {
                            var definitionInterface = definition;
                            return (typeof definition === 'string'
                                ? definition
                                : undefined) ||
                                definitionInterface.pattern ||
                                definitionInterface.name;
                        };
                        Detector.prototype.handleMissingError = function () {
                            throw new Error('Please give user-agent.\n> browser(navigator.userAgent or res.headers[\'user-agent\']).');
                        };
                        return Detector;
                    }());

                    function createCommonjsModule(fn, module) {
                        return module = {exports: {}}, fn(module, module.exports), module.exports;
                    }

                    var _global = createCommonjsModule(function (module) {
                        // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
                        var global = module.exports = typeof window != 'undefined' && window.Math == Math
                            ? window : typeof self != 'undefined' && self.Math == Math ? self
                                // eslint-disable-next-line no-new-func
                                : Function('return this')();
                        if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
                    });

                    var _core = createCommonjsModule(function (module) {
                        var core = module.exports = {version: '2.5.7'};
                        if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
                    });
                    var _core_1 = _core.version;

                    var _isObject = function (it) {
                        return typeof it === 'object' ? it !== null : typeof it === 'function';
                    };

                    var _anObject = function (it) {
                        if (!_isObject(it)) throw TypeError(it + ' is not an object!');
                        return it;
                    };

                    var _fails = function (exec) {
                        try {
                            return !!exec();
                        } catch (e) {
                            return true;
                        }
                    };

                    // Thank's IE8 for his funny defineProperty
                    var _descriptors = !_fails(function () {
                        return Object.defineProperty({}, 'a', {
                            get: function () {
                                return 7;
                            }
                        }).a != 7;
                    });

                    var document = _global.document;
                    // typeof document.createElement is 'object' in old IE
                    var is = _isObject(document) && _isObject(document.createElement);
                    var _domCreate = function (it) {
                        return is ? document.createElement(it) : {};
                    };

                    var _ie8DomDefine = !_descriptors && !_fails(function () {
                        return Object.defineProperty(_domCreate('div'), 'a', {
                            get: function () {
                                return 7;
                            }
                        }).a != 7;
                    });

                    // 7.1.1 ToPrimitive(input [, PreferredType])

                    // instead of the ES6 spec version, we didn't implement @@toPrimitive case
                    // and the second argument - flag - preferred type is a string
                    var _toPrimitive = function (it, S) {
                        if (!_isObject(it)) return it;
                        var fn, val;
                        if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
                        if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
                        if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
                        throw TypeError("Can't convert object to primitive value");
                    };

                    var dP = Object.defineProperty;

                    var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
                        _anObject(O);
                        P = _toPrimitive(P, true);
                        _anObject(Attributes);
                        if (_ie8DomDefine) try {
                            return dP(O, P, Attributes);
                        } catch (e) { /* empty */
                        }
                        if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
                        if ('value' in Attributes) O[P] = Attributes.value;
                        return O;
                    };

                    var _objectDp = {
                        f: f
                    };

                    var _propertyDesc = function (bitmap, value) {
                        return {
                            enumerable: !(bitmap & 1),
                            configurable: !(bitmap & 2),
                            writable: !(bitmap & 4),
                            value: value
                        };
                    };

                    var _hide = _descriptors ? function (object, key, value) {
                        return _objectDp.f(object, key, _propertyDesc(1, value));
                    } : function (object, key, value) {
                        object[key] = value;
                        return object;
                    };

                    var hasOwnProperty = {}.hasOwnProperty;
                    var _has = function (it, key) {
                        return hasOwnProperty.call(it, key);
                    };

                    var id = 0;
                    var px = Math.random();
                    var _uid = function (key) {
                        return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
                    };

                    var _redefine = createCommonjsModule(function (module) {
                        var SRC = _uid('src');
                        var TO_STRING = 'toString';
                        var $toString = Function[TO_STRING];
                        var TPL = ('' + $toString).split(TO_STRING);

                        _core.inspectSource = function (it) {
                            return $toString.call(it);
                        };

                        (module.exports = function (O, key, val, safe) {
                            var isFunction = typeof val == 'function';
                            if (isFunction) _has(val, 'name') || _hide(val, 'name', key);
                            if (O[key] === val) return;
                            if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
                            if (O === _global) {
                                O[key] = val;
                            } else if (!safe) {
                                delete O[key];
                                _hide(O, key, val);
                            } else if (O[key]) {
                                O[key] = val;
                            } else {
                                _hide(O, key, val);
                            }
                            // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
                        })(Function.prototype, TO_STRING, function toString() {
                            return typeof this == 'function' && this[SRC] || $toString.call(this);
                        });
                    });

                    var _aFunction = function (it) {
                        if (typeof it != 'function') throw TypeError(it + ' is not a function!');
                        return it;
                    };

                    // optional / simple context binding

                    var _ctx = function (fn, that, length) {
                        _aFunction(fn);
                        if (that === undefined) return fn;
                        switch (length) {
                            case 1:
                                return function (a) {
                                    return fn.call(that, a);
                                };
                            case 2:
                                return function (a, b) {
                                    return fn.call(that, a, b);
                                };
                            case 3:
                                return function (a, b, c) {
                                    return fn.call(that, a, b, c);
                                };
                        }
                        return function (/* ...args */) {
                            return fn.apply(that, arguments);
                        };
                    };

                    var PROTOTYPE = 'prototype';

                    var $export = function (type, name, source) {
                        var IS_FORCED = type & $export.F;
                        var IS_GLOBAL = type & $export.G;
                        var IS_STATIC = type & $export.S;
                        var IS_PROTO = type & $export.P;
                        var IS_BIND = type & $export.B;
                        var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
                        var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
                        var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
                        var key, own, out, exp;
                        if (IS_GLOBAL) source = name;
                        for (key in source) {
                            // contains in native
                            own = !IS_FORCED && target && target[key] !== undefined;
                            // export native or passed
                            out = (own ? target : source)[key];
                            // bind timers to global for call from export context
                            exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
                            // extend global
                            if (target) _redefine(target, key, out, type & $export.U);
                            // export
                            if (exports[key] != out) _hide(exports, key, exp);
                            if (IS_PROTO && expProto[key] != out) expProto[key] = out;
                        }
                    };
                    _global.core = _core;
                    // type bitmap
                    $export.F = 1;   // forced
                    $export.G = 2;   // global
                    $export.S = 4;   // static
                    $export.P = 8;   // proto
                    $export.B = 16;  // bind
                    $export.W = 32;  // wrap
                    $export.U = 64;  // safe
                    $export.R = 128; // real proto method for `library`
                    var _export = $export;

                    var toString = {}.toString;

                    var _cof = function (it) {
                        return toString.call(it).slice(8, -1);
                    };

                    // fallback for non-array-like ES3 and non-enumerable old V8 strings

                    // eslint-disable-next-line no-prototype-builtins
                    var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
                        return _cof(it) == 'String' ? it.split('') : Object(it);
                    };

                    // 7.2.1 RequireObjectCoercible(argument)
                    var _defined = function (it) {
                        if (it == undefined) throw TypeError("Can't call method on  " + it);
                        return it;
                    };

                    // 7.1.13 ToObject(argument)

                    var _toObject = function (it) {
                        return Object(_defined(it));
                    };

                    // 7.1.4 ToInteger
                    var ceil = Math.ceil;
                    var floor = Math.floor;
                    var _toInteger = function (it) {
                        return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
                    };

                    // 7.1.15 ToLength

                    var min = Math.min;
                    var _toLength = function (it) {
                        return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
                    };

                    // 7.2.2 IsArray(argument)

                    var _isArray = Array.isArray || function isArray(arg) {
                        return _cof(arg) == 'Array';
                    };

                    var _shared = createCommonjsModule(function (module) {
                        var SHARED = '__core-js_shared__';
                        var store = _global[SHARED] || (_global[SHARED] = {});

                        (module.exports = function (key, value) {
                            return store[key] || (store[key] = value !== undefined ? value : {});
                        })('versions', []).push({
                            version: _core.version,
                            mode: 'global',
                            copyright: '© 2018 Denis Pushkarev (zloirock.ru)'
                        });
                    });

                    var _wks = createCommonjsModule(function (module) {
                        var store = _shared('wks');

                        var Symbol = _global.Symbol;
                        var USE_SYMBOL = typeof Symbol == 'function';

                        var $exports = module.exports = function (name) {
                            return store[name] || (store[name] =
                                USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));
                        };

                        $exports.store = store;
                    });

                    var SPECIES = _wks('species');

                    var _arraySpeciesConstructor = function (original) {
                        var C;
                        if (_isArray(original)) {
                            C = original.constructor;
                            // cross-realm fallback
                            if (typeof C == 'function' && (C === Array || _isArray(C.prototype))) C = undefined;
                            if (_isObject(C)) {
                                C = C[SPECIES];
                                if (C === null) C = undefined;
                            }
                        }
                        return C === undefined ? Array : C;
                    };

                    // 9.4.2.3 ArraySpeciesCreate(originalArray, length)


                    var _arraySpeciesCreate = function (original, length) {
                        return new (_arraySpeciesConstructor(original))(length);
                    };

                    // 0 -> Array#forEach
                    // 1 -> Array#map
                    // 2 -> Array#filter
                    // 3 -> Array#some
                    // 4 -> Array#every
                    // 5 -> Array#find
                    // 6 -> Array#findIndex


                    var _arrayMethods = function (TYPE, $create) {
                        var IS_MAP = TYPE == 1;
                        var IS_FILTER = TYPE == 2;
                        var IS_SOME = TYPE == 3;
                        var IS_EVERY = TYPE == 4;
                        var IS_FIND_INDEX = TYPE == 6;
                        var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
                        var create = $create || _arraySpeciesCreate;
                        return function ($this, callbackfn, that) {
                            var O = _toObject($this);
                            var self = _iobject(O);
                            var f = _ctx(callbackfn, that, 3);
                            var length = _toLength(self.length);
                            var index = 0;
                            var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
                            var val, res;
                            for (; length > index; index++) if (NO_HOLES || index in self) {
                                val = self[index];
                                res = f(val, index, O);
                                if (TYPE) {
                                    if (IS_MAP) result[index] = res;   // map
                                    else if (res) switch (TYPE) {
                                        case 3:
                                            return true;             // some
                                        case 5:
                                            return val;              // find
                                        case 6:
                                            return index;            // findIndex
                                        case 2:
                                            result.push(val);        // filter
                                    } else if (IS_EVERY) return false; // every
                                }
                            }
                            return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
                        };
                    };

                    var _strictMethod = function (method, arg) {
                        return !!method && _fails(function () {
                            // eslint-disable-next-line no-useless-call
                            arg ? method.call(null, function () { /* empty */
                            }, 1) : method.call(null);
                        });
                    };

                    var $filter = _arrayMethods(2);

                    _export(_export.P + _export.F * !_strictMethod([].filter, true), 'Array', {
                        // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
                        filter: function filter(callbackfn /* , thisArg */) {
                            return $filter(this, callbackfn, arguments[1]);
                        }
                    });

                    var filter = _core.Array.filter;

                    var $map = _arrayMethods(1);

                    _export(_export.P + _export.F * !_strictMethod([].map, true), 'Array', {
                        // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
                        map: function map(callbackfn /* , thisArg */) {
                            return $map(this, callbackfn, arguments[1]);
                        }
                    });

                    var map = _core.Array.map;

                    var _stringWs = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
                        '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

                    var space = '[' + _stringWs + ']';
                    var non = '\u200b\u0085';
                    var ltrim = RegExp('^' + space + space + '*');
                    var rtrim = RegExp(space + space + '*$');

                    var exporter = function (KEY, exec, ALIAS) {
                        var exp = {};
                        var FORCE = _fails(function () {
                            return !!_stringWs[KEY]() || non[KEY]() != non;
                        });
                        var fn = exp[KEY] = FORCE ? exec(trim) : _stringWs[KEY];
                        if (ALIAS) exp[ALIAS] = fn;
                        _export(_export.P + _export.F * FORCE, 'String', exp);
                    };

                    // 1 -> String#trimLeft
                    // 2 -> String#trimRight
                    // 3 -> String#trim
                    var trim = exporter.trim = function (string, TYPE) {
                        string = String(_defined(string));
                        if (TYPE & 1) string = string.replace(ltrim, '');
                        if (TYPE & 2) string = string.replace(rtrim, '');
                        return string;
                    };

                    var _stringTrim = exporter;

                    // 21.1.3.25 String.prototype.trim()
                    _stringTrim('trim', function ($trim) {
                        return function trim() {
                            return $trim(this, 3);
                        };
                    });

                    var trim$1 = _core.String.trim;

                    var injectableNavigator = typeof window !== 'undefined'
                        ? window.navigator
                        : undefined;
                    var injectableProcess = typeof process !== 'undefined'
                        ? process
                        : undefined;

                    function browserDetect(userAgent) {
                        var detector = new Detector(userAgent, injectableNavigator, injectableProcess);
                        return detector.detect();
                    }

                    return browserDetect;

                })));


            }).call(this, require('_process'))
        }, {"_process": 1}], 8: [function (require, module, exports) {
            !function (t, e) {
                "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : t.dayjs = e()
            }(this, function () {
                "use strict";
                var t = "millisecond", e = "second", n = "minute", r = "hour", s = "day", i = "week", a = "month",
                    u = "year", c = /^(\d{4})-?(\d{1,2})-?(\d{0,2})(.*?(\d{1,2}):(\d{1,2}):(\d{1,2}))?.?(\d{1,3})?$/,
                    o = /\[.*?\]|Y{2,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, h = {
                        name: "en",
                        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_")
                    }, d = function (t, e, n) {
                        var r = String(t);
                        return !r || r.length >= e ? t : "" + Array(e + 1 - r.length).join(n) + t
                    }, $ = {
                        padStart: d, padZoneStr: function (t) {
                            var e = Math.abs(t), n = Math.floor(e / 60), r = e % 60;
                            return (t <= 0 ? "+" : "-") + d(n, 2, "0") + ":" + d(r, 2, "0")
                        }, monthDiff: function (t, e) {
                            var n = 12 * (e.year() - t.year()) + (e.month() - t.month()), r = t.clone().add(n, "months"),
                                s = e - r < 0, i = t.clone().add(n + (s ? -1 : 1), "months");
                            return Number(-(n + (e - r) / (s ? r - i : i - r)))
                        }, absFloor: function (t) {
                            return t < 0 ? Math.ceil(t) || 0 : Math.floor(t)
                        }, prettyUnit: function (c) {
                            return {
                                M: a,
                                y: u,
                                w: i,
                                d: s,
                                h: r,
                                m: n,
                                s: e,
                                ms: t
                            }[c] || String(c || "").toLowerCase().replace(/s$/, "")
                        }, isUndefined: function (t) {
                            return void 0 === t
                        }
                    }, f = "en", l = {};
                l[f] = h;
                var m = function (t) {
                    return t instanceof D
                }, y = function (t, e, n) {
                    var r;
                    if (!t) return null;
                    if ("string" == typeof t) l[t] && (r = t), e && (l[t] = e, r = t); else {
                        var s = t.name;
                        l[s] = t, r = s
                    }
                    return n || (f = r), r
                }, M = function (t, e) {
                    if (m(t)) return t.clone();
                    var n = e || {};
                    return n.date = t, new D(n)
                }, S = function (t, e) {
                    return M(t, {locale: e.$L})
                }, p = $;
                p.parseLocale = y, p.isDayjs = m, p.wrapper = S;
                var D = function () {
                    function h(t) {
                        this.parse(t)
                    }

                    var d = h.prototype;
                    return d.parse = function (t) {
                        var e, n;
                        this.$d = null === (e = t.date) ? new Date(NaN) : p.isUndefined(e) ? new Date : e instanceof Date ? e : "string" == typeof e && /.*[^Z]$/i.test(e) && (n = e.match(c)) ? new Date(n[1], n[2] - 1, n[3] || 1, n[5] || 0, n[6] || 0, n[7] || 0, n[8] || 0) : new Date(e), this.init(t)
                    }, d.init = function (t) {
                        this.$y = this.$d.getFullYear(), this.$M = this.$d.getMonth(), this.$D = this.$d.getDate(), this.$W = this.$d.getDay(), this.$H = this.$d.getHours(), this.$m = this.$d.getMinutes(), this.$s = this.$d.getSeconds(), this.$ms = this.$d.getMilliseconds(), this.$L = this.$L || y(t.locale, null, !0) || f
                    }, d.$utils = function () {
                        return p
                    }, d.isValid = function () {
                        return !("Invalid Date" === this.$d.toString())
                    }, d.$compare = function (t) {
                        return this.valueOf() - M(t).valueOf()
                    }, d.isSame = function (t) {
                        return 0 === this.$compare(t)
                    }, d.isBefore = function (t) {
                        return this.$compare(t) < 0
                    }, d.isAfter = function (t) {
                        return this.$compare(t) > 0
                    }, d.year = function () {
                        return this.$y
                    }, d.month = function () {
                        return this.$M
                    }, d.day = function () {
                        return this.$W
                    }, d.date = function () {
                        return this.$D
                    }, d.hour = function () {
                        return this.$H
                    }, d.minute = function () {
                        return this.$m
                    }, d.second = function () {
                        return this.$s
                    }, d.millisecond = function () {
                        return this.$ms
                    }, d.unix = function () {
                        return Math.floor(this.valueOf() / 1e3)
                    }, d.valueOf = function () {
                        return this.$d.getTime()
                    }, d.startOf = function (t, c) {
                        var o = this, h = !!p.isUndefined(c) || c, d = function (t, e) {
                            var n = S(new Date(o.$y, e, t), o);
                            return h ? n : n.endOf(s)
                        }, $ = function (t, e) {
                            return S(o.toDate()[t].apply(o.toDate(), h ? [0, 0, 0, 0].slice(e) : [23, 59, 59, 999].slice(e)), o)
                        };
                        switch (p.prettyUnit(t)) {
                            case u:
                                return h ? d(1, 0) : d(31, 11);
                            case a:
                                return h ? d(1, this.$M) : d(0, this.$M + 1);
                            case i:
                                return d(h ? this.$D - this.$W : this.$D + (6 - this.$W), this.$M);
                            case s:
                            case"date":
                                return $("setHours", 0);
                            case r:
                                return $("setMinutes", 1);
                            case n:
                                return $("setSeconds", 2);
                            case e:
                                return $("setMilliseconds", 3);
                            default:
                                return this.clone()
                        }
                    }, d.endOf = function (t) {
                        return this.startOf(t, !1)
                    }, d.$set = function (i, c) {
                        switch (p.prettyUnit(i)) {
                            case s:
                                this.$d.setDate(this.$D + (c - this.$W));
                                break;
                            case"date":
                                this.$d.setDate(c);
                                break;
                            case a:
                                this.$d.setMonth(c);
                                break;
                            case u:
                                this.$d.setFullYear(c);
                                break;
                            case r:
                                this.$d.setHours(c);
                                break;
                            case n:
                                this.$d.setMinutes(c);
                                break;
                            case e:
                                this.$d.setSeconds(c);
                                break;
                            case t:
                                this.$d.setMilliseconds(c)
                        }
                        return this.init(), this
                    }, d.set = function (t, e) {
                        return this.clone().$set(t, e)
                    }, d.add = function (t, c) {
                        var o = this;
                        t = Number(t);
                        var h, d = p.prettyUnit(c), $ = function (e, n) {
                            var r = o.set("date", 1).set(e, n + t);
                            return r.set("date", Math.min(o.$D, r.daysInMonth()))
                        };
                        if (d === a) return $(a, this.$M);
                        if (d === u) return $(u, this.$y);
                        switch (d) {
                            case n:
                                h = 6e4;
                                break;
                            case r:
                                h = 36e5;
                                break;
                            case s:
                                h = 864e5;
                                break;
                            case i:
                                h = 6048e5;
                                break;
                            case e:
                                h = 1e3;
                                break;
                            default:
                                h = 1
                        }
                        var f = this.valueOf() + t * h;
                        return S(f, this)
                    }, d.subtract = function (t, e) {
                        return this.add(-1 * t, e)
                    }, d.format = function (t) {
                        var e = this, n = t || "YYYY-MM-DDTHH:mm:ssZ", r = p.padZoneStr(this.$d.getTimezoneOffset()),
                            s = this.$locale(), i = s.weekdays, a = s.months, u = function (t, e, n, r) {
                                return t && t[e] || n[e].substr(0, r)
                            };
                        return n.replace(o, function (t) {
                            if (t.indexOf("[") > -1) return t.replace(/\[|\]/g, "");
                            switch (t) {
                                case"YY":
                                    return String(e.$y).slice(-2);
                                case"YYYY":
                                    return String(e.$y);
                                case"M":
                                    return String(e.$M + 1);
                                case"MM":
                                    return p.padStart(e.$M + 1, 2, "0");
                                case"MMM":
                                    return u(s.monthsShort, e.$M, a, 3);
                                case"MMMM":
                                    return a[e.$M];
                                case"D":
                                    return String(e.$D);
                                case"DD":
                                    return p.padStart(e.$D, 2, "0");
                                case"d":
                                    return String(e.$W);
                                case"dd":
                                    return u(s.weekdaysMin, e.$W, i, 2);
                                case"ddd":
                                    return u(s.weekdaysShort, e.$W, i, 3);
                                case"dddd":
                                    return i[e.$W];
                                case"H":
                                    return String(e.$H);
                                case"HH":
                                    return p.padStart(e.$H, 2, "0");
                                case"h":
                                case"hh":
                                    return 0 === e.$H ? 12 : p.padStart(e.$H < 13 ? e.$H : e.$H - 12, "hh" === t ? 2 : 1, "0");
                                case"a":
                                    return e.$H < 12 ? "am" : "pm";
                                case"A":
                                    return e.$H < 12 ? "AM" : "PM";
                                case"m":
                                    return String(e.$m);
                                case"mm":
                                    return p.padStart(e.$m, 2, "0");
                                case"s":
                                    return String(e.$s);
                                case"ss":
                                    return p.padStart(e.$s, 2, "0");
                                case"SSS":
                                    return p.padStart(e.$ms, 3, "0");
                                case"Z":
                                    return r;
                                default:
                                    return r.replace(":", "")
                            }
                        })
                    }, d.diff = function (t, c, o) {
                        var h = p.prettyUnit(c), d = M(t), $ = this - d, f = p.monthDiff(this, d);
                        switch (h) {
                            case u:
                                f /= 12;
                                break;
                            case a:
                                break;
                            case"quarter":
                                f /= 3;
                                break;
                            case i:
                                f = $ / 6048e5;
                                break;
                            case s:
                                f = $ / 864e5;
                                break;
                            case r:
                                f = $ / 36e5;
                                break;
                            case n:
                                f = $ / 6e4;
                                break;
                            case e:
                                f = $ / 1e3;
                                break;
                            default:
                                f = $
                        }
                        return o ? f : p.absFloor(f)
                    }, d.daysInMonth = function () {
                        return this.endOf(a).$D
                    }, d.$locale = function () {
                        return l[this.$L]
                    }, d.locale = function (t, e) {
                        var n = this.clone();
                        return n.$L = y(t, e, !0), n
                    }, d.clone = function () {
                        return S(this.toDate(), this)
                    }, d.toDate = function () {
                        return new Date(this.$d)
                    }, d.toArray = function () {
                        return [this.$y, this.$M, this.$D, this.$H, this.$m, this.$s, this.$ms]
                    }, d.toJSON = function () {
                        return this.toISOString()
                    }, d.toISOString = function () {
                        return this.toDate().toISOString()
                    }, d.toObject = function () {
                        return {
                            years: this.$y,
                            months: this.$M,
                            date: this.$D,
                            hours: this.$H,
                            minutes: this.$m,
                            seconds: this.$s,
                            milliseconds: this.$ms
                        }
                    }, d.toString = function () {
                        return this.$d.toUTCString()
                    }, h
                }();
                return M.extend = function (t, e) {
                    return t(e, D, M), M
                }, M.locale = y, M.isDayjs = m, M.en = l[f], M
            });

        }, {}], 9: [function (require, module, exports) {
            'use strict';
            var token = '%[a-f0-9]{2}';
            var singleMatcher = new RegExp(token, 'gi');
            var multiMatcher = new RegExp('(' + token + ')+', 'gi');

            function decodeComponents(components, split) {
                try {
                    // Try to decode the entire string first
                    return decodeURIComponent(components.join(''));
                } catch (err) {
                    // Do nothing
                }

                if (components.length === 1) {
                    return components;
                }

                split = split || 1;

                // Split the array in 2 parts
                var left = components.slice(0, split);
                var right = components.slice(split);

                return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
            }

            function decode(input) {
                try {
                    return decodeURIComponent(input);
                } catch (err) {
                    var tokens = input.match(singleMatcher);

                    for (var i = 1; i < tokens.length; i++) {
                        input = decodeComponents(tokens, i).join('');

                        tokens = input.match(singleMatcher);
                    }

                    return input;
                }
            }

            function customDecodeURIComponent(input) {
                // Keep track of all the replacements and prefill the map with the `BOM`
                var replaceMap = {
                    '%FE%FF': '\uFFFD\uFFFD',
                    '%FF%FE': '\uFFFD\uFFFD'
                };

                var match = multiMatcher.exec(input);
                while (match) {
                    try {
                        // Decode as big chunks as possible
                        replaceMap[match[0]] = decodeURIComponent(match[0]);
                    } catch (err) {
                        var result = decode(match[0]);

                        if (result !== match[0]) {
                            replaceMap[match[0]] = result;
                        }
                    }

                    match = multiMatcher.exec(input);
                }

                // Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
                replaceMap['%C2'] = '\uFFFD';

                var entries = Object.keys(replaceMap);

                for (var i = 0; i < entries.length; i++) {
                    // Replace all decoded components
                    var key = entries[i];
                    input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
                }

                return input;
            }

            module.exports = function (encodedURI) {
                if (typeof encodedURI !== 'string') {
                    throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
                }

                try {
                    encodedURI = encodedURI.replace(/\+/g, ' ');

                    // Try the built in decoder first
                    return decodeURIComponent(encodedURI);
                } catch (err) {
                    // Fallback to a more advanced decoder
                    return customDecodeURIComponent(encodedURI);
                }
            };

        }, {}], 10: [function (require, module, exports) {
            (function (global) {
                ;(function () {
                    var k,
                        l = "function" == typeof Object.defineProperties ? Object.defineProperty : function (a, b, d) {
                            a != Array.prototype && a != Object.prototype && (a[b] = d.value)
                        },
                        m = "undefined" != typeof window && window === this ? this : "undefined" != typeof global && null != global ? global : this;

                    function n() {
                        n = function () {
                        };
                        m.Symbol || (m.Symbol = p)
                    }

                    var p = function () {
                        var a = 0;
                        return function (b) {
                            return "jscomp_symbol_" + (b || "") + a++
                        }
                    }();

                    function r() {
                        n();
                        var a = m.Symbol.iterator;
                        a || (a = m.Symbol.iterator = m.Symbol("iterator"));
                        "function" != typeof Array.prototype[a] && l(Array.prototype, a, {
                            configurable: !0,
                            writable: !0,
                            value: function () {
                                return u(this)
                            }
                        });
                        r = function () {
                        }
                    }

                    function u(a) {
                        var b = 0;
                        return v(function () {
                            return b < a.length ? {done: !1, value: a[b++]} : {done: !0}
                        })
                    }

                    function v(a) {
                        r();
                        a = {next: a};
                        a[m.Symbol.iterator] = function () {
                            return this
                        };
                        return a
                    }

                    function w(a) {
                        r();
                        n();
                        r();
                        var b = a[Symbol.iterator];
                        return b ? b.call(a) : u(a)
                    }

                    var x;
                    if ("function" == typeof Object.setPrototypeOf) x = Object.setPrototypeOf; else {
                        var z;
                        a:{
                            var A = {o: !0}, B = {};
                            try {
                                B.__proto__ = A;
                                z = B.o;
                                break a
                            } catch (a) {
                            }
                            z = !1
                        }
                        x = z ? function (a, b) {
                            a.__proto__ = b;
                            if (a.__proto__ !== b) throw new TypeError(a + " is not extensible");
                            return a
                        } : null
                    }
                    var C = x;

                    function D() {
                        this.g = !1;
                        this.c = null;
                        this.m = void 0;
                        this.b = 1;
                        this.l = this.s = 0;
                        this.f = null
                    }

                    function E(a) {
                        if (a.g) throw new TypeError("Generator is already running");
                        a.g = !0
                    }

                    D.prototype.h = function (a) {
                        this.m = a
                    };
                    D.prototype.i = function (a) {
                        this.f = {u: a, v: !0};
                        this.b = this.s || this.l
                    };
                    D.prototype["return"] = function (a) {
                        this.f = {"return": a};
                        this.b = this.l
                    };

                    function F(a, b, d) {
                        a.b = d;
                        return {value: b}
                    }

                    function G(a) {
                        this.w = a;
                        this.j = [];
                        for (var b in a) this.j.push(b);
                        this.j.reverse()
                    }

                    function H(a) {
                        this.a = new D;
                        this.A = a
                    }

                    H.prototype.h = function (a) {
                        E(this.a);
                        if (this.a.c) return I(this, this.a.c.next, a, this.a.h);
                        this.a.h(a);
                        return J(this)
                    };

                    function K(a, b) {
                        E(a.a);
                        var d = a.a.c;
                        if (d) return I(a, "return" in d ? d["return"] : function (a) {
                            return {value: a, done: !0}
                        }, b, a.a["return"]);
                        a.a["return"](b);
                        return J(a)
                    }

                    H.prototype.i = function (a) {
                        E(this.a);
                        if (this.a.c) return I(this, this.a.c["throw"], a, this.a.h);
                        this.a.i(a);
                        return J(this)
                    };

                    function I(a, b, d, c) {
                        try {
                            var e = b.call(a.a.c, d);
                            if (!(e instanceof Object)) throw new TypeError("Iterator result " + e + " is not an object");
                            if (!e.done) return a.a.g = !1, e;
                            var f = e.value
                        } catch (g) {
                            return a.a.c = null, a.a.i(g), J(a)
                        }
                        a.a.c = null;
                        c.call(a.a, f);
                        return J(a)
                    }

                    function J(a) {
                        for (; a.a.b;) try {
                            var b = a.A(a.a);
                            if (b) return a.a.g = !1, {value: b.value, done: !1}
                        } catch (d) {
                            a.a.m = void 0, a.a.i(d)
                        }
                        a.a.g = !1;
                        if (a.a.f) {
                            b = a.a.f;
                            a.a.f = null;
                            if (b.v) throw b.u;
                            return {value: b["return"], done: !0}
                        }
                        return {value: void 0, done: !0}
                    }

                    function L(a) {
                        this.next = function (b) {
                            return a.h(b)
                        };
                        this["throw"] = function (b) {
                            return a.i(b)
                        };
                        this["return"] = function (b) {
                            return K(a, b)
                        };
                        r();
                        this[Symbol.iterator] = function () {
                            return this
                        }
                    }

                    function M(a, b) {
                        var d = new L(new H(b));
                        C && C(d, a.prototype);
                        return d
                    }

                    if ("undefined" === typeof FormData || !FormData.prototype.keys) {
                        var N = function (a, b, d) {
                                if (2 > arguments.length) throw new TypeError("2 arguments required, but only " + arguments.length + " present.");
                                return b instanceof Blob ? [a + "", b, void 0 !== d ? d + "" : "string" === typeof b.name ? b.name : "blob"] : [a + "", b + ""]
                            }, O = function (a) {
                                if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
                                return [a + ""]
                            }, P = function (a) {
                                var b = w(a);
                                a = b.next().value;
                                b = b.next().value;
                                a instanceof Blob && (a = new File([a], b, {
                                    type: a.type,
                                    lastModified: a.lastModified
                                }));
                                return a
                            }, Q = "object" === typeof window ? window : "object" === typeof self ? self : this,
                            R = Q.FormData, S = Q.XMLHttpRequest && Q.XMLHttpRequest.prototype.send,
                            T = Q.Request && Q.fetch;
                        n();
                        var U = Q.Symbol && Symbol.toStringTag, V = new WeakMap, W = Array.from || function (a) {
                            return [].slice.call(a)
                        };
                        U && (Blob.prototype[U] || (Blob.prototype[U] = "Blob"), "File" in Q && !File.prototype[U] && (File.prototype[U] = "File"));
                        try {
                            new File([], "")
                        } catch (a) {
                            Q.File = function (b, d, c) {
                                b = new Blob(b, c);
                                c = c && void 0 !== c.lastModified ?
                                    new Date(c.lastModified) : new Date;
                                Object.defineProperties(b, {
                                    name: {value: d},
                                    lastModifiedDate: {value: c},
                                    lastModified: {value: +c},
                                    toString: {
                                        value: function () {
                                            return "[object File]"
                                        }
                                    }
                                });
                                U && Object.defineProperty(b, U, {value: "File"});
                                return b
                            }
                        }
                        var X = function (a) {
                            V.set(this, Object.create(null));
                            if (!a) return this;
                            a = w(W(a.elements));
                            for (var b = a.next(); !b.done; b = a.next()) if (b = b.value, b.name && !b.disabled) if ("file" === b.type) for (var d = w(b.files), c = d.next(); !c.done; c = d.next()) this.append(b.name, c.value); else if ("select-multiple" ===
                                b.type || "select-one" === b.type) for (d = w(W(b.options)), c = d.next(); !c.done; c = d.next()) c = c.value, !c.disabled && c.selected && this.append(b.name, c.value); else "checkbox" === b.type || "radio" === b.type ? b.checked && this.append(b.name, b.value) : this.append(b.name, b.value)
                        };
                        k = X.prototype;
                        k.append = function (a, b, d) {
                            var c = V.get(this);
                            c[a] || (c[a] = []);
                            c[a].push([b, d])
                        };
                        k["delete"] = function (a) {
                            delete V.get(this)[a]
                        };
                        k.entries = function b() {
                            var d = this, c, e, f, g, h, q;
                            return M(b, function (b) {
                                switch (b.b) {
                                    case 1:
                                        c = V.get(d), f = new G(c);
                                    case 2:
                                        var t;
                                        a:{
                                            for (t = f; 0 < t.j.length;) {
                                                var y = t.j.pop();
                                                if (y in t.w) {
                                                    t = y;
                                                    break a
                                                }
                                            }
                                            t = null
                                        }
                                        if (null == (e = t)) {
                                            b.b = 0;
                                            break
                                        }
                                        g = w(c[e]);
                                        h = g.next();
                                    case 5:
                                        if (h.done) {
                                            b.b = 2;
                                            break
                                        }
                                        q = h.value;
                                        return F(b, [e, P(q)], 6);
                                    case 6:
                                        h = g.next(), b.b = 5
                                }
                            })
                        };
                        k.forEach = function (b, d) {
                            for (var c = w(this), e = c.next(); !e.done; e = c.next()) {
                                var f = w(e.value);
                                e = f.next().value;
                                f = f.next().value;
                                b.call(d, f, e, this)
                            }
                        };
                        k.get = function (b) {
                            var d = V.get(this);
                            return d[b] ? P(d[b][0]) : null
                        };
                        k.getAll = function (b) {
                            return (V.get(this)[b] || []).map(P)
                        };
                        k.has = function (b) {
                            return b in
                                V.get(this)
                        };
                        k.keys = function d() {
                            var c = this, e, f, g, h, q;
                            return M(d, function (d) {
                                1 == d.b && (e = w(c), f = e.next());
                                if (3 != d.b) {
                                    if (f.done) {
                                        d.b = 0;
                                        return
                                    }
                                    g = f.value;
                                    h = w(g);
                                    q = h.next().value;
                                    return F(d, q, 3)
                                }
                                f = e.next();
                                d.b = 2
                            })
                        };
                        k.set = function (d, c, e) {
                            V.get(this)[d] = [[c, e]]
                        };
                        k.values = function c() {
                            var e = this, f, g, h, q, y;
                            return M(c, function (c) {
                                1 == c.b && (f = w(e), g = f.next());
                                if (3 != c.b) {
                                    if (g.done) {
                                        c.b = 0;
                                        return
                                    }
                                    h = g.value;
                                    q = w(h);
                                    q.next();
                                    y = q.next().value;
                                    return F(c, y, 3)
                                }
                                g = f.next();
                                c.b = 2
                            })
                        };
                        X.prototype._asNative = function () {
                            for (var c =
                                new R, e = w(this), f = e.next(); !f.done; f = e.next()) {
                                var g = w(f.value);
                                f = g.next().value;
                                g = g.next().value;
                                c.append(f, g)
                            }
                            return c
                        };
                        X.prototype._blob = function () {
                            for (var c = "----formdata-polyfill-" + Math.random(), e = [], f = w(this), g = f.next(); !g.done; g = f.next()) {
                                var h = w(g.value);
                                g = h.next().value;
                                h = h.next().value;
                                e.push("--" + c + "\r\n");
                                h instanceof Blob ? e.push('Content-Disposition: form-data; name="' + g + '"; filename="' + h.name + '"\r\n', "Content-Type: " + (h.type || "application/octet-stream") + "\r\n\r\n", h, "\r\n") : e.push('Content-Disposition: form-data; name="' +
                                    g + '"\r\n\r\n' + h + "\r\n")
                            }
                            e.push("--" + c + "--");
                            return new Blob(e, {type: "multipart/form-data; boundary=" + c})
                        };
                        n();
                        r();
                        X.prototype[Symbol.iterator] = function () {
                            return this.entries()
                        };
                        X.prototype.toString = function () {
                            return "[object FormData]"
                        };
                        U && (X.prototype[U] = "FormData");
                        [["append", N], ["delete", O], ["get", O], ["getAll", O], ["has", O], ["set", N]].forEach(function (c) {
                            var e = X.prototype[c[0]];
                            X.prototype[c[0]] = function () {
                                return e.apply(this, c[1].apply(this, W(arguments)))
                            }
                        });
                        S && (XMLHttpRequest.prototype.send = function (c) {
                            c instanceof
                            X ? (c = c._blob(), this.setRequestHeader("Content-Type", c.type), S.call(this, c)) : S.call(this, c)
                        });
                        if (T) {
                            var Y = Q.fetch;
                            Q.fetch = function (c, e) {
                                e && e.body && e.body instanceof X && (e.body = e.body._blob());
                                return Y(c, e)
                            }
                        }
                        Q.FormData = X
                    }
                    ;
                })();

            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
        }, {}], 11: [function (require, module, exports) {
            (function (global) {
                /*!
    localForage -- Offline Storage, Improved
    Version 1.7.2
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
                (function (f) {
                    if (typeof exports === "object" && typeof module !== "undefined") {
                        module.exports = f()
                    } else if (typeof define === "function" && define.amd) {
                        define([], f)
                    } else {
                        var g;
                        if (typeof window !== "undefined") {
                            g = window
                        } else if (typeof global !== "undefined") {
                            g = global
                        } else if (typeof self !== "undefined") {
                            g = self
                        } else {
                            g = this
                        }
                        g.localforage = f()
                    }
                })(function () {
                    var define, module, exports;
                    return (function e(t, n, r) {
                        function s(o, u) {
                            if (!n[o]) {
                                if (!t[o]) {
                                    var a = typeof require == "function" && require;
                                    if (!u && a) return a(o, !0);
                                    if (i) return i(o, !0);
                                    var f = new Error("Cannot find module '" + o + "'");
                                    throw (f.code = "MODULE_NOT_FOUND", f)
                                }
                                var l = n[o] = {exports: {}};
                                t[o][0].call(l.exports, function (e) {
                                    var n = t[o][1][e];
                                    return s(n ? n : e)
                                }, l, l.exports, e, t, n, r)
                            }
                            return n[o].exports
                        }

                        var i = typeof require == "function" && require;
                        for (var o = 0; o < r.length; o++) s(r[o]);
                        return s
                    })({
                        1: [function (_dereq_, module, exports) {
                            (function (global) {
                                'use strict';
                                var Mutation = global.MutationObserver || global.WebKitMutationObserver;

                                var scheduleDrain;

                                {
                                    if (Mutation) {
                                        var called = 0;
                                        var observer = new Mutation(nextTick);
                                        var element = global.document.createTextNode('');
                                        observer.observe(element, {
                                            characterData: true
                                        });
                                        scheduleDrain = function () {
                                            element.data = (called = ++called % 2);
                                        };
                                    } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
                                        var channel = new global.MessageChannel();
                                        channel.port1.onmessage = nextTick;
                                        scheduleDrain = function () {
                                            channel.port2.postMessage(0);
                                        };
                                    } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
                                        scheduleDrain = function () {

                                            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
                                            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
                                            var scriptEl = global.document.createElement('script');
                                            scriptEl.onreadystatechange = function () {
                                                nextTick();

                                                scriptEl.onreadystatechange = null;
                                                scriptEl.parentNode.removeChild(scriptEl);
                                                scriptEl = null;
                                            };
                                            global.document.documentElement.appendChild(scriptEl);
                                        };
                                    } else {
                                        scheduleDrain = function () {
                                            setTimeout(nextTick, 0);
                                        };
                                    }
                                }

                                var draining;
                                var queue = [];

//named nextTick for less confusing stack traces
                                function nextTick() {
                                    draining = true;
                                    var i, oldQueue;
                                    var len = queue.length;
                                    while (len) {
                                        oldQueue = queue;
                                        queue = [];
                                        i = -1;
                                        while (++i < len) {
                                            oldQueue[i]();
                                        }
                                        len = queue.length;
                                    }
                                    draining = false;
                                }

                                module.exports = immediate;

                                function immediate(task) {
                                    if (queue.push(task) === 1 && !draining) {
                                        scheduleDrain();
                                    }
                                }

                            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
                        }, {}], 2: [function (_dereq_, module, exports) {
                            'use strict';
                            var immediate = _dereq_(1);

                            /* istanbul ignore next */
                            function INTERNAL() {
                            }

                            var handlers = {};

                            var REJECTED = ['REJECTED'];
                            var FULFILLED = ['FULFILLED'];
                            var PENDING = ['PENDING'];

                            module.exports = Promise;

                            function Promise(resolver) {
                                if (typeof resolver !== 'function') {
                                    throw new TypeError('resolver must be a function');
                                }
                                this.state = PENDING;
                                this.queue = [];
                                this.outcome = void 0;
                                if (resolver !== INTERNAL) {
                                    safelyResolveThenable(this, resolver);
                                }
                            }

                            Promise.prototype["catch"] = function (onRejected) {
                                return this.then(null, onRejected);
                            };
                            Promise.prototype.then = function (onFulfilled, onRejected) {
                                if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
                                    typeof onRejected !== 'function' && this.state === REJECTED) {
                                    return this;
                                }
                                var promise = new this.constructor(INTERNAL);
                                if (this.state !== PENDING) {
                                    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
                                    unwrap(promise, resolver, this.outcome);
                                } else {
                                    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
                                }

                                return promise;
                            };

                            function QueueItem(promise, onFulfilled, onRejected) {
                                this.promise = promise;
                                if (typeof onFulfilled === 'function') {
                                    this.onFulfilled = onFulfilled;
                                    this.callFulfilled = this.otherCallFulfilled;
                                }
                                if (typeof onRejected === 'function') {
                                    this.onRejected = onRejected;
                                    this.callRejected = this.otherCallRejected;
                                }
                            }

                            QueueItem.prototype.callFulfilled = function (value) {
                                handlers.resolve(this.promise, value);
                            };
                            QueueItem.prototype.otherCallFulfilled = function (value) {
                                unwrap(this.promise, this.onFulfilled, value);
                            };
                            QueueItem.prototype.callRejected = function (value) {
                                handlers.reject(this.promise, value);
                            };
                            QueueItem.prototype.otherCallRejected = function (value) {
                                unwrap(this.promise, this.onRejected, value);
                            };

                            function unwrap(promise, func, value) {
                                immediate(function () {
                                    var returnValue;
                                    try {
                                        returnValue = func(value);
                                    } catch (e) {
                                        return handlers.reject(promise, e);
                                    }
                                    if (returnValue === promise) {
                                        handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
                                    } else {
                                        handlers.resolve(promise, returnValue);
                                    }
                                });
                            }

                            handlers.resolve = function (self, value) {
                                var result = tryCatch(getThen, value);
                                if (result.status === 'error') {
                                    return handlers.reject(self, result.value);
                                }
                                var thenable = result.value;

                                if (thenable) {
                                    safelyResolveThenable(self, thenable);
                                } else {
                                    self.state = FULFILLED;
                                    self.outcome = value;
                                    var i = -1;
                                    var len = self.queue.length;
                                    while (++i < len) {
                                        self.queue[i].callFulfilled(value);
                                    }
                                }
                                return self;
                            };
                            handlers.reject = function (self, error) {
                                self.state = REJECTED;
                                self.outcome = error;
                                var i = -1;
                                var len = self.queue.length;
                                while (++i < len) {
                                    self.queue[i].callRejected(error);
                                }
                                return self;
                            };

                            function getThen(obj) {
                                // Make sure we only access the accessor once as required by the spec
                                var then = obj && obj.then;
                                if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
                                    return function appyThen() {
                                        then.apply(obj, arguments);
                                    };
                                }
                            }

                            function safelyResolveThenable(self, thenable) {
                                // Either fulfill, reject or reject with error
                                var called = false;

                                function onError(value) {
                                    if (called) {
                                        return;
                                    }
                                    called = true;
                                    handlers.reject(self, value);
                                }

                                function onSuccess(value) {
                                    if (called) {
                                        return;
                                    }
                                    called = true;
                                    handlers.resolve(self, value);
                                }

                                function tryToUnwrap() {
                                    thenable(onSuccess, onError);
                                }

                                var result = tryCatch(tryToUnwrap);
                                if (result.status === 'error') {
                                    onError(result.value);
                                }
                            }

                            function tryCatch(func, value) {
                                var out = {};
                                try {
                                    out.value = func(value);
                                    out.status = 'success';
                                } catch (e) {
                                    out.status = 'error';
                                    out.value = e;
                                }
                                return out;
                            }

                            Promise.resolve = resolve;

                            function resolve(value) {
                                if (value instanceof this) {
                                    return value;
                                }
                                return handlers.resolve(new this(INTERNAL), value);
                            }

                            Promise.reject = reject;

                            function reject(reason) {
                                var promise = new this(INTERNAL);
                                return handlers.reject(promise, reason);
                            }

                            Promise.all = all;

                            function all(iterable) {
                                var self = this;
                                if (Object.prototype.toString.call(iterable) !== '[object Array]') {
                                    return this.reject(new TypeError('must be an array'));
                                }

                                var len = iterable.length;
                                var called = false;
                                if (!len) {
                                    return this.resolve([]);
                                }

                                var values = new Array(len);
                                var resolved = 0;
                                var i = -1;
                                var promise = new this(INTERNAL);

                                while (++i < len) {
                                    allResolver(iterable[i], i);
                                }
                                return promise;

                                function allResolver(value, i) {
                                    self.resolve(value).then(resolveFromAll, function (error) {
                                        if (!called) {
                                            called = true;
                                            handlers.reject(promise, error);
                                        }
                                    });

                                    function resolveFromAll(outValue) {
                                        values[i] = outValue;
                                        if (++resolved === len && !called) {
                                            called = true;
                                            handlers.resolve(promise, values);
                                        }
                                    }
                                }
                            }

                            Promise.race = race;

                            function race(iterable) {
                                var self = this;
                                if (Object.prototype.toString.call(iterable) !== '[object Array]') {
                                    return this.reject(new TypeError('must be an array'));
                                }

                                var len = iterable.length;
                                var called = false;
                                if (!len) {
                                    return this.resolve([]);
                                }

                                var i = -1;
                                var promise = new this(INTERNAL);

                                while (++i < len) {
                                    resolver(iterable[i]);
                                }
                                return promise;

                                function resolver(value) {
                                    self.resolve(value).then(function (response) {
                                        if (!called) {
                                            called = true;
                                            handlers.resolve(promise, response);
                                        }
                                    }, function (error) {
                                        if (!called) {
                                            called = true;
                                            handlers.reject(promise, error);
                                        }
                                    });
                                }
                            }

                        }, {"1": 1}], 3: [function (_dereq_, module, exports) {
                            (function (global) {
                                'use strict';
                                if (typeof global.Promise !== 'function') {
                                    global.Promise = _dereq_(2);
                                }

                            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
                        }, {"2": 2}], 4: [function (_dereq_, module, exports) {
                            'use strict';

                            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
                                return typeof obj;
                            } : function (obj) {
                                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                            };

                            function _classCallCheck(instance, Constructor) {
                                if (!(instance instanceof Constructor)) {
                                    throw new TypeError("Cannot call a class as a function");
                                }
                            }

                            function getIDB() {
                                /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */
                                try {
                                    if (typeof indexedDB !== 'undefined') {
                                        return indexedDB;
                                    }
                                    if (typeof webkitIndexedDB !== 'undefined') {
                                        return webkitIndexedDB;
                                    }
                                    if (typeof mozIndexedDB !== 'undefined') {
                                        return mozIndexedDB;
                                    }
                                    if (typeof OIndexedDB !== 'undefined') {
                                        return OIndexedDB;
                                    }
                                    if (typeof msIndexedDB !== 'undefined') {
                                        return msIndexedDB;
                                    }
                                } catch (e) {
                                    return;
                                }
                            }

                            var idb = getIDB();

                            function isIndexedDBValid() {
                                try {
                                    // Initialize IndexedDB; fall back to vendor-prefixed versions
                                    // if needed.
                                    if (!idb) {
                                        return false;
                                    }
                                    // We mimic PouchDB here;
                                    //
                                    // We test for openDatabase because IE Mobile identifies itself
                                    // as Safari. Oh the lulz...
                                    var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);

                                    var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;

                                    // Safari <10.1 does not meet our requirements for IDB support (#5572)
                                    // since Safari 10.1 shipped with fetch, we can use that to detect it
                                    return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&
                                        // some outdated implementations of IDB that appear on Samsung
                                        // and HTC Android devices <4.4 are missing IDBKeyRange
                                        // See: https://github.com/mozilla/localForage/issues/128
                                        // See: https://github.com/mozilla/localForage/issues/272
                                        typeof IDBKeyRange !== 'undefined';
                                } catch (e) {
                                    return false;
                                }
                            }

// Abstracts constructing a Blob object, so it also works in older
// browsers that don't support the native Blob constructor. (i.e.
// old QtWebKit versions, at least).
// Abstracts constructing a Blob object, so it also works in older
// browsers that don't support the native Blob constructor. (i.e.
// old QtWebKit versions, at least).
                            function createBlob(parts, properties) {
                                /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */
                                parts = parts || [];
                                properties = properties || {};
                                try {
                                    return new Blob(parts, properties);
                                } catch (e) {
                                    if (e.name !== 'TypeError') {
                                        throw e;
                                    }
                                    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;
                                    var builder = new Builder();
                                    for (var i = 0; i < parts.length; i += 1) {
                                        builder.append(parts[i]);
                                    }
                                    return builder.getBlob(properties.type);
                                }
                            }

// This is CommonJS because lie is an external dependency, so Rollup
// can just ignore it.
                            if (typeof Promise === 'undefined') {
                                // In the "nopromises" build this will just throw if you don't have
                                // a global promise object, but it would throw anyway later.
                                _dereq_(3);
                            }
                            var Promise$1 = Promise;

                            function executeCallback(promise, callback) {
                                if (callback) {
                                    promise.then(function (result) {
                                        callback(null, result);
                                    }, function (error) {
                                        callback(error);
                                    });
                                }
                            }

                            function executeTwoCallbacks(promise, callback, errorCallback) {
                                if (typeof callback === 'function') {
                                    promise.then(callback);
                                }

                                if (typeof errorCallback === 'function') {
                                    promise["catch"](errorCallback);
                                }
                            }

                            function normalizeKey(key) {
                                // Cast the key to a string, as that's all we can set as a key.
                                if (typeof key !== 'string') {
                                    console.warn(key + ' used as a key, but it is not a string.');
                                    key = String(key);
                                }

                                return key;
                            }

                            function getCallback() {
                                if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {
                                    return arguments[arguments.length - 1];
                                }
                            }

// Some code originally from async_storage.js in
// [Gaia](https://github.com/mozilla-b2g/gaia).

                            var DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';
                            var supportsBlobs = void 0;
                            var dbContexts = {};
                            var toString = Object.prototype.toString;

// Transaction Modes
                            var READ_ONLY = 'readonly';
                            var READ_WRITE = 'readwrite';

// Transform a binary string to an array buffer, because otherwise
// weird stuff happens when you try to work with the binary string directly.
// It is known.
// From http://stackoverflow.com/questions/14967647/ (continues on next line)
// encode-decode-image-with-base64-breaks-image (2013-04-21)
                            function _binStringToArrayBuffer(bin) {
                                var length = bin.length;
                                var buf = new ArrayBuffer(length);
                                var arr = new Uint8Array(buf);
                                for (var i = 0; i < length; i++) {
                                    arr[i] = bin.charCodeAt(i);
                                }
                                return buf;
                            }

//
// Blobs are not supported in all versions of IndexedDB, notably
// Chrome <37 and Android <5. In those versions, storing a blob will throw.
//
// Various other blob bugs exist in Chrome v37-42 (inclusive).
// Detecting them is expensive and confusing to users, and Chrome 37-42
// is at very low usage worldwide, so we do a hacky userAgent check instead.
//
// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120
// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916
// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836
//
// Code borrowed from PouchDB. See:
// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js
//
                            function _checkBlobSupportWithoutCaching(idb) {
                                return new Promise$1(function (resolve) {
                                    var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
                                    var blob = createBlob(['']);
                                    txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');

                                    txn.onabort = function (e) {
                                        // If the transaction aborts now its due to not being able to
                                        // write to the database, likely due to the disk being full
                                        e.preventDefault();
                                        e.stopPropagation();
                                        resolve(false);
                                    };

                                    txn.oncomplete = function () {
                                        var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
                                        var matchedEdge = navigator.userAgent.match(/Edge\//);
                                        // MS Edge pretends to be Chrome 42:
                                        // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx
                                        resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
                                    };
                                })["catch"](function () {
                                    return false; // error, so assume unsupported
                                });
                            }

                            function _checkBlobSupport(idb) {
                                if (typeof supportsBlobs === 'boolean') {
                                    return Promise$1.resolve(supportsBlobs);
                                }
                                return _checkBlobSupportWithoutCaching(idb).then(function (value) {
                                    supportsBlobs = value;
                                    return supportsBlobs;
                                });
                            }

                            function _deferReadiness(dbInfo) {
                                var dbContext = dbContexts[dbInfo.name];

                                // Create a deferred object representing the current database operation.
                                var deferredOperation = {};

                                deferredOperation.promise = new Promise$1(function (resolve, reject) {
                                    deferredOperation.resolve = resolve;
                                    deferredOperation.reject = reject;
                                });

                                // Enqueue the deferred operation.
                                dbContext.deferredOperations.push(deferredOperation);

                                // Chain its promise to the database readiness.
                                if (!dbContext.dbReady) {
                                    dbContext.dbReady = deferredOperation.promise;
                                } else {
                                    dbContext.dbReady = dbContext.dbReady.then(function () {
                                        return deferredOperation.promise;
                                    });
                                }
                            }

                            function _advanceReadiness(dbInfo) {
                                var dbContext = dbContexts[dbInfo.name];

                                // Dequeue a deferred operation.
                                var deferredOperation = dbContext.deferredOperations.pop();

                                // Resolve its promise (which is part of the database readiness
                                // chain of promises).
                                if (deferredOperation) {
                                    deferredOperation.resolve();
                                    return deferredOperation.promise;
                                }
                            }

                            function _rejectReadiness(dbInfo, err) {
                                var dbContext = dbContexts[dbInfo.name];

                                // Dequeue a deferred operation.
                                var deferredOperation = dbContext.deferredOperations.pop();

                                // Reject its promise (which is part of the database readiness
                                // chain of promises).
                                if (deferredOperation) {
                                    deferredOperation.reject(err);
                                    return deferredOperation.promise;
                                }
                            }

                            function _getConnection(dbInfo, upgradeNeeded) {
                                return new Promise$1(function (resolve, reject) {
                                    dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();

                                    if (dbInfo.db) {
                                        if (upgradeNeeded) {
                                            _deferReadiness(dbInfo);
                                            dbInfo.db.close();
                                        } else {
                                            return resolve(dbInfo.db);
                                        }
                                    }

                                    var dbArgs = [dbInfo.name];

                                    if (upgradeNeeded) {
                                        dbArgs.push(dbInfo.version);
                                    }

                                    var openreq = idb.open.apply(idb, dbArgs);

                                    if (upgradeNeeded) {
                                        openreq.onupgradeneeded = function (e) {
                                            var db = openreq.result;
                                            try {
                                                db.createObjectStore(dbInfo.storeName);
                                                if (e.oldVersion <= 1) {
                                                    // Added when support for blob shims was added
                                                    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                                                }
                                            } catch (ex) {
                                                if (ex.name === 'ConstraintError') {
                                                    console.warn('The database "' + dbInfo.name + '"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                                                } else {
                                                    throw ex;
                                                }
                                            }
                                        };
                                    }

                                    openreq.onerror = function (e) {
                                        e.preventDefault();
                                        reject(openreq.error);
                                    };

                                    openreq.onsuccess = function () {
                                        resolve(openreq.result);
                                        _advanceReadiness(dbInfo);
                                    };
                                });
                            }

                            function _getOriginalConnection(dbInfo) {
                                return _getConnection(dbInfo, false);
                            }

                            function _getUpgradedConnection(dbInfo) {
                                return _getConnection(dbInfo, true);
                            }

                            function _isUpgradeNeeded(dbInfo, defaultVersion) {
                                if (!dbInfo.db) {
                                    return true;
                                }

                                var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
                                var isDowngrade = dbInfo.version < dbInfo.db.version;
                                var isUpgrade = dbInfo.version > dbInfo.db.version;

                                if (isDowngrade) {
                                    // If the version is not the default one
                                    // then warn for impossible downgrade.
                                    if (dbInfo.version !== defaultVersion) {
                                        console.warn('The database "' + dbInfo.name + '"' + " can't be downgraded from version " + dbInfo.db.version + ' to version ' + dbInfo.version + '.');
                                    }
                                    // Align the versions to prevent errors.
                                    dbInfo.version = dbInfo.db.version;
                                }

                                if (isUpgrade || isNewStore) {
                                    // If the store is new then increment the version (if needed).
                                    // This will trigger an "upgradeneeded" event which is required
                                    // for creating a store.
                                    if (isNewStore) {
                                        var incVersion = dbInfo.db.version + 1;
                                        if (incVersion > dbInfo.version) {
                                            dbInfo.version = incVersion;
                                        }
                                    }

                                    return true;
                                }

                                return false;
                            }

// encode a blob for indexeddb engines that don't support blobs
                            function _encodeBlob(blob) {
                                return new Promise$1(function (resolve, reject) {
                                    var reader = new FileReader();
                                    reader.onerror = reject;
                                    reader.onloadend = function (e) {
                                        var base64 = btoa(e.target.result || '');
                                        resolve({
                                            __local_forage_encoded_blob: true,
                                            data: base64,
                                            type: blob.type
                                        });
                                    };
                                    reader.readAsBinaryString(blob);
                                });
                            }

// decode an encoded blob
                            function _decodeBlob(encodedBlob) {
                                var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
                                return createBlob([arrayBuff], {type: encodedBlob.type});
                            }

// is this one of our fancy encoded blobs?
                            function _isEncodedBlob(value) {
                                return value && value.__local_forage_encoded_blob;
                            }

// Specialize the default `ready()` function by making it dependent
// on the current database operations. Thus, the driver will be actually
// ready when it's been initialized (default) *and* there are no pending
// operations on the database (initiated by some other instances).
                            function _fullyReady(callback) {
                                var self = this;

                                var promise = self._initReady().then(function () {
                                    var dbContext = dbContexts[self._dbInfo.name];

                                    if (dbContext && dbContext.dbReady) {
                                        return dbContext.dbReady;
                                    }
                                });

                                executeTwoCallbacks(promise, callback, callback);
                                return promise;
                            }

// Try to establish a new db connection to replace the
// current one which is broken (i.e. experiencing
// InvalidStateError while creating a transaction).
                            function _tryReconnect(dbInfo) {
                                _deferReadiness(dbInfo);

                                var dbContext = dbContexts[dbInfo.name];
                                var forages = dbContext.forages;

                                for (var i = 0; i < forages.length; i++) {
                                    var forage = forages[i];
                                    if (forage._dbInfo.db) {
                                        forage._dbInfo.db.close();
                                        forage._dbInfo.db = null;
                                    }
                                }
                                dbInfo.db = null;

                                return _getOriginalConnection(dbInfo).then(function (db) {
                                    dbInfo.db = db;
                                    if (_isUpgradeNeeded(dbInfo)) {
                                        // Reopen the database for upgrading.
                                        return _getUpgradedConnection(dbInfo);
                                    }
                                    return db;
                                }).then(function (db) {
                                    // store the latest db reference
                                    // in case the db was upgraded
                                    dbInfo.db = dbContext.db = db;
                                    for (var i = 0; i < forages.length; i++) {
                                        forages[i]._dbInfo.db = db;
                                    }
                                })["catch"](function (err) {
                                    _rejectReadiness(dbInfo, err);
                                    throw err;
                                });
                            }

// FF doesn't like Promises (micro-tasks) and IDDB store operations,
// so we have to do it with callbacks
                            function createTransaction(dbInfo, mode, callback, retries) {
                                if (retries === undefined) {
                                    retries = 1;
                                }

                                try {
                                    var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
                                    callback(null, tx);
                                } catch (err) {
                                    if (retries > 0 && (!dbInfo.db || err.name === 'InvalidStateError' || err.name === 'NotFoundError')) {
                                        return Promise$1.resolve().then(function () {
                                            if (!dbInfo.db || err.name === 'NotFoundError' && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                                                // increase the db version, to create the new ObjectStore
                                                if (dbInfo.db) {
                                                    dbInfo.version = dbInfo.db.version + 1;
                                                }
                                                // Reopen the database for upgrading.
                                                return _getUpgradedConnection(dbInfo);
                                            }
                                        }).then(function () {
                                            return _tryReconnect(dbInfo).then(function () {
                                                createTransaction(dbInfo, mode, callback, retries - 1);
                                            });
                                        })["catch"](callback);
                                    }

                                    callback(err);
                                }
                            }

                            function createDbContext() {
                                return {
                                    // Running localForages sharing a database.
                                    forages: [],
                                    // Shared database.
                                    db: null,
                                    // Database readiness (promise).
                                    dbReady: null,
                                    // Deferred operations on the database.
                                    deferredOperations: []
                                };
                            }

// Open the IndexedDB database (automatically creates one if one didn't
// previously exist), using any options set in the config.
                            function _initStorage(options) {
                                var self = this;
                                var dbInfo = {
                                    db: null
                                };

                                if (options) {
                                    for (var i in options) {
                                        dbInfo[i] = options[i];
                                    }
                                }

                                // Get the current context of the database;
                                var dbContext = dbContexts[dbInfo.name];

                                // ...or create a new context.
                                if (!dbContext) {
                                    dbContext = createDbContext();
                                    // Register the new context in the global container.
                                    dbContexts[dbInfo.name] = dbContext;
                                }

                                // Register itself as a running localForage in the current context.
                                dbContext.forages.push(self);

                                // Replace the default `ready()` function with the specialized one.
                                if (!self._initReady) {
                                    self._initReady = self.ready;
                                    self.ready = _fullyReady;
                                }

                                // Create an array of initialization states of the related localForages.
                                var initPromises = [];

                                function ignoreErrors() {
                                    // Don't handle errors here,
                                    // just makes sure related localForages aren't pending.
                                    return Promise$1.resolve();
                                }

                                for (var j = 0; j < dbContext.forages.length; j++) {
                                    var forage = dbContext.forages[j];
                                    if (forage !== self) {
                                        // Don't wait for itself...
                                        initPromises.push(forage._initReady()["catch"](ignoreErrors));
                                    }
                                }

                                // Take a snapshot of the related localForages.
                                var forages = dbContext.forages.slice(0);

                                // Initialize the connection process only when
                                // all the related localForages aren't pending.
                                return Promise$1.all(initPromises).then(function () {
                                    dbInfo.db = dbContext.db;
                                    // Get the connection or open a new one without upgrade.
                                    return _getOriginalConnection(dbInfo);
                                }).then(function (db) {
                                    dbInfo.db = db;
                                    if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {
                                        // Reopen the database for upgrading.
                                        return _getUpgradedConnection(dbInfo);
                                    }
                                    return db;
                                }).then(function (db) {
                                    dbInfo.db = dbContext.db = db;
                                    self._dbInfo = dbInfo;
                                    // Share the final connection amongst related localForages.
                                    for (var k = 0; k < forages.length; k++) {
                                        var forage = forages[k];
                                        if (forage !== self) {
                                            // Self is already up-to-date.
                                            forage._dbInfo.db = dbInfo.db;
                                            forage._dbInfo.version = dbInfo.version;
                                        }
                                    }
                                });
                            }

                            function getItem(key, callback) {
                                var self = this;

                                key = normalizeKey(key);

                                var promise = new Promise$1(function (resolve, reject) {
                                    self.ready().then(function () {
                                        createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                                            if (err) {
                                                return reject(err);
                                            }

                                            try {
                                                var store = transaction.objectStore(self._dbInfo.storeName);
                                                var req = store.get(key);

                                                req.onsuccess = function () {
                                                    var value = req.result;
                                                    if (value === undefined) {
                                                        value = null;
                                                    }
                                                    if (_isEncodedBlob(value)) {
                                                        value = _decodeBlob(value);
                                                    }
                                                    resolve(value);
                                                };

                                                req.onerror = function () {
                                                    reject(req.error);
                                                };
                                            } catch (e) {
                                                reject(e);
                                            }
                                        });
                                    })["catch"](reject);
                                });

                                executeCallback(promise, callback);
                                return promise;
                            }

// Iterate over all items stored in database.
                            function iterate(iterator, callback) {
                                var self = this;

                                var promise = new Promise$1(function (resolve, reject) {
                                    self.ready().then(function () {
                                        createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                                            if (err) {
                                                return reject(err);
                                            }

                                            try {
                                                var store = transaction.objectStore(self._dbInfo.storeName);
                                                var req = store.openCursor();
                                                var iterationNumber = 1;

                                                req.onsuccess = function () {
                                                    var cursor = req.result;

                                                    if (cursor) {
                                                        var value = cursor.value;
                                                        if (_isEncodedBlob(value)) {
                                                            value = _decodeBlob(value);
                                                        }
                                                        var result = iterator(value, cursor.key, iterationNumber++);

                                                        // when the iterator callback retuns any
                                                        // (non-`undefined`) value, then we stop
                                                        // the iteration immediately
                                                        if (result !== void 0) {
                                                            resolve(result);
                                                        } else {
                                                            cursor["continue"]();
                                                        }
                                                    } else {
                                                        resolve();
                                                    }
                                                };

                                                req.onerror = function () {
                                                    reject(req.error);
                                                };
                                            } catch (e) {
                                                reject(e);
                                            }
                                        });
                                    })["catch"](reject);
                                });

                                executeCallback(promise, callback);

                                return promise;
                            }

                            function setItem(key, value, callback) {
                                var self = this;

                                key = normalizeKey(key);

                                var promise = new Promise$1(function (resolve, reject) {
                                    var dbInfo;
                                    self.ready().then(function () {
                                        dbInfo = self._dbInfo;
                                        if (toString.call(value) === '[object Blob]') {
                                            return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {
                                                if (blobSupport) {
                                                    return value;
                                                }
                                                return _encodeBlob(value);
                                            });
                                        }
                                        return value;
                                    }).then(function (value) {
                                        createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                                            if (err) {
                                                return reject(err);
                                            }

                                            try {
                                                var store = transaction.objectStore(self._dbInfo.storeName);

                                                // The reason we don't _save_ null is because IE 10 does
                                                // not support saving the `null` type in IndexedDB. How
                                                // ironic, given the bug below!
                                                // See: https://github.com/mozilla/localForage/issues/161
                                                if (value === null) {
                                                    value = undefined;
                                                }

                                                var req = store.put(value, key);

                                                transaction.oncomplete = function () {
                                                    // Cast to undefined so the value passed to
                                                    // callback/promise is the same as what one would get out
                                                    // of `getItem()` later. This leads to some weirdness
                                                    // (setItem('foo', undefined) will return `null`), but
                                                    // it's not my fault localStorage is our baseline and that
                                                    // it's weird.
                                                    if (value === undefined) {
                                                        value = null;
                                                    }

                                                    resolve(value);
                                                };
                                                transaction.onabort = transaction.onerror = function () {
                                                    var err = req.error ? req.error : req.transaction.error;
                                                    reject(err);
                                                };
                                            } catch (e) {
                                                reject(e);
                                            }
                                        });
                                    })["catch"](reject);
                                });

                                executeCallback(promise, callback);
                                return promise;
                            }

                            function removeItem(key, callback) {
                                var self = this;

                                key = normalizeKey(key);

                                var promise = new Promise$1(function (resolve, reject) {
                                    self.ready().then(function () {
                                        createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                                            if (err) {
                                                return reject(err);
                                            }

                                            try {
                                                var store = transaction.objectStore(self._dbInfo.storeName);
                                                // We use a Grunt task to make this safe for IE and some
                                                // versions of Android (including those used by Cordova).
                                                // Normally IE won't like `.delete()` and will insist on
                                                // using `['delete']()`, but we have a build step that
                                                // fixes this for us now.
                                                var req = store["delete"](key);
                                                transaction.oncomplete = function () {
                                                    resolve();
                                                };

                                                transaction.onerror = function () {
                                                    reject(req.error);
                                                };

                                                // The request will be also be aborted if we've exceeded our storage
                                                // space.
                                                transaction.onabort = function () {
                                                    var err = req.error ? req.error : req.transaction.error;
                                                    reject(err);
                                                };
                                            } catch (e) {
                                                reject(e);
                                            }
                                        });
                                    })["catch"](reject);
                                });

                                executeCallback(promise, callback);
                                return promise;
                            }

                            function clear(callback) {
                                var self = this;

                                var promise = new Promise$1(function (resolve, reject) {
                                    self.ready().then(function () {
                                        createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                                            if (err) {
                                                return reject(err);
                                            }

                                            try {
                                                var store = transaction.objectStore(self._dbInfo.storeName);
                                                var req = store.clear();

                                                transaction.oncomplete = function () {
                                                    resolve();
                                                };

                                                transaction.onabort = transaction.onerror = function () {
                                                    var err = req.error ? req.error : req.transaction.error;
                                                    reject(err);
                                                };
                                            } catch (e) {
                                                reject(e);
                                            }
                                        });
                                    })["catch"](reject);
                                });

                                executeCallback(promise, callback);
                                return promise;
                            }

                            function length(callback) {
                                var self = this;

                                var promise = new Promise$1(function (resolve, reject) {
                                    self.ready().then(function () {
                                        createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                                            if (err) {
                                                return reject(err);
                                            }

                                            try {
                                                var store = transaction.objectStore(self._dbInfo.storeName);
                                                var req = store.count();

                                                req.onsuccess = function () {
                                                    resolve(req.result);
                                                };

                                                req.onerror = function () {
                                                    reject(req.error);
                                                };
                                            } catch (e) {
                                                reject(e);
                                            }
                                        });
                                    })["catch"](reject);
                                });

                                executeCallback(promise, callback);
                                return promise;
                            }

                            function key(n, callback) {
                                var self = this;

                                var promise = new Promise$1(function (resolve, reject) {
                                    if (n < 0) {
                                        resolve(null);

                                        return;
                                    }

                                    self.ready().then(function () {
                                        createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                                            if (err) {
                                                return reject(err);
                                            }

                                            try {
                                                var store = transaction.objectStore(self._dbInfo.storeName);
                                                var advanced = false;
                                                var req = store.openCursor();

                                                req.onsuccess = function () {
                                                    var cursor = req.result;
                                                    if (!cursor) {
                                                        // this means there weren't enough keys
                                                        resolve(null);

                                                        return;
                                                    }

                                                    if (n === 0) {
                                                        // We have the first key, return it if that's what they
                                                        // wanted.
                                                        resolve(cursor.key);
                                                    } else {
                                                        if (!advanced) {
                                                            // Otherwise, ask the cursor to skip ahead n
                                                            // records.
                                                            advanced = true;
                                                            cursor.advance(n);
                                                        } else {
                                                            // When we get here, we've got the nth key.
                                                            resolve(cursor.key);
                                                        }
                                                    }
                                                };

                                                req.onerror = function () {
                                                    reject(req.error);
                                                };
                                            } catch (e) {
                                                reject(e);
                                            }
                                        });
                                    })["catch"](reject);
                                });

                                executeCallback(promise, callback);
                                return promise;
                            }

                            function keys(callback) {
                                var self = this;

                                var promise = new Promise$1(function (resolve, reject) {
                                    self.ready().then(function () {
                                        createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                                            if (err) {
                                                return reject(err);
                                            }

                                            try {
                                                var store = transaction.objectStore(self._dbInfo.storeName);
                                                var req = store.openCursor();
                                                var keys = [];

                                                req.onsuccess = function () {
                                                    var cursor = req.result;

                                                    if (!cursor) {
                                                        resolve(keys);
                                                        return;
                                                    }

                                                    keys.push(cursor.key);
                                                    cursor["continue"]();
                                                };

                                                req.onerror = function () {
                                                    reject(req.error);
                                                };
                                            } catch (e) {
                                                reject(e);
                                            }
                                        });
                                    })["catch"](reject);
                                });

                                executeCallback(promise, callback);
                                return promise;
                            }

                            function dropInstance(options, callback) {
                                callback = getCallback.apply(this, arguments);

                                var currentConfig = this.config();
                                options = typeof options !== 'function' && options || {};
                                if (!options.name) {
                                    options.name = options.name || currentConfig.name;
                                    options.storeName = options.storeName || currentConfig.storeName;
                                }

                                var self = this;
                                var promise;
                                if (!options.name) {
                                    promise = Promise$1.reject('Invalid arguments');
                                } else {
                                    var isCurrentDb = options.name === currentConfig.name && self._dbInfo.db;

                                    var dbPromise = isCurrentDb ? Promise$1.resolve(self._dbInfo.db) : _getOriginalConnection(options).then(function (db) {
                                        var dbContext = dbContexts[options.name];
                                        var forages = dbContext.forages;
                                        dbContext.db = db;
                                        for (var i = 0; i < forages.length; i++) {
                                            forages[i]._dbInfo.db = db;
                                        }
                                        return db;
                                    });

                                    if (!options.storeName) {
                                        promise = dbPromise.then(function (db) {
                                            _deferReadiness(options);

                                            var dbContext = dbContexts[options.name];
                                            var forages = dbContext.forages;

                                            db.close();
                                            for (var i = 0; i < forages.length; i++) {
                                                var forage = forages[i];
                                                forage._dbInfo.db = null;
                                            }

                                            var dropDBPromise = new Promise$1(function (resolve, reject) {
                                                var req = idb.deleteDatabase(options.name);

                                                req.onerror = req.onblocked = function (err) {
                                                    var db = req.result;
                                                    if (db) {
                                                        db.close();
                                                    }
                                                    reject(err);
                                                };

                                                req.onsuccess = function () {
                                                    var db = req.result;
                                                    if (db) {
                                                        db.close();
                                                    }
                                                    resolve(db);
                                                };
                                            });

                                            return dropDBPromise.then(function (db) {
                                                dbContext.db = db;
                                                for (var i = 0; i < forages.length; i++) {
                                                    var _forage = forages[i];
                                                    _advanceReadiness(_forage._dbInfo);
                                                }
                                            })["catch"](function (err) {
                                                (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {
                                                });
                                                throw err;
                                            });
                                        });
                                    } else {
                                        promise = dbPromise.then(function (db) {
                                            if (!db.objectStoreNames.contains(options.storeName)) {
                                                return;
                                            }

                                            var newVersion = db.version + 1;

                                            _deferReadiness(options);

                                            var dbContext = dbContexts[options.name];
                                            var forages = dbContext.forages;

                                            db.close();
                                            for (var i = 0; i < forages.length; i++) {
                                                var forage = forages[i];
                                                forage._dbInfo.db = null;
                                                forage._dbInfo.version = newVersion;
                                            }

                                            var dropObjectPromise = new Promise$1(function (resolve, reject) {
                                                var req = idb.open(options.name, newVersion);

                                                req.onerror = function (err) {
                                                    var db = req.result;
                                                    db.close();
                                                    reject(err);
                                                };

                                                req.onupgradeneeded = function () {
                                                    var db = req.result;
                                                    db.deleteObjectStore(options.storeName);
                                                };

                                                req.onsuccess = function () {
                                                    var db = req.result;
                                                    db.close();
                                                    resolve(db);
                                                };
                                            });

                                            return dropObjectPromise.then(function (db) {
                                                dbContext.db = db;
                                                for (var j = 0; j < forages.length; j++) {
                                                    var _forage2 = forages[j];
                                                    _forage2._dbInfo.db = db;
                                                    _advanceReadiness(_forage2._dbInfo);
                                                }
                                            })["catch"](function (err) {
                                                (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {
                                                });
                                                throw err;
                                            });
                                        });
                                    }
                                }

                                executeCallback(promise, callback);
                                return promise;
                            }

                            var asyncStorage = {
                                _driver: 'asyncStorage',
                                _initStorage: _initStorage,
                                _support: isIndexedDBValid(),
                                iterate: iterate,
                                getItem: getItem,
                                setItem: setItem,
                                removeItem: removeItem,
                                clear: clear,
                                length: length,
                                key: key,
                                keys: keys,
                                dropInstance: dropInstance
                            };

                            function isWebSQLValid() {
                                return typeof openDatabase === 'function';
                            }

// Sadly, the best way to save binary data in WebSQL/localStorage is serializing
// it to Base64, so this is how we store it to prevent very strange errors with less
// verbose ways of binary <-> string data storage.
                            var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

                            var BLOB_TYPE_PREFIX = '~~local_forage_type~';
                            var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;

                            var SERIALIZED_MARKER = '__lfsc__:';
                            var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;

// OMG the serializations!
                            var TYPE_ARRAYBUFFER = 'arbf';
                            var TYPE_BLOB = 'blob';
                            var TYPE_INT8ARRAY = 'si08';
                            var TYPE_UINT8ARRAY = 'ui08';
                            var TYPE_UINT8CLAMPEDARRAY = 'uic8';
                            var TYPE_INT16ARRAY = 'si16';
                            var TYPE_INT32ARRAY = 'si32';
                            var TYPE_UINT16ARRAY = 'ur16';
                            var TYPE_UINT32ARRAY = 'ui32';
                            var TYPE_FLOAT32ARRAY = 'fl32';
                            var TYPE_FLOAT64ARRAY = 'fl64';
                            var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;

                            var toString$1 = Object.prototype.toString;

                            function stringToBuffer(serializedString) {
                                // Fill the string into a ArrayBuffer.
                                var bufferLength = serializedString.length * 0.75;
                                var len = serializedString.length;
                                var i;
                                var p = 0;
                                var encoded1, encoded2, encoded3, encoded4;

                                if (serializedString[serializedString.length - 1] === '=') {
                                    bufferLength--;
                                    if (serializedString[serializedString.length - 2] === '=') {
                                        bufferLength--;
                                    }
                                }

                                var buffer = new ArrayBuffer(bufferLength);
                                var bytes = new Uint8Array(buffer);

                                for (i = 0; i < len; i += 4) {
                                    encoded1 = BASE_CHARS.indexOf(serializedString[i]);
                                    encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
                                    encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
                                    encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);

                                    /*jslint bitwise: true */
                                    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
                                    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
                                    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
                                }
                                return buffer;
                            }

// Converts a buffer to a string to store, serialized, in the backend
// storage library.
                            function bufferToString(buffer) {
                                // base64-arraybuffer
                                var bytes = new Uint8Array(buffer);
                                var base64String = '';
                                var i;

                                for (i = 0; i < bytes.length; i += 3) {
                                    /*jslint bitwise: true */
                                    base64String += BASE_CHARS[bytes[i] >> 2];
                                    base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
                                    base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
                                    base64String += BASE_CHARS[bytes[i + 2] & 63];
                                }

                                if (bytes.length % 3 === 2) {
                                    base64String = base64String.substring(0, base64String.length - 1) + '=';
                                } else if (bytes.length % 3 === 1) {
                                    base64String = base64String.substring(0, base64String.length - 2) + '==';
                                }

                                return base64String;
                            }

// Serialize a value, afterwards executing a callback (which usually
// instructs the `setItem()` callback/promise to be executed). This is how
// we store binary data with localStorage.
                            function serialize(value, callback) {
                                var valueType = '';
                                if (value) {
                                    valueType = toString$1.call(value);
                                }

                                // Cannot use `value instanceof ArrayBuffer` or such here, as these
                                // checks fail when running the tests using casper.js...
                                //
                                // TODO: See why those tests fail and use a better solution.
                                if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {
                                    // Convert binary arrays to a string and prefix the string with
                                    // a special marker.
                                    var buffer;
                                    var marker = SERIALIZED_MARKER;

                                    if (value instanceof ArrayBuffer) {
                                        buffer = value;
                                        marker += TYPE_ARRAYBUFFER;
                                    } else {
                                        buffer = value.buffer;

                                        if (valueType === '[object Int8Array]') {
                                            marker += TYPE_INT8ARRAY;
                                        } else if (valueType === '[object Uint8Array]') {
                                            marker += TYPE_UINT8ARRAY;
                                        } else if (valueType === '[object Uint8ClampedArray]') {
                                            marker += TYPE_UINT8CLAMPEDARRAY;
                                        } else if (valueType === '[object Int16Array]') {
                                            marker += TYPE_INT16ARRAY;
                                        } else if (valueType === '[object Uint16Array]') {
                                            marker += TYPE_UINT16ARRAY;
                                        } else if (valueType === '[object Int32Array]') {
                                            marker += TYPE_INT32ARRAY;
                                        } else if (valueType === '[object Uint32Array]') {
                                            marker += TYPE_UINT32ARRAY;
                                        } else if (valueType === '[object Float32Array]') {
                                            marker += TYPE_FLOAT32ARRAY;
                                        } else if (valueType === '[object Float64Array]') {
                                            marker += TYPE_FLOAT64ARRAY;
                                        } else {
                                            callback(new Error('Failed to get type for BinaryArray'));
                                        }
                                    }

                                    callback(marker + bufferToString(buffer));
                                } else if (valueType === '[object Blob]') {
                                    // Conver the blob to a binaryArray and then to a string.
                                    var fileReader = new FileReader();

                                    fileReader.onload = function () {
                                        // Backwards-compatible prefix for the blob type.
                                        var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);

                                        callback(SERIALIZED_MARKER + TYPE_BLOB + str);
                                    };

                                    fileReader.readAsArrayBuffer(value);
                                } else {
                                    try {
                                        callback(JSON.stringify(value));
                                    } catch (e) {
                                        console.error("Couldn't convert value into a JSON string: ", value);

                                        callback(null, e);
                                    }
                                }
                            }

// Deserialize data we've inserted into a value column/field. We place
// special markers into our strings to mark them as encoded; this isn't
// as nice as a meta field, but it's the only sane thing we can do whilst
// keeping localStorage support intact.
//
// Oftentimes this will just deserialize JSON content, but if we have a
// special marker (SERIALIZED_MARKER, defined above), we will extract
// some kind of arraybuffer/binary data/typed array out of the string.
                            function deserialize(value) {
                                // If we haven't marked this string as being specially serialized (i.e.
                                // something other than serialized JSON), we can just return it and be
                                // done with it.
                                if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
                                    return JSON.parse(value);
                                }

                                // The following code deals with deserializing some kind of Blob or
                                // TypedArray. First we separate out the type of data we're dealing
                                // with from the data itself.
                                var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
                                var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);

                                var blobType;
                                // Backwards-compatible blob type serialization strategy.
                                // DBs created with older versions of localForage will simply not have the blob type.
                                if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
                                    var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
                                    blobType = matcher[1];
                                    serializedString = serializedString.substring(matcher[0].length);
                                }
                                var buffer = stringToBuffer(serializedString);

                                // Return the right type based on the code/type set during
                                // serialization.
                                switch (type) {
                                    case TYPE_ARRAYBUFFER:
                                        return buffer;
                                    case TYPE_BLOB:
                                        return createBlob([buffer], {type: blobType});
                                    case TYPE_INT8ARRAY:
                                        return new Int8Array(buffer);
                                    case TYPE_UINT8ARRAY:
                                        return new Uint8Array(buffer);
                                    case TYPE_UINT8CLAMPEDARRAY:
                                        return new Uint8ClampedArray(buffer);
                                    case TYPE_INT16ARRAY:
                                        return new Int16Array(buffer);
                                    case TYPE_UINT16ARRAY:
                                        return new Uint16Array(buffer);
                                    case TYPE_INT32ARRAY:
                                        return new Int32Array(buffer);
                                    case TYPE_UINT32ARRAY:
                                        return new Uint32Array(buffer);
                                    case TYPE_FLOAT32ARRAY:
                                        return new Float32Array(buffer);
                                    case TYPE_FLOAT64ARRAY:
                                        return new Float64Array(buffer);
                                    default:
                                        throw new Error('Unkown type: ' + type);
                                }
                            }

                            var localforageSerializer = {
                                serialize: serialize,
                                deserialize: deserialize,
                                stringToBuffer: stringToBuffer,
                                bufferToString: bufferToString
                            };

                            /*
 * Includes code from:
 *
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */

                            function createDbTable(t, dbInfo, callback, errorCallback) {
                                t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' ' + '(id INTEGER PRIMARY KEY, key unique, value)', [], callback, errorCallback);
                            }

// Open the WebSQL database (automatically creates one if one didn't
// previously exist), using any options set in the config.
                            function _initStorage$1(options) {
                                var self = this;
                                var dbInfo = {
                                    db: null
                                };

                                if (options) {
                                    for (var i in options) {
                                        dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];
                                    }
                                }

                                var dbInfoPromise = new Promise$1(function (resolve, reject) {
                                    // Open the database; the openDatabase API will automatically
                                    // create it for us if it doesn't exist.
                                    try {
                                        dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
                                    } catch (e) {
                                        return reject(e);
                                    }

                                    // Create our key/value table if it doesn't exist.
                                    dbInfo.db.transaction(function (t) {
                                        createDbTable(t, dbInfo, function () {
                                            self._dbInfo = dbInfo;
                                            resolve();
                                        }, function (t, error) {
                                            reject(error);
                                        });
                                    }, reject);
                                });

                                dbInfo.serializer = localforageSerializer;
                                return dbInfoPromise;
                            }

                            function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {
                                t.executeSql(sqlStatement, args, callback, function (t, error) {
                                    if (error.code === error.SYNTAX_ERR) {
                                        t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name = ?", [dbInfo.storeName], function (t, results) {
                                            if (!results.rows.length) {
                                                // if the table is missing (was deleted)
                                                // re-create it table and retry
                                                createDbTable(t, dbInfo, function () {
                                                    t.executeSql(sqlStatement, args, callback, errorCallback);
                                                }, errorCallback);
                                            } else {
                                                errorCallback(t, error);
                                            }
                                        }, errorCallback);
                                    } else {
                                        errorCallback(t, error);
                                    }
                                }, errorCallback);
                            }

                            function getItem$1(key, callback) {
                                var self = this;

                                key = normalizeKey(key);

                                var promise = new Promise$1(function (resolve, reject) {
                                    self.ready().then(function () {
                                        var dbInfo = self._dbInfo;
                                        dbInfo.db.transaction(function (t) {
                                            tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {
                                                var result = results.rows.length ? results.rows.item(0).value : null;

                                                // Check to see if this is serialized content we need to
                                                // unpack.
                                                if (result) {
                                                    result = dbInfo.serializer.deserialize(result);
                                                }

                                                resolve(result);
                                            }, function (t, error) {
                                                reject(error);
                                            });
                                        });
                                    })["catch"](reject);
                                });

                                executeCallback(promise, callback);
                                return promise;
                            }

                            function iterate$1(iterator, callback) {
                                var self = this;

                                var promise = new Promise$1(function (resolve, reject) {
                                    self.ready().then(function () {
                                        var dbInfo = self._dbInfo;

                                        dbInfo.db.transaction(function (t) {
                                            tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {
                                                var rows = results.rows;
                                                var length = rows.length;

                                                for (var i = 0; i < length; i++) {
                                                    var item = rows.item(i);
                                                    var result = item.value;

                                                    // Check to see if this is serialized content
                                                    // we need to unpack.
                                                    if (result) {
                                                        result = dbInfo.serializer.deserialize(result);
                                                    }

                                                    result = iterator(result, item.key, i + 1);

                                                    // void(0) prevents problems with redefinition
                                                    // of `undefined`.
                                                    if (result !== void 0) {
                                                        resolve(result);
                                                        return;
                                                    }
                                                }

                                                resolve();
                                            }, function (t, error) {
                                                reject(error);
                                            });
                                        });
                                    })["catch"](reject);
                                });

                                executeCallback(promise, callback);
                                return promise;
                            }

                            function _setItem(key, value, callback, retriesLeft) {
                                var self = this;

                                key = normalizeKey(key);

                                var promise = new Promise$1(function (resolve, reject) {
                                    self.ready().then(function () {
                                        // The localStorage API doesn't return undefined values in an
                                        // "expected" way, so undefined is always cast to null in all
                                        // drivers. See: https://github.com/mozilla/localForage/pull/42
                                        if (value === undefined) {
                                            value = null;
                                        }

                                        // Save the original value to pass to the callback.
                                        var originalValue = value;

                                        var dbInfo = self._dbInfo;
                                        dbInfo.serializer.serialize(value, function (value, error) {
                                            if (error) {
                                                reject(error);
                                            } else {
                                                dbInfo.db.transaction(function (t) {
                                                    tryExecuteSql(t, dbInfo, 'INSERT OR REPLACE INTO ' + dbInfo.storeName + ' ' + '(key, value) VALUES (?, ?)', [key, value], function () {
                                                        resolve(originalValue);
                                                    }, function (t, error) {
                                                        reject(error);
                                                    });
                                                }, function (sqlError) {
                                                    // The transaction failed; check
                                                    // to see if it's a quota error.
                                                    if (sqlError.code === sqlError.QUOTA_ERR) {
                                                        // We reject the callback outright for now, but
                                                        // it's worth trying to re-run the transaction.
                                                        // Even if the user accepts the prompt to use
                                                        // more storage on Safari, this error will
                                                        // be called.
                                                        //
                                                        // Try to re-run the transaction.
                                                        if (retriesLeft > 0) {
                                                            resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));
                                                            return;
                                                        }
                                                        reject(sqlError);
                                                    }
                                                });
                                            }
                                        });
                                    })["catch"](reject);
                                });

                                executeCallback(promise, callback);
                                return promise;
                            }

                            function setItem$1(key, value, callback) {
                                return _setItem.apply(this, [key, value, callback, 1]);
                            }

                            function removeItem$1(key, callback) {
                                var self = this;

                                key = normalizeKey(key);

                                var promise = new Promise$1(function (resolve, reject) {
                                    self.ready().then(function () {
                                        var dbInfo = self._dbInfo;
                                        dbInfo.db.transaction(function (t) {
                                            tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {
                                                resolve();
                                            }, function (t, error) {
                                                reject(error);
                                            });
                                        });
                                    })["catch"](reject);
                                });

                                executeCallback(promise, callback);
                                return promise;
                            }

// Deletes every item in the table.
// TODO: Find out if this resets the AUTO_INCREMENT number.
                            function clear$1(callback) {
                                var self = this;

                                var promise = new Promise$1(function (resolve, reject) {
                                    self.ready().then(function () {
                                        var dbInfo = self._dbInfo;
                                        dbInfo.db.transaction(function (t) {
                                            tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName, [], function () {
                                                resolve();
                                            }, function (t, error) {
                                                reject(error);
                                            });
                                        });
                                    })["catch"](reject);
                                });

                                executeCallback(promise, callback);
                                return promise;
                            }

// Does a simple `COUNT(key)` to get the number of items stored in
// localForage.
                            function length$1(callback) {
                                var self = this;

                                var promise = new Promise$1(function (resolve, reject) {
                                    self.ready().then(function () {
                                        var dbInfo = self._dbInfo;
                                        dbInfo.db.transaction(function (t) {
                                            // Ahhh, SQL makes this one soooooo easy.
                                            tryExecuteSql(t, dbInfo, 'SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {
                                                var result = results.rows.item(0).c;
                                                resolve(result);
                                            }, function (t, error) {
                                                reject(error);
                                            });
                                        });
                                    })["catch"](reject);
                                });

                                executeCallback(promise, callback);
                                return promise;
                            }

// Return the key located at key index X; essentially gets the key from a
// `WHERE id = ?`. This is the most efficient way I can think to implement
// this rarely-used (in my experience) part of the API, but it can seem
// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so
// the ID of each key will change every time it's updated. Perhaps a stored
// procedure for the `setItem()` SQL would solve this problem?
// TODO: Don't change ID on `setItem()`.
                            function key$1(n, callback) {
                                var self = this;

                                var promise = new Promise$1(function (resolve, reject) {
                                    self.ready().then(function () {
                                        var dbInfo = self._dbInfo;
                                        dbInfo.db.transaction(function (t) {
                                            tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {
                                                var result = results.rows.length ? results.rows.item(0).key : null;
                                                resolve(result);
                                            }, function (t, error) {
                                                reject(error);
                                            });
                                        });
                                    })["catch"](reject);
                                });

                                executeCallback(promise, callback);
                                return promise;
                            }

                            function keys$1(callback) {
                                var self = this;

                                var promise = new Promise$1(function (resolve, reject) {
                                    self.ready().then(function () {
                                        var dbInfo = self._dbInfo;
                                        dbInfo.db.transaction(function (t) {
                                            tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {
                                                var keys = [];

                                                for (var i = 0; i < results.rows.length; i++) {
                                                    keys.push(results.rows.item(i).key);
                                                }

                                                resolve(keys);
                                            }, function (t, error) {
                                                reject(error);
                                            });
                                        });
                                    })["catch"](reject);
                                });

                                executeCallback(promise, callback);
                                return promise;
                            }

// https://www.w3.org/TR/webdatabase/#databases
// > There is no way to enumerate or delete the databases available for an origin from this API.
                            function getAllStoreNames(db) {
                                return new Promise$1(function (resolve, reject) {
                                    db.transaction(function (t) {
                                        t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function (t, results) {
                                            var storeNames = [];

                                            for (var i = 0; i < results.rows.length; i++) {
                                                storeNames.push(results.rows.item(i).name);
                                            }

                                            resolve({
                                                db: db,
                                                storeNames: storeNames
                                            });
                                        }, function (t, error) {
                                            reject(error);
                                        });
                                    }, function (sqlError) {
                                        reject(sqlError);
                                    });
                                });
                            }

                            function dropInstance$1(options, callback) {
                                callback = getCallback.apply(this, arguments);

                                var currentConfig = this.config();
                                options = typeof options !== 'function' && options || {};
                                if (!options.name) {
                                    options.name = options.name || currentConfig.name;
                                    options.storeName = options.storeName || currentConfig.storeName;
                                }

                                var self = this;
                                var promise;
                                if (!options.name) {
                                    promise = Promise$1.reject('Invalid arguments');
                                } else {
                                    promise = new Promise$1(function (resolve) {
                                        var db;
                                        if (options.name === currentConfig.name) {
                                            // use the db reference of the current instance
                                            db = self._dbInfo.db;
                                        } else {
                                            db = openDatabase(options.name, '', '', 0);
                                        }

                                        if (!options.storeName) {
                                            // drop all database tables
                                            resolve(getAllStoreNames(db));
                                        } else {
                                            resolve({
                                                db: db,
                                                storeNames: [options.storeName]
                                            });
                                        }
                                    }).then(function (operationInfo) {
                                        return new Promise$1(function (resolve, reject) {
                                            operationInfo.db.transaction(function (t) {
                                                function dropTable(storeName) {
                                                    return new Promise$1(function (resolve, reject) {
                                                        t.executeSql('DROP TABLE IF EXISTS ' + storeName, [], function () {
                                                            resolve();
                                                        }, function (t, error) {
                                                            reject(error);
                                                        });
                                                    });
                                                }

                                                var operations = [];
                                                for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
                                                    operations.push(dropTable(operationInfo.storeNames[i]));
                                                }

                                                Promise$1.all(operations).then(function () {
                                                    resolve();
                                                })["catch"](function (e) {
                                                    reject(e);
                                                });
                                            }, function (sqlError) {
                                                reject(sqlError);
                                            });
                                        });
                                    });
                                }

                                executeCallback(promise, callback);
                                return promise;
                            }

                            var webSQLStorage = {
                                _driver: 'webSQLStorage',
                                _initStorage: _initStorage$1,
                                _support: isWebSQLValid(),
                                iterate: iterate$1,
                                getItem: getItem$1,
                                setItem: setItem$1,
                                removeItem: removeItem$1,
                                clear: clear$1,
                                length: length$1,
                                key: key$1,
                                keys: keys$1,
                                dropInstance: dropInstance$1
                            };

                            function isLocalStorageValid() {
                                try {
                                    return typeof localStorage !== 'undefined' && 'setItem' in localStorage &&
                                        // in IE8 typeof localStorage.setItem === 'object'
                                        !!localStorage.setItem;
                                } catch (e) {
                                    return false;
                                }
                            }

                            function _getKeyPrefix(options, defaultConfig) {
                                var keyPrefix = options.name + '/';

                                if (options.storeName !== defaultConfig.storeName) {
                                    keyPrefix += options.storeName + '/';
                                }
                                return keyPrefix;
                            }

// Check if localStorage throws when saving an item
                            function checkIfLocalStorageThrows() {
                                var localStorageTestKey = '_localforage_support_test';

                                try {
                                    localStorage.setItem(localStorageTestKey, true);
                                    localStorage.removeItem(localStorageTestKey);

                                    return false;
                                } catch (e) {
                                    return true;
                                }
                            }

// Check if localStorage is usable and allows to save an item
// This method checks if localStorage is usable in Safari Private Browsing
// mode, or in any other case where the available quota for localStorage
// is 0 and there wasn't any saved items yet.
                            function _isLocalStorageUsable() {
                                return !checkIfLocalStorageThrows() || localStorage.length > 0;
                            }

// Config the localStorage backend, using options set in the config.
                            function _initStorage$2(options) {
                                var self = this;
                                var dbInfo = {};
                                if (options) {
                                    for (var i in options) {
                                        dbInfo[i] = options[i];
                                    }
                                }

                                dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);

                                if (!_isLocalStorageUsable()) {
                                    return Promise$1.reject();
                                }

                                self._dbInfo = dbInfo;
                                dbInfo.serializer = localforageSerializer;

                                return Promise$1.resolve();
                            }

// Remove all keys from the datastore, effectively destroying all data in
// the app's key/value store!
                            function clear$2(callback) {
                                var self = this;
                                var promise = self.ready().then(function () {
                                    var keyPrefix = self._dbInfo.keyPrefix;

                                    for (var i = localStorage.length - 1; i >= 0; i--) {
                                        var key = localStorage.key(i);

                                        if (key.indexOf(keyPrefix) === 0) {
                                            localStorage.removeItem(key);
                                        }
                                    }
                                });

                                executeCallback(promise, callback);
                                return promise;
                            }

// Retrieve an item from the store. Unlike the original async_storage
// library in Gaia, we don't modify return values at all. If a key's value
// is `undefined`, we pass that value to the callback function.
                            function getItem$2(key, callback) {
                                var self = this;

                                key = normalizeKey(key);

                                var promise = self.ready().then(function () {
                                    var dbInfo = self._dbInfo;
                                    var result = localStorage.getItem(dbInfo.keyPrefix + key);

                                    // If a result was found, parse it from the serialized
                                    // string into a JS object. If result isn't truthy, the key
                                    // is likely undefined and we'll pass it straight to the
                                    // callback.
                                    if (result) {
                                        result = dbInfo.serializer.deserialize(result);
                                    }

                                    return result;
                                });

                                executeCallback(promise, callback);
                                return promise;
                            }

// Iterate over all items in the store.
                            function iterate$2(iterator, callback) {
                                var self = this;

                                var promise = self.ready().then(function () {
                                    var dbInfo = self._dbInfo;
                                    var keyPrefix = dbInfo.keyPrefix;
                                    var keyPrefixLength = keyPrefix.length;
                                    var length = localStorage.length;

                                    // We use a dedicated iterator instead of the `i` variable below
                                    // so other keys we fetch in localStorage aren't counted in
                                    // the `iterationNumber` argument passed to the `iterate()`
                                    // callback.
                                    //
                                    // See: github.com/mozilla/localForage/pull/435#discussion_r38061530
                                    var iterationNumber = 1;

                                    for (var i = 0; i < length; i++) {
                                        var key = localStorage.key(i);
                                        if (key.indexOf(keyPrefix) !== 0) {
                                            continue;
                                        }
                                        var value = localStorage.getItem(key);

                                        // If a result was found, parse it from the serialized
                                        // string into a JS object. If result isn't truthy, the
                                        // key is likely undefined and we'll pass it straight
                                        // to the iterator.
                                        if (value) {
                                            value = dbInfo.serializer.deserialize(value);
                                        }

                                        value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);

                                        if (value !== void 0) {
                                            return value;
                                        }
                                    }
                                });

                                executeCallback(promise, callback);
                                return promise;
                            }

// Same as localStorage's key() method, except takes a callback.
                            function key$2(n, callback) {
                                var self = this;
                                var promise = self.ready().then(function () {
                                    var dbInfo = self._dbInfo;
                                    var result;
                                    try {
                                        result = localStorage.key(n);
                                    } catch (error) {
                                        result = null;
                                    }

                                    // Remove the prefix from the key, if a key is found.
                                    if (result) {
                                        result = result.substring(dbInfo.keyPrefix.length);
                                    }

                                    return result;
                                });

                                executeCallback(promise, callback);
                                return promise;
                            }

                            function keys$2(callback) {
                                var self = this;
                                var promise = self.ready().then(function () {
                                    var dbInfo = self._dbInfo;
                                    var length = localStorage.length;
                                    var keys = [];

                                    for (var i = 0; i < length; i++) {
                                        var itemKey = localStorage.key(i);
                                        if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
                                            keys.push(itemKey.substring(dbInfo.keyPrefix.length));
                                        }
                                    }

                                    return keys;
                                });

                                executeCallback(promise, callback);
                                return promise;
                            }

// Supply the number of keys in the datastore to the callback function.
                            function length$2(callback) {
                                var self = this;
                                var promise = self.keys().then(function (keys) {
                                    return keys.length;
                                });

                                executeCallback(promise, callback);
                                return promise;
                            }

// Remove an item from the store, nice and simple.
                            function removeItem$2(key, callback) {
                                var self = this;

                                key = normalizeKey(key);

                                var promise = self.ready().then(function () {
                                    var dbInfo = self._dbInfo;
                                    localStorage.removeItem(dbInfo.keyPrefix + key);
                                });

                                executeCallback(promise, callback);
                                return promise;
                            }

// Set a key's value and run an optional callback once the value is set.
// Unlike Gaia's implementation, the callback function is passed the value,
// in case you want to operate on that value only after you're sure it
// saved, or something like that.
                            function setItem$2(key, value, callback) {
                                var self = this;

                                key = normalizeKey(key);

                                var promise = self.ready().then(function () {
                                    // Convert undefined values to null.
                                    // https://github.com/mozilla/localForage/pull/42
                                    if (value === undefined) {
                                        value = null;
                                    }

                                    // Save the original value to pass to the callback.
                                    var originalValue = value;

                                    return new Promise$1(function (resolve, reject) {
                                        var dbInfo = self._dbInfo;
                                        dbInfo.serializer.serialize(value, function (value, error) {
                                            if (error) {
                                                reject(error);
                                            } else {
                                                try {
                                                    localStorage.setItem(dbInfo.keyPrefix + key, value);
                                                    resolve(originalValue);
                                                } catch (e) {
                                                    // localStorage capacity exceeded.
                                                    // TODO: Make this a specific error/event.
                                                    if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                                                        reject(e);
                                                    }
                                                    reject(e);
                                                }
                                            }
                                        });
                                    });
                                });

                                executeCallback(promise, callback);
                                return promise;
                            }

                            function dropInstance$2(options, callback) {
                                callback = getCallback.apply(this, arguments);

                                options = typeof options !== 'function' && options || {};
                                if (!options.name) {
                                    var currentConfig = this.config();
                                    options.name = options.name || currentConfig.name;
                                    options.storeName = options.storeName || currentConfig.storeName;
                                }

                                var self = this;
                                var promise;
                                if (!options.name) {
                                    promise = Promise$1.reject('Invalid arguments');
                                } else {
                                    promise = new Promise$1(function (resolve) {
                                        if (!options.storeName) {
                                            resolve(options.name + '/');
                                        } else {
                                            resolve(_getKeyPrefix(options, self._defaultConfig));
                                        }
                                    }).then(function (keyPrefix) {
                                        for (var i = localStorage.length - 1; i >= 0; i--) {
                                            var key = localStorage.key(i);

                                            if (key.indexOf(keyPrefix) === 0) {
                                                localStorage.removeItem(key);
                                            }
                                        }
                                    });
                                }

                                executeCallback(promise, callback);
                                return promise;
                            }

                            var localStorageWrapper = {
                                _driver: 'localStorageWrapper',
                                _initStorage: _initStorage$2,
                                _support: isLocalStorageValid(),
                                iterate: iterate$2,
                                getItem: getItem$2,
                                setItem: setItem$2,
                                removeItem: removeItem$2,
                                clear: clear$2,
                                length: length$2,
                                key: key$2,
                                keys: keys$2,
                                dropInstance: dropInstance$2
                            };

                            var sameValue = function sameValue(x, y) {
                                return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);
                            };

                            var includes = function includes(array, searchElement) {
                                var len = array.length;
                                var i = 0;
                                while (i < len) {
                                    if (sameValue(array[i], searchElement)) {
                                        return true;
                                    }
                                    i++;
                                }

                                return false;
                            };

                            var isArray = Array.isArray || function (arg) {
                                return Object.prototype.toString.call(arg) === '[object Array]';
                            };

// Drivers are stored here when `defineDriver()` is called.
// They are shared across all instances of localForage.
                            var DefinedDrivers = {};

                            var DriverSupport = {};

                            var DefaultDrivers = {
                                INDEXEDDB: asyncStorage,
                                WEBSQL: webSQLStorage,
                                LOCALSTORAGE: localStorageWrapper
                            };

                            var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];

                            var OptionalDriverMethods = ['dropInstance'];

                            var LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'].concat(OptionalDriverMethods);

                            var DefaultConfig = {
                                description: '',
                                driver: DefaultDriverOrder.slice(),
                                name: 'localforage',
                                // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
                                // we can use without a prompt.
                                size: 4980736,
                                storeName: 'keyvaluepairs',
                                version: 1.0
                            };

                            function callWhenReady(localForageInstance, libraryMethod) {
                                localForageInstance[libraryMethod] = function () {
                                    var _args = arguments;
                                    return localForageInstance.ready().then(function () {
                                        return localForageInstance[libraryMethod].apply(localForageInstance, _args);
                                    });
                                };
                            }

                            function extend() {
                                for (var i = 1; i < arguments.length; i++) {
                                    var arg = arguments[i];

                                    if (arg) {
                                        for (var _key in arg) {
                                            if (arg.hasOwnProperty(_key)) {
                                                if (isArray(arg[_key])) {
                                                    arguments[0][_key] = arg[_key].slice();
                                                } else {
                                                    arguments[0][_key] = arg[_key];
                                                }
                                            }
                                        }
                                    }
                                }

                                return arguments[0];
                            }

                            var LocalForage = function () {
                                function LocalForage(options) {
                                    _classCallCheck(this, LocalForage);

                                    for (var driverTypeKey in DefaultDrivers) {
                                        if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
                                            var driver = DefaultDrivers[driverTypeKey];
                                            var driverName = driver._driver;
                                            this[driverTypeKey] = driverName;

                                            if (!DefinedDrivers[driverName]) {
                                                // we don't need to wait for the promise,
                                                // since the default drivers can be defined
                                                // in a blocking manner
                                                this.defineDriver(driver);
                                            }
                                        }
                                    }

                                    this._defaultConfig = extend({}, DefaultConfig);
                                    this._config = extend({}, this._defaultConfig, options);
                                    this._driverSet = null;
                                    this._initDriver = null;
                                    this._ready = false;
                                    this._dbInfo = null;

                                    this._wrapLibraryMethodsWithReady();
                                    this.setDriver(this._config.driver)["catch"](function () {
                                    });
                                }

                                // Set any config values for localForage; can be called anytime before
                                // the first API call (e.g. `getItem`, `setItem`).
                                // We loop through options so we don't overwrite existing config
                                // values.


                                LocalForage.prototype.config = function config(options) {
                                    // If the options argument is an object, we use it to set values.
                                    // Otherwise, we return either a specified config value or all
                                    // config values.
                                    if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
                                        // If localforage is ready and fully initialized, we can't set
                                        // any new configuration values. Instead, we return an error.
                                        if (this._ready) {
                                            return new Error("Can't call config() after localforage " + 'has been used.');
                                        }

                                        for (var i in options) {
                                            if (i === 'storeName') {
                                                options[i] = options[i].replace(/\W/g, '_');
                                            }

                                            if (i === 'version' && typeof options[i] !== 'number') {
                                                return new Error('Database version must be a number.');
                                            }

                                            this._config[i] = options[i];
                                        }

                                        // after all config options are set and
                                        // the driver option is used, try setting it
                                        if ('driver' in options && options.driver) {
                                            return this.setDriver(this._config.driver);
                                        }

                                        return true;
                                    } else if (typeof options === 'string') {
                                        return this._config[options];
                                    } else {
                                        return this._config;
                                    }
                                };

                                // Used to define a custom driver, shared across all instances of
                                // localForage.


                                LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
                                    var promise = new Promise$1(function (resolve, reject) {
                                        try {
                                            var driverName = driverObject._driver;
                                            var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');

                                            // A driver name should be defined and not overlap with the
                                            // library-defined, default drivers.
                                            if (!driverObject._driver) {
                                                reject(complianceError);
                                                return;
                                            }

                                            var driverMethods = LibraryMethods.concat('_initStorage');
                                            for (var i = 0, len = driverMethods.length; i < len; i++) {
                                                var driverMethodName = driverMethods[i];

                                                // when the property is there,
                                                // it should be a method even when optional
                                                var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                                                if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== 'function') {
                                                    reject(complianceError);
                                                    return;
                                                }
                                            }

                                            var configureMissingMethods = function configureMissingMethods() {
                                                var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {
                                                    return function () {
                                                        var error = new Error('Method ' + methodName + ' is not implemented by the current driver');
                                                        var promise = Promise$1.reject(error);
                                                        executeCallback(promise, arguments[arguments.length - 1]);
                                                        return promise;
                                                    };
                                                };

                                                for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                                                    var optionalDriverMethod = OptionalDriverMethods[_i];
                                                    if (!driverObject[optionalDriverMethod]) {
                                                        driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                                                    }
                                                }
                                            };

                                            configureMissingMethods();

                                            var setDriverSupport = function setDriverSupport(support) {
                                                if (DefinedDrivers[driverName]) {
                                                    console.info('Redefining LocalForage driver: ' + driverName);
                                                }
                                                DefinedDrivers[driverName] = driverObject;
                                                DriverSupport[driverName] = support;
                                                // don't use a then, so that we can define
                                                // drivers that have simple _support methods
                                                // in a blocking manner
                                                resolve();
                                            };

                                            if ('_support' in driverObject) {
                                                if (driverObject._support && typeof driverObject._support === 'function') {
                                                    driverObject._support().then(setDriverSupport, reject);
                                                } else {
                                                    setDriverSupport(!!driverObject._support);
                                                }
                                            } else {
                                                setDriverSupport(true);
                                            }
                                        } catch (e) {
                                            reject(e);
                                        }
                                    });

                                    executeTwoCallbacks(promise, callback, errorCallback);
                                    return promise;
                                };

                                LocalForage.prototype.driver = function driver() {
                                    return this._driver || null;
                                };

                                LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
                                    var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));

                                    executeTwoCallbacks(getDriverPromise, callback, errorCallback);
                                    return getDriverPromise;
                                };

                                LocalForage.prototype.getSerializer = function getSerializer(callback) {
                                    var serializerPromise = Promise$1.resolve(localforageSerializer);
                                    executeTwoCallbacks(serializerPromise, callback);
                                    return serializerPromise;
                                };

                                LocalForage.prototype.ready = function ready(callback) {
                                    var self = this;

                                    var promise = self._driverSet.then(function () {
                                        if (self._ready === null) {
                                            self._ready = self._initDriver();
                                        }

                                        return self._ready;
                                    });

                                    executeTwoCallbacks(promise, callback, callback);
                                    return promise;
                                };

                                LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
                                    var self = this;

                                    if (!isArray(drivers)) {
                                        drivers = [drivers];
                                    }

                                    var supportedDrivers = this._getSupportedDrivers(drivers);

                                    function setDriverToConfig() {
                                        self._config.driver = self.driver();
                                    }

                                    function extendSelfWithDriver(driver) {
                                        self._extend(driver);
                                        setDriverToConfig();

                                        self._ready = self._initStorage(self._config);
                                        return self._ready;
                                    }

                                    function initDriver(supportedDrivers) {
                                        return function () {
                                            var currentDriverIndex = 0;

                                            function driverPromiseLoop() {
                                                while (currentDriverIndex < supportedDrivers.length) {
                                                    var driverName = supportedDrivers[currentDriverIndex];
                                                    currentDriverIndex++;

                                                    self._dbInfo = null;
                                                    self._ready = null;

                                                    return self.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                                                }

                                                setDriverToConfig();
                                                var error = new Error('No available storage method found.');
                                                self._driverSet = Promise$1.reject(error);
                                                return self._driverSet;
                                            }

                                            return driverPromiseLoop();
                                        };
                                    }

                                    // There might be a driver initialization in progress
                                    // so wait for it to finish in order to avoid a possible
                                    // race condition to set _dbInfo
                                    var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function () {
                                        return Promise$1.resolve();
                                    }) : Promise$1.resolve();

                                    this._driverSet = oldDriverSetDone.then(function () {
                                        var driverName = supportedDrivers[0];
                                        self._dbInfo = null;
                                        self._ready = null;

                                        return self.getDriver(driverName).then(function (driver) {
                                            self._driver = driver._driver;
                                            setDriverToConfig();
                                            self._wrapLibraryMethodsWithReady();
                                            self._initDriver = initDriver(supportedDrivers);
                                        });
                                    })["catch"](function () {
                                        setDriverToConfig();
                                        var error = new Error('No available storage method found.');
                                        self._driverSet = Promise$1.reject(error);
                                        return self._driverSet;
                                    });

                                    executeTwoCallbacks(this._driverSet, callback, errorCallback);
                                    return this._driverSet;
                                };

                                LocalForage.prototype.supports = function supports(driverName) {
                                    return !!DriverSupport[driverName];
                                };

                                LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {
                                    extend(this, libraryMethodsAndProperties);
                                };

                                LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
                                    var supportedDrivers = [];
                                    for (var i = 0, len = drivers.length; i < len; i++) {
                                        var driverName = drivers[i];
                                        if (this.supports(driverName)) {
                                            supportedDrivers.push(driverName);
                                        }
                                    }
                                    return supportedDrivers;
                                };

                                LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
                                    // Add a stub for each driver API method that delays the call to the
                                    // corresponding driver method until localForage is ready. These stubs
                                    // will be replaced by the driver methods as soon as the driver is
                                    // loaded, so there is no performance impact.
                                    for (var i = 0, len = LibraryMethods.length; i < len; i++) {
                                        callWhenReady(this, LibraryMethods[i]);
                                    }
                                };

                                LocalForage.prototype.createInstance = function createInstance(options) {
                                    return new LocalForage(options);
                                };

                                return LocalForage;
                            }();

// The actual localForage object that we expose as a module or via a
// global. It's extended by pulling in one of our other libraries.


                            var localforage_js = new LocalForage();

                            module.exports = localforage_js;

                        }, {"3": 3}]
                    }, {}, [4])(4)
                });

            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
        }, {}], 12: [function (require, module, exports) {
            (function (global) {
                /**!
                 * @fileOverview Kickass library to create and place poppers near their reference elements.
                 * @version 1.14.3
                 * @license
                 * Copyright (c) 2016 Federico Zivolo and contributors
                 *
                 * Permission is hereby granted, free of charge, to any person obtaining a copy
                 * of this software and associated documentation files (the "Software"), to deal
                 * in the Software without restriction, including without limitation the rights
                 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                 * copies of the Software, and to permit persons to whom the Software is
                 * furnished to do so, subject to the following conditions:
                 *
                 * The above copyright notice and this permission notice shall be included in all
                 * copies or substantial portions of the Software.
                 *
                 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                 * SOFTWARE.
                 */
                (function (global, factory) {
                    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
                        typeof define === 'function' && define.amd ? define(factory) :
                            (global.Popper = factory());
                }(this, (function () {
                    'use strict';

                    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';

                    var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
                    var timeoutDuration = 0;
                    for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
                        if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
                            timeoutDuration = 1;
                            break;
                        }
                    }

                    function microtaskDebounce(fn) {
                        var called = false;
                        return function () {
                            if (called) {
                                return;
                            }
                            called = true;
                            window.Promise.resolve().then(function () {
                                called = false;
                                fn();
                            });
                        };
                    }

                    function taskDebounce(fn) {
                        var scheduled = false;
                        return function () {
                            if (!scheduled) {
                                scheduled = true;
                                setTimeout(function () {
                                    scheduled = false;
                                    fn();
                                }, timeoutDuration);
                            }
                        };
                    }

                    var supportsMicroTasks = isBrowser && window.Promise;

                    /**
                     * Create a debounced version of a method, that's asynchronously deferred
                     * but called in the minimum time possible.
                     *
                     * @method
                     * @memberof Popper.Utils
                     * @argument {Function} fn
                     * @returns {Function}
                     */
                    var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

                    /**
                     * Check if the given variable is a function
                     * @method
                     * @memberof Popper.Utils
                     * @argument {Any} functionToCheck - variable to check
                     * @returns {Boolean} answer to: is a function?
                     */
                    function isFunction(functionToCheck) {
                        var getType = {};
                        return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
                    }

                    /**
                     * Get CSS computed property of the given element
                     * @method
                     * @memberof Popper.Utils
                     * @argument {Eement} element
                     * @argument {String} property
                     */
                    function getStyleComputedProperty(element, property) {
                        if (element.nodeType !== 1) {
                            return [];
                        }
                        // NOTE: 1 DOM access here
                        var css = getComputedStyle(element, null);
                        return property ? css[property] : css;
                    }

                    /**
                     * Returns the parentNode or the host of the element
                     * @method
                     * @memberof Popper.Utils
                     * @argument {Element} element
                     * @returns {Element} parent
                     */
                    function getParentNode(element) {
                        if (element.nodeName === 'HTML') {
                            return element;
                        }
                        return element.parentNode || element.host;
                    }

                    /**
                     * Returns the scrolling parent of the given element
                     * @method
                     * @memberof Popper.Utils
                     * @argument {Element} element
                     * @returns {Element} scroll parent
                     */
                    function getScrollParent(element) {
                        // Return body, `getScroll` will take care to get the correct `scrollTop` from it
                        if (!element) {
                            return document.body;
                        }

                        switch (element.nodeName) {
                            case 'HTML':
                            case 'BODY':
                                return element.ownerDocument.body;
                            case '#document':
                                return element.body;
                        }

                        // Firefox want us to check `-x` and `-y` variations as well

                        var _getStyleComputedProp = getStyleComputedProperty(element),
                            overflow = _getStyleComputedProp.overflow,
                            overflowX = _getStyleComputedProp.overflowX,
                            overflowY = _getStyleComputedProp.overflowY;

                        if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
                            return element;
                        }

                        return getScrollParent(getParentNode(element));
                    }

                    var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
                    var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

                    /**
                     * Determines if the browser is Internet Explorer
                     * @method
                     * @memberof Popper.Utils
                     * @param {Number} version to check
                     * @returns {Boolean} isIE
                     */
                    function isIE(version) {
                        if (version === 11) {
                            return isIE11;
                        }
                        if (version === 10) {
                            return isIE10;
                        }
                        return isIE11 || isIE10;
                    }

                    /**
                     * Returns the offset parent of the given element
                     * @method
                     * @memberof Popper.Utils
                     * @argument {Element} element
                     * @returns {Element} offset parent
                     */
                    function getOffsetParent(element) {
                        if (!element) {
                            return document.documentElement;
                        }

                        var noOffsetParent = isIE(10) ? document.body : null;

                        // NOTE: 1 DOM access here
                        var offsetParent = element.offsetParent;
                        // Skip hidden elements which don't have an offsetParent
                        while (offsetParent === noOffsetParent && element.nextElementSibling) {
                            offsetParent = (element = element.nextElementSibling).offsetParent;
                        }

                        var nodeName = offsetParent && offsetParent.nodeName;

                        if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
                            return element ? element.ownerDocument.documentElement : document.documentElement;
                        }

                        // .offsetParent will return the closest TD or TABLE in case
                        // no offsetParent is present, I hate this job...
                        if (['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
                            return getOffsetParent(offsetParent);
                        }

                        return offsetParent;
                    }

                    function isOffsetContainer(element) {
                        var nodeName = element.nodeName;

                        if (nodeName === 'BODY') {
                            return false;
                        }
                        return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
                    }

                    /**
                     * Finds the root node (document, shadowDOM root) of the given element
                     * @method
                     * @memberof Popper.Utils
                     * @argument {Element} node
                     * @returns {Element} root node
                     */
                    function getRoot(node) {
                        if (node.parentNode !== null) {
                            return getRoot(node.parentNode);
                        }

                        return node;
                    }

                    /**
                     * Finds the offset parent common to the two provided nodes
                     * @method
                     * @memberof Popper.Utils
                     * @argument {Element} element1
                     * @argument {Element} element2
                     * @returns {Element} common offset parent
                     */
                    function findCommonOffsetParent(element1, element2) {
                        // This check is needed to avoid errors in case one of the elements isn't defined for any reason
                        if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
                            return document.documentElement;
                        }

                        // Here we make sure to give as "start" the element that comes first in the DOM
                        var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
                        var start = order ? element1 : element2;
                        var end = order ? element2 : element1;

                        // Get common ancestor container
                        var range = document.createRange();
                        range.setStart(start, 0);
                        range.setEnd(end, 0);
                        var commonAncestorContainer = range.commonAncestorContainer;

                        // Both nodes are inside #document

                        if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
                            if (isOffsetContainer(commonAncestorContainer)) {
                                return commonAncestorContainer;
                            }

                            return getOffsetParent(commonAncestorContainer);
                        }

                        // one of the nodes is inside shadowDOM, find which one
                        var element1root = getRoot(element1);
                        if (element1root.host) {
                            return findCommonOffsetParent(element1root.host, element2);
                        } else {
                            return findCommonOffsetParent(element1, getRoot(element2).host);
                        }
                    }

                    /**
                     * Gets the scroll value of the given element in the given side (top and left)
                     * @method
                     * @memberof Popper.Utils
                     * @argument {Element} element
                     * @argument {String} side `top` or `left`
                     * @returns {number} amount of scrolled pixels
                     */
                    function getScroll(element) {
                        var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

                        var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
                        var nodeName = element.nodeName;

                        if (nodeName === 'BODY' || nodeName === 'HTML') {
                            var html = element.ownerDocument.documentElement;
                            var scrollingElement = element.ownerDocument.scrollingElement || html;
                            return scrollingElement[upperSide];
                        }

                        return element[upperSide];
                    }

                    /*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
                    function includeScroll(rect, element) {
                        var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

                        var scrollTop = getScroll(element, 'top');
                        var scrollLeft = getScroll(element, 'left');
                        var modifier = subtract ? -1 : 1;
                        rect.top += scrollTop * modifier;
                        rect.bottom += scrollTop * modifier;
                        rect.left += scrollLeft * modifier;
                        rect.right += scrollLeft * modifier;
                        return rect;
                    }

                    /*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

                    function getBordersSize(styles, axis) {
                        var sideA = axis === 'x' ? 'Left' : 'Top';
                        var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

                        return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
                    }

                    function getSize(axis, body, html, computedStyle) {
                        return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);
                    }

                    function getWindowSizes() {
                        var body = document.body;
                        var html = document.documentElement;
                        var computedStyle = isIE(10) && getComputedStyle(html);

                        return {
                            height: getSize('Height', body, html, computedStyle),
                            width: getSize('Width', body, html, computedStyle)
                        };
                    }

                    var classCallCheck = function (instance, Constructor) {
                        if (!(instance instanceof Constructor)) {
                            throw new TypeError("Cannot call a class as a function");
                        }
                    };

                    var createClass = function () {
                        function defineProperties(target, props) {
                            for (var i = 0; i < props.length; i++) {
                                var descriptor = props[i];
                                descriptor.enumerable = descriptor.enumerable || false;
                                descriptor.configurable = true;
                                if ("value" in descriptor) descriptor.writable = true;
                                Object.defineProperty(target, descriptor.key, descriptor);
                            }
                        }

                        return function (Constructor, protoProps, staticProps) {
                            if (protoProps) defineProperties(Constructor.prototype, protoProps);
                            if (staticProps) defineProperties(Constructor, staticProps);
                            return Constructor;
                        };
                    }();


                    var defineProperty = function (obj, key, value) {
                        if (key in obj) {
                            Object.defineProperty(obj, key, {
                                value: value,
                                enumerable: true,
                                configurable: true,
                                writable: true
                            });
                        } else {
                            obj[key] = value;
                        }

                        return obj;
                    };

                    var _extends = Object.assign || function (target) {
                        for (var i = 1; i < arguments.length; i++) {
                            var source = arguments[i];

                            for (var key in source) {
                                if (Object.prototype.hasOwnProperty.call(source, key)) {
                                    target[key] = source[key];
                                }
                            }
                        }

                        return target;
                    };

                    /**
                     * Given element offsets, generate an output similar to getBoundingClientRect
                     * @method
                     * @memberof Popper.Utils
                     * @argument {Object} offsets
                     * @returns {Object} ClientRect like output
                     */
                    function getClientRect(offsets) {
                        return _extends({}, offsets, {
                            right: offsets.left + offsets.width,
                            bottom: offsets.top + offsets.height
                        });
                    }

                    /**
                     * Get bounding client rect of given element
                     * @method
                     * @memberof Popper.Utils
                     * @param {HTMLElement} element
                     * @return {Object} client rect
                     */
                    function getBoundingClientRect(element) {
                        var rect = {};

                        // IE10 10 FIX: Please, don't ask, the element isn't
                        // considered in DOM in some circumstances...
                        // This isn't reproducible in IE10 compatibility mode of IE11
                        try {
                            if (isIE(10)) {
                                rect = element.getBoundingClientRect();
                                var scrollTop = getScroll(element, 'top');
                                var scrollLeft = getScroll(element, 'left');
                                rect.top += scrollTop;
                                rect.left += scrollLeft;
                                rect.bottom += scrollTop;
                                rect.right += scrollLeft;
                            } else {
                                rect = element.getBoundingClientRect();
                            }
                        } catch (e) {
                        }

                        var result = {
                            left: rect.left,
                            top: rect.top,
                            width: rect.right - rect.left,
                            height: rect.bottom - rect.top
                        };

                        // subtract scrollbar size from sizes
                        var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};
                        var width = sizes.width || element.clientWidth || result.right - result.left;
                        var height = sizes.height || element.clientHeight || result.bottom - result.top;

                        var horizScrollbar = element.offsetWidth - width;
                        var vertScrollbar = element.offsetHeight - height;

                        // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
                        // we make this check conditional for performance reasons
                        if (horizScrollbar || vertScrollbar) {
                            var styles = getStyleComputedProperty(element);
                            horizScrollbar -= getBordersSize(styles, 'x');
                            vertScrollbar -= getBordersSize(styles, 'y');

                            result.width -= horizScrollbar;
                            result.height -= vertScrollbar;
                        }

                        return getClientRect(result);
                    }

                    function getOffsetRectRelativeToArbitraryNode(children, parent) {
                        var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

                        var isIE10 = isIE(10);
                        var isHTML = parent.nodeName === 'HTML';
                        var childrenRect = getBoundingClientRect(children);
                        var parentRect = getBoundingClientRect(parent);
                        var scrollParent = getScrollParent(children);

                        var styles = getStyleComputedProperty(parent);
                        var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
                        var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

                        // In cases where the parent is fixed, we must ignore negative scroll in offset calc
                        if (fixedPosition && parent.nodeName === 'HTML') {
                            parentRect.top = Math.max(parentRect.top, 0);
                            parentRect.left = Math.max(parentRect.left, 0);
                        }
                        var offsets = getClientRect({
                            top: childrenRect.top - parentRect.top - borderTopWidth,
                            left: childrenRect.left - parentRect.left - borderLeftWidth,
                            width: childrenRect.width,
                            height: childrenRect.height
                        });
                        offsets.marginTop = 0;
                        offsets.marginLeft = 0;

                        // Subtract margins of documentElement in case it's being used as parent
                        // we do this only on HTML because it's the only element that behaves
                        // differently when margins are applied to it. The margins are included in
                        // the box of the documentElement, in the other cases not.
                        if (!isIE10 && isHTML) {
                            var marginTop = parseFloat(styles.marginTop, 10);
                            var marginLeft = parseFloat(styles.marginLeft, 10);

                            offsets.top -= borderTopWidth - marginTop;
                            offsets.bottom -= borderTopWidth - marginTop;
                            offsets.left -= borderLeftWidth - marginLeft;
                            offsets.right -= borderLeftWidth - marginLeft;

                            // Attach marginTop and marginLeft because in some circumstances we may need them
                            offsets.marginTop = marginTop;
                            offsets.marginLeft = marginLeft;
                        }

                        if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
                            offsets = includeScroll(offsets, parent);
                        }

                        return offsets;
                    }

                    function getViewportOffsetRectRelativeToArtbitraryNode(element) {
                        var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

                        var html = element.ownerDocument.documentElement;
                        var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
                        var width = Math.max(html.clientWidth, window.innerWidth || 0);
                        var height = Math.max(html.clientHeight, window.innerHeight || 0);

                        var scrollTop = !excludeScroll ? getScroll(html) : 0;
                        var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

                        var offset = {
                            top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
                            left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
                            width: width,
                            height: height
                        };

                        return getClientRect(offset);
                    }

                    /**
                     * Check if the given element is fixed or is inside a fixed parent
                     * @method
                     * @memberof Popper.Utils
                     * @argument {Element} element
                     * @argument {Element} customContainer
                     * @returns {Boolean} answer to "isFixed?"
                     */
                    function isFixed(element) {
                        var nodeName = element.nodeName;
                        if (nodeName === 'BODY' || nodeName === 'HTML') {
                            return false;
                        }
                        if (getStyleComputedProperty(element, 'position') === 'fixed') {
                            return true;
                        }
                        return isFixed(getParentNode(element));
                    }

                    /**
                     * Finds the first parent of an element that has a transformed property defined
                     * @method
                     * @memberof Popper.Utils
                     * @argument {Element} element
                     * @returns {Element} first transformed parent or documentElement
                     */

                    function getFixedPositionOffsetParent(element) {
                        // This check is needed to avoid errors in case one of the elements isn't defined for any reason
                        if (!element || !element.parentElement || isIE()) {
                            return document.documentElement;
                        }
                        var el = element.parentElement;
                        while (el && getStyleComputedProperty(el, 'transform') === 'none') {
                            el = el.parentElement;
                        }
                        return el || document.documentElement;
                    }

                    /**
                     * Computed the boundaries limits and return them
                     * @method
                     * @memberof Popper.Utils
                     * @param {HTMLElement} popper
                     * @param {HTMLElement} reference
                     * @param {number} padding
                     * @param {HTMLElement} boundariesElement - Element used to define the boundaries
                     * @param {Boolean} fixedPosition - Is in fixed position mode
                     * @returns {Object} Coordinates of the boundaries
                     */
                    function getBoundaries(popper, reference, padding, boundariesElement) {
                        var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

                        // NOTE: 1 DOM access here

                        var boundaries = {top: 0, left: 0};
                        var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);

                        // Handle viewport case
                        if (boundariesElement === 'viewport') {
                            boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
                        } else {
                            // Handle other cases based on DOM element used as boundaries
                            var boundariesNode = void 0;
                            if (boundariesElement === 'scrollParent') {
                                boundariesNode = getScrollParent(getParentNode(reference));
                                if (boundariesNode.nodeName === 'BODY') {
                                    boundariesNode = popper.ownerDocument.documentElement;
                                }
                            } else if (boundariesElement === 'window') {
                                boundariesNode = popper.ownerDocument.documentElement;
                            } else {
                                boundariesNode = boundariesElement;
                            }

                            var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

                            // In case of HTML, we need a different computation
                            if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
                                var _getWindowSizes = getWindowSizes(),
                                    height = _getWindowSizes.height,
                                    width = _getWindowSizes.width;

                                boundaries.top += offsets.top - offsets.marginTop;
                                boundaries.bottom = height + offsets.top;
                                boundaries.left += offsets.left - offsets.marginLeft;
                                boundaries.right = width + offsets.left;
                            } else {
                                // for all the other DOM elements, this one is good
                                boundaries = offsets;
                            }
                        }

                        // Add paddings
                        boundaries.left += padding;
                        boundaries.top += padding;
                        boundaries.right -= padding;
                        boundaries.bottom -= padding;

                        return boundaries;
                    }

                    function getArea(_ref) {
                        var width = _ref.width,
                            height = _ref.height;

                        return width * height;
                    }

                    /**
                     * Utility used to transform the `auto` placement to the placement with more
                     * available space.
                     * @method
                     * @memberof Popper.Utils
                     * @argument {Object} data - The data object generated by update method
                     * @argument {Object} options - Modifiers configuration and options
                     * @returns {Object} The data object, properly modified
                     */
                    function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
                        var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

                        if (placement.indexOf('auto') === -1) {
                            return placement;
                        }

                        var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

                        var rects = {
                            top: {
                                width: boundaries.width,
                                height: refRect.top - boundaries.top
                            },
                            right: {
                                width: boundaries.right - refRect.right,
                                height: boundaries.height
                            },
                            bottom: {
                                width: boundaries.width,
                                height: boundaries.bottom - refRect.bottom
                            },
                            left: {
                                width: refRect.left - boundaries.left,
                                height: boundaries.height
                            }
                        };

                        var sortedAreas = Object.keys(rects).map(function (key) {
                            return _extends({
                                key: key
                            }, rects[key], {
                                area: getArea(rects[key])
                            });
                        }).sort(function (a, b) {
                            return b.area - a.area;
                        });

                        var filteredAreas = sortedAreas.filter(function (_ref2) {
                            var width = _ref2.width,
                                height = _ref2.height;
                            return width >= popper.clientWidth && height >= popper.clientHeight;
                        });

                        var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

                        var variation = placement.split('-')[1];

                        return computedPlacement + (variation ? '-' + variation : '');
                    }

                    /**
                     * Get offsets to the reference element
                     * @method
                     * @memberof Popper.Utils
                     * @param {Object} state
                     * @param {Element} popper - the popper element
                     * @param {Element} reference - the reference element (the popper will be relative to this)
                     * @param {Element} fixedPosition - is in fixed position mode
                     * @returns {Object} An object containing the offsets which will be applied to the popper
                     */
                    function getReferenceOffsets(state, popper, reference) {
                        var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

                        var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
                        return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
                    }

                    /**
                     * Get the outer sizes of the given element (offset size + margins)
                     * @method
                     * @memberof Popper.Utils
                     * @argument {Element} element
                     * @returns {Object} object containing width and height properties
                     */
                    function getOuterSizes(element) {
                        var styles = getComputedStyle(element);
                        var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
                        var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
                        var result = {
                            width: element.offsetWidth + y,
                            height: element.offsetHeight + x
                        };
                        return result;
                    }

                    /**
                     * Get the opposite placement of the given one
                     * @method
                     * @memberof Popper.Utils
                     * @argument {String} placement
                     * @returns {String} flipped placement
                     */
                    function getOppositePlacement(placement) {
                        var hash = {left: 'right', right: 'left', bottom: 'top', top: 'bottom'};
                        return placement.replace(/left|right|bottom|top/g, function (matched) {
                            return hash[matched];
                        });
                    }

                    /**
                     * Get offsets to the popper
                     * @method
                     * @memberof Popper.Utils
                     * @param {Object} position - CSS position the Popper will get applied
                     * @param {HTMLElement} popper - the popper element
                     * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
                     * @param {String} placement - one of the valid placement options
                     * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
                     */
                    function getPopperOffsets(popper, referenceOffsets, placement) {
                        placement = placement.split('-')[0];

                        // Get popper node sizes
                        var popperRect = getOuterSizes(popper);

                        // Add position, width and height to our offsets object
                        var popperOffsets = {
                            width: popperRect.width,
                            height: popperRect.height
                        };

                        // depending by the popper placement we have to compute its offsets slightly differently
                        var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
                        var mainSide = isHoriz ? 'top' : 'left';
                        var secondarySide = isHoriz ? 'left' : 'top';
                        var measurement = isHoriz ? 'height' : 'width';
                        var secondaryMeasurement = !isHoriz ? 'height' : 'width';

                        popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
                        if (placement === secondarySide) {
                            popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
                        } else {
                            popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
                        }

                        return popperOffsets;
                    }

                    /**
                     * Mimics the `find` method of Array
                     * @method
                     * @memberof Popper.Utils
                     * @argument {Array} arr
                     * @argument prop
                     * @argument value
                     * @returns index or -1
                     */
                    function find(arr, check) {
                        // use native find if supported
                        if (Array.prototype.find) {
                            return arr.find(check);
                        }

                        // use `filter` to obtain the same behavior of `find`
                        return arr.filter(check)[0];
                    }

                    /**
                     * Return the index of the matching object
                     * @method
                     * @memberof Popper.Utils
                     * @argument {Array} arr
                     * @argument prop
                     * @argument value
                     * @returns index or -1
                     */
                    function findIndex(arr, prop, value) {
                        // use native findIndex if supported
                        if (Array.prototype.findIndex) {
                            return arr.findIndex(function (cur) {
                                return cur[prop] === value;
                            });
                        }

                        // use `find` + `indexOf` if `findIndex` isn't supported
                        var match = find(arr, function (obj) {
                            return obj[prop] === value;
                        });
                        return arr.indexOf(match);
                    }

                    /**
                     * Loop trough the list of modifiers and run them in order,
                     * each of them will then edit the data object.
                     * @method
                     * @memberof Popper.Utils
                     * @param {dataObject} data
                     * @param {Array} modifiers
                     * @param {String} ends - Optional modifier name used as stopper
                     * @returns {dataObject}
                     */
                    function runModifiers(modifiers, data, ends) {
                        var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

                        modifiersToRun.forEach(function (modifier) {
                            if (modifier['function']) {
                                // eslint-disable-line dot-notation
                                console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
                            }
                            var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
                            if (modifier.enabled && isFunction(fn)) {
                                // Add properties to offsets to make them a complete clientRect object
                                // we do this before each modifier to make sure the previous one doesn't
                                // mess with these values
                                data.offsets.popper = getClientRect(data.offsets.popper);
                                data.offsets.reference = getClientRect(data.offsets.reference);

                                data = fn(data, modifier);
                            }
                        });

                        return data;
                    }

                    /**
                     * Updates the position of the popper, computing the new offsets and applying
                     * the new style.<br />
                     * Prefer `scheduleUpdate` over `update` because of performance reasons.
                     * @method
                     * @memberof Popper
                     */
                    function update() {
                        // if popper is destroyed, don't perform any further update
                        if (this.state.isDestroyed) {
                            return;
                        }

                        var data = {
                            instance: this,
                            styles: {},
                            arrowStyles: {},
                            attributes: {},
                            flipped: false,
                            offsets: {}
                        };

                        // compute reference element offsets
                        data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

                        // compute auto placement, store placement inside the data object,
                        // modifiers will be able to edit `placement` if needed
                        // and refer to originalPlacement to know the original value
                        data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

                        // store the computed placement inside `originalPlacement`
                        data.originalPlacement = data.placement;

                        data.positionFixed = this.options.positionFixed;

                        // compute the popper offsets
                        data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

                        data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

                        // run the modifiers
                        data = runModifiers(this.modifiers, data);

                        // the first `update` will call `onCreate` callback
                        // the other ones will call `onUpdate` callback
                        if (!this.state.isCreated) {
                            this.state.isCreated = true;
                            this.options.onCreate(data);
                        } else {
                            this.options.onUpdate(data);
                        }
                    }

                    /**
                     * Helper used to know if the given modifier is enabled.
                     * @method
                     * @memberof Popper.Utils
                     * @returns {Boolean}
                     */
                    function isModifierEnabled(modifiers, modifierName) {
                        return modifiers.some(function (_ref) {
                            var name = _ref.name,
                                enabled = _ref.enabled;
                            return enabled && name === modifierName;
                        });
                    }

                    /**
                     * Get the prefixed supported property name
                     * @method
                     * @memberof Popper.Utils
                     * @argument {String} property (camelCase)
                     * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
                     */
                    function getSupportedPropertyName(property) {
                        var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
                        var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

                        for (var i = 0; i < prefixes.length; i++) {
                            var prefix = prefixes[i];
                            var toCheck = prefix ? '' + prefix + upperProp : property;
                            if (typeof document.body.style[toCheck] !== 'undefined') {
                                return toCheck;
                            }
                        }
                        return null;
                    }

                    /**
                     * Destroy the popper
                     * @method
                     * @memberof Popper
                     */
                    function destroy() {
                        this.state.isDestroyed = true;

                        // touch DOM only if `applyStyle` modifier is enabled
                        if (isModifierEnabled(this.modifiers, 'applyStyle')) {
                            this.popper.removeAttribute('x-placement');
                            this.popper.style.position = '';
                            this.popper.style.top = '';
                            this.popper.style.left = '';
                            this.popper.style.right = '';
                            this.popper.style.bottom = '';
                            this.popper.style.willChange = '';
                            this.popper.style[getSupportedPropertyName('transform')] = '';
                        }

                        this.disableEventListeners();

                        // remove the popper if user explicity asked for the deletion on destroy
                        // do not use `remove` because IE11 doesn't support it
                        if (this.options.removeOnDestroy) {
                            this.popper.parentNode.removeChild(this.popper);
                        }
                        return this;
                    }

                    /**
                     * Get the window associated with the element
                     * @argument {Element} element
                     * @returns {Window}
                     */
                    function getWindow(element) {
                        var ownerDocument = element.ownerDocument;
                        return ownerDocument ? ownerDocument.defaultView : window;
                    }

                    function attachToScrollParents(scrollParent, event, callback, scrollParents) {
                        var isBody = scrollParent.nodeName === 'BODY';
                        var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
                        target.addEventListener(event, callback, {passive: true});

                        if (!isBody) {
                            attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
                        }
                        scrollParents.push(target);
                    }

                    /**
                     * Setup needed event listeners used to update the popper position
                     * @method
                     * @memberof Popper.Utils
                     * @private
                     */
                    function setupEventListeners(reference, options, state, updateBound) {
                        // Resize event listener on window
                        state.updateBound = updateBound;
                        getWindow(reference).addEventListener('resize', state.updateBound, {passive: true});

                        // Scroll event listener on scroll parents
                        var scrollElement = getScrollParent(reference);
                        attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
                        state.scrollElement = scrollElement;
                        state.eventsEnabled = true;

                        return state;
                    }

                    /**
                     * It will add resize/scroll events and start recalculating
                     * position of the popper element when they are triggered.
                     * @method
                     * @memberof Popper
                     */
                    function enableEventListeners() {
                        if (!this.state.eventsEnabled) {
                            this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
                        }
                    }

                    /**
                     * Remove event listeners used to update the popper position
                     * @method
                     * @memberof Popper.Utils
                     * @private
                     */
                    function removeEventListeners(reference, state) {
                        // Remove resize event listener on window
                        getWindow(reference).removeEventListener('resize', state.updateBound);

                        // Remove scroll event listener on scroll parents
                        state.scrollParents.forEach(function (target) {
                            target.removeEventListener('scroll', state.updateBound);
                        });

                        // Reset state
                        state.updateBound = null;
                        state.scrollParents = [];
                        state.scrollElement = null;
                        state.eventsEnabled = false;
                        return state;
                    }

                    /**
                     * It will remove resize/scroll events and won't recalculate popper position
                     * when they are triggered. It also won't trigger onUpdate callback anymore,
                     * unless you call `update` method manually.
                     * @method
                     * @memberof Popper
                     */
                    function disableEventListeners() {
                        if (this.state.eventsEnabled) {
                            cancelAnimationFrame(this.scheduleUpdate);
                            this.state = removeEventListeners(this.reference, this.state);
                        }
                    }

                    /**
                     * Tells if a given input is a number
                     * @method
                     * @memberof Popper.Utils
                     * @param {*} input to check
                     * @return {Boolean}
                     */
                    function isNumeric(n) {
                        return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
                    }

                    /**
                     * Set the style to the given popper
                     * @method
                     * @memberof Popper.Utils
                     * @argument {Element} element - Element to apply the style to
                     * @argument {Object} styles
                     * Object with a list of properties and values which will be applied to the element
                     */
                    function setStyles(element, styles) {
                        Object.keys(styles).forEach(function (prop) {
                            var unit = '';
                            // add unit if the value is numeric and is one of the following
                            if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
                                unit = 'px';
                            }
                            element.style[prop] = styles[prop] + unit;
                        });
                    }

                    /**
                     * Set the attributes to the given popper
                     * @method
                     * @memberof Popper.Utils
                     * @argument {Element} element - Element to apply the attributes to
                     * @argument {Object} styles
                     * Object with a list of properties and values which will be applied to the element
                     */
                    function setAttributes(element, attributes) {
                        Object.keys(attributes).forEach(function (prop) {
                            var value = attributes[prop];
                            if (value !== false) {
                                element.setAttribute(prop, attributes[prop]);
                            } else {
                                element.removeAttribute(prop);
                            }
                        });
                    }

                    /**
                     * @function
                     * @memberof Modifiers
                     * @argument {Object} data - The data object generated by `update` method
                     * @argument {Object} data.styles - List of style properties - values to apply to popper element
                     * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
                     * @argument {Object} options - Modifiers configuration and options
                     * @returns {Object} The same data object
                     */
                    function applyStyle(data) {
                        // any property present in `data.styles` will be applied to the popper,
                        // in this way we can make the 3rd party modifiers add custom styles to it
                        // Be aware, modifiers could override the properties defined in the previous
                        // lines of this modifier!
                        setStyles(data.instance.popper, data.styles);

                        // any property present in `data.attributes` will be applied to the popper,
                        // they will be set as HTML attributes of the element
                        setAttributes(data.instance.popper, data.attributes);

                        // if arrowElement is defined and arrowStyles has some properties
                        if (data.arrowElement && Object.keys(data.arrowStyles).length) {
                            setStyles(data.arrowElement, data.arrowStyles);
                        }

                        return data;
                    }

                    /**
                     * Set the x-placement attribute before everything else because it could be used
                     * to add margins to the popper margins needs to be calculated to get the
                     * correct popper offsets.
                     * @method
                     * @memberof Popper.modifiers
                     * @param {HTMLElement} reference - The reference element used to position the popper
                     * @param {HTMLElement} popper - The HTML element used as popper
                     * @param {Object} options - Popper.js options
                     */
                    function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
                        // compute reference element offsets
                        var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

                        // compute auto placement, store placement inside the data object,
                        // modifiers will be able to edit `placement` if needed
                        // and refer to originalPlacement to know the original value
                        var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

                        popper.setAttribute('x-placement', placement);

                        // Apply `position` to popper before anything else because
                        // without the position applied we can't guarantee correct computations
                        setStyles(popper, {position: options.positionFixed ? 'fixed' : 'absolute'});

                        return options;
                    }

                    /**
                     * @function
                     * @memberof Modifiers
                     * @argument {Object} data - The data object generated by `update` method
                     * @argument {Object} options - Modifiers configuration and options
                     * @returns {Object} The data object, properly modified
                     */
                    function computeStyle(data, options) {
                        var x = options.x,
                            y = options.y;
                        var popper = data.offsets.popper;

                        // Remove this legacy support in Popper.js v2

                        var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
                            return modifier.name === 'applyStyle';
                        }).gpuAcceleration;
                        if (legacyGpuAccelerationOption !== undefined) {
                            console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
                        }
                        var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

                        var offsetParent = getOffsetParent(data.instance.popper);
                        var offsetParentRect = getBoundingClientRect(offsetParent);

                        // Styles
                        var styles = {
                            position: popper.position
                        };

                        // Avoid blurry text by using full pixel integers.
                        // For pixel-perfect positioning, top/bottom prefers rounded
                        // values, while left/right prefers floored values.
                        var offsets = {
                            left: Math.floor(popper.left),
                            top: Math.round(popper.top),
                            bottom: Math.round(popper.bottom),
                            right: Math.floor(popper.right)
                        };

                        var sideA = x === 'bottom' ? 'top' : 'bottom';
                        var sideB = y === 'right' ? 'left' : 'right';

                        // if gpuAcceleration is set to `true` and transform is supported,
                        //  we use `translate3d` to apply the position to the popper we
                        // automatically use the supported prefixed version if needed
                        var prefixedProperty = getSupportedPropertyName('transform');

                        // now, let's make a step back and look at this code closely (wtf?)
                        // If the content of the popper grows once it's been positioned, it
                        // may happen that the popper gets misplaced because of the new content
                        // overflowing its reference element
                        // To avoid this problem, we provide two options (x and y), which allow
                        // the consumer to define the offset origin.
                        // If we position a popper on top of a reference element, we can set
                        // `x` to `top` to make the popper grow towards its top instead of
                        // its bottom.
                        var left = void 0,
                            top = void 0;
                        if (sideA === 'bottom') {
                            top = -offsetParentRect.height + offsets.bottom;
                        } else {
                            top = offsets.top;
                        }
                        if (sideB === 'right') {
                            left = -offsetParentRect.width + offsets.right;
                        } else {
                            left = offsets.left;
                        }
                        if (gpuAcceleration && prefixedProperty) {
                            styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
                            styles[sideA] = 0;
                            styles[sideB] = 0;
                            styles.willChange = 'transform';
                        } else {
                            // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
                            var invertTop = sideA === 'bottom' ? -1 : 1;
                            var invertLeft = sideB === 'right' ? -1 : 1;
                            styles[sideA] = top * invertTop;
                            styles[sideB] = left * invertLeft;
                            styles.willChange = sideA + ', ' + sideB;
                        }

                        // Attributes
                        var attributes = {
                            'x-placement': data.placement
                        };

                        // Update `data` attributes, styles and arrowStyles
                        data.attributes = _extends({}, attributes, data.attributes);
                        data.styles = _extends({}, styles, data.styles);
                        data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

                        return data;
                    }

                    /**
                     * Helper used to know if the given modifier depends from another one.<br />
                     * It checks if the needed modifier is listed and enabled.
                     * @method
                     * @memberof Popper.Utils
                     * @param {Array} modifiers - list of modifiers
                     * @param {String} requestingName - name of requesting modifier
                     * @param {String} requestedName - name of requested modifier
                     * @returns {Boolean}
                     */
                    function isModifierRequired(modifiers, requestingName, requestedName) {
                        var requesting = find(modifiers, function (_ref) {
                            var name = _ref.name;
                            return name === requestingName;
                        });

                        var isRequired = !!requesting && modifiers.some(function (modifier) {
                            return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
                        });

                        if (!isRequired) {
                            var _requesting = '`' + requestingName + '`';
                            var requested = '`' + requestedName + '`';
                            console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
                        }
                        return isRequired;
                    }

                    /**
                     * @function
                     * @memberof Modifiers
                     * @argument {Object} data - The data object generated by update method
                     * @argument {Object} options - Modifiers configuration and options
                     * @returns {Object} The data object, properly modified
                     */
                    function arrow(data, options) {
                        var _data$offsets$arrow;

                        // arrow depends on keepTogether in order to work
                        if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
                            return data;
                        }

                        var arrowElement = options.element;

                        // if arrowElement is a string, suppose it's a CSS selector
                        if (typeof arrowElement === 'string') {
                            arrowElement = data.instance.popper.querySelector(arrowElement);

                            // if arrowElement is not found, don't run the modifier
                            if (!arrowElement) {
                                return data;
                            }
                        } else {
                            // if the arrowElement isn't a query selector we must check that the
                            // provided DOM node is child of its popper node
                            if (!data.instance.popper.contains(arrowElement)) {
                                console.warn('WARNING: `arrow.element` must be child of its popper element!');
                                return data;
                            }
                        }

                        var placement = data.placement.split('-')[0];
                        var _data$offsets = data.offsets,
                            popper = _data$offsets.popper,
                            reference = _data$offsets.reference;

                        var isVertical = ['left', 'right'].indexOf(placement) !== -1;

                        var len = isVertical ? 'height' : 'width';
                        var sideCapitalized = isVertical ? 'Top' : 'Left';
                        var side = sideCapitalized.toLowerCase();
                        var altSide = isVertical ? 'left' : 'top';
                        var opSide = isVertical ? 'bottom' : 'right';
                        var arrowElementSize = getOuterSizes(arrowElement)[len];

                        //
                        // extends keepTogether behavior making sure the popper and its
                        // reference have enough pixels in conjuction
                        //

                        // top/left side
                        if (reference[opSide] - arrowElementSize < popper[side]) {
                            data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
                        }
                        // bottom/right side
                        if (reference[side] + arrowElementSize > popper[opSide]) {
                            data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
                        }
                        data.offsets.popper = getClientRect(data.offsets.popper);

                        // compute center of the popper
                        var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

                        // Compute the sideValue using the updated popper offsets
                        // take popper margin in account because we don't have this info available
                        var css = getStyleComputedProperty(data.instance.popper);
                        var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
                        var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
                        var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

                        // prevent arrowElement from being placed not contiguously to its popper
                        sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

                        data.arrowElement = arrowElement;
                        data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

                        return data;
                    }

                    /**
                     * Get the opposite placement variation of the given one
                     * @method
                     * @memberof Popper.Utils
                     * @argument {String} placement variation
                     * @returns {String} flipped placement variation
                     */
                    function getOppositeVariation(variation) {
                        if (variation === 'end') {
                            return 'start';
                        } else if (variation === 'start') {
                            return 'end';
                        }
                        return variation;
                    }

                    /**
                     * List of accepted placements to use as values of the `placement` option.<br />
                     * Valid placements are:
                     * - `auto`
                     * - `top`
                     * - `right`
                     * - `bottom`
                     * - `left`
                     *
                     * Each placement can have a variation from this list:
                     * - `-start`
                     * - `-end`
                     *
                     * Variations are interpreted easily if you think of them as the left to right
                     * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
                     * is right.<br />
                     * Vertically (`left` and `right`), `start` is top and `end` is bottom.
                     *
                     * Some valid examples are:
                     * - `top-end` (on top of reference, right aligned)
                     * - `right-start` (on right of reference, top aligned)
                     * - `bottom` (on bottom, centered)
                     * - `auto-right` (on the side with more space available, alignment depends by placement)
                     *
                     * @static
                     * @type {Array}
                     * @enum {String}
                     * @readonly
                     * @method placements
                     * @memberof Popper
                     */
                    var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
                    var validPlacements = placements.slice(3);

                    /**
                     * Given an initial placement, returns all the subsequent placements
                     * clockwise (or counter-clockwise).
                     *
                     * @method
                     * @memberof Popper.Utils
                     * @argument {String} placement - A valid placement (it accepts variations)
                     * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
                     * @returns {Array} placements including their variations
                     */
                    function clockwise(placement) {
                        var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

                        var index = validPlacements.indexOf(placement);
                        var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
                        return counter ? arr.reverse() : arr;
                    }

                    var BEHAVIORS = {
                        FLIP: 'flip',
                        CLOCKWISE: 'clockwise',
                        COUNTERCLOCKWISE: 'counterclockwise'
                    };

                    /**
                     * @function
                     * @memberof Modifiers
                     * @argument {Object} data - The data object generated by update method
                     * @argument {Object} options - Modifiers configuration and options
                     * @returns {Object} The data object, properly modified
                     */
                    function flip(data, options) {
                        // if `inner` modifier is enabled, we can't use the `flip` modifier
                        if (isModifierEnabled(data.instance.modifiers, 'inner')) {
                            return data;
                        }

                        if (data.flipped && data.placement === data.originalPlacement) {
                            // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
                            return data;
                        }

                        var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

                        var placement = data.placement.split('-')[0];
                        var placementOpposite = getOppositePlacement(placement);
                        var variation = data.placement.split('-')[1] || '';

                        var flipOrder = [];

                        switch (options.behavior) {
                            case BEHAVIORS.FLIP:
                                flipOrder = [placement, placementOpposite];
                                break;
                            case BEHAVIORS.CLOCKWISE:
                                flipOrder = clockwise(placement);
                                break;
                            case BEHAVIORS.COUNTERCLOCKWISE:
                                flipOrder = clockwise(placement, true);
                                break;
                            default:
                                flipOrder = options.behavior;
                        }

                        flipOrder.forEach(function (step, index) {
                            if (placement !== step || flipOrder.length === index + 1) {
                                return data;
                            }

                            placement = data.placement.split('-')[0];
                            placementOpposite = getOppositePlacement(placement);

                            var popperOffsets = data.offsets.popper;
                            var refOffsets = data.offsets.reference;

                            // using floor because the reference offsets may contain decimals we are not going to consider here
                            var floor = Math.floor;
                            var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

                            var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
                            var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
                            var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
                            var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

                            var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

                            // flip the variation if required
                            var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
                            var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

                            if (overlapsRef || overflowsBoundaries || flippedVariation) {
                                // this boolean to detect any flip loop
                                data.flipped = true;

                                if (overlapsRef || overflowsBoundaries) {
                                    placement = flipOrder[index + 1];
                                }

                                if (flippedVariation) {
                                    variation = getOppositeVariation(variation);
                                }

                                data.placement = placement + (variation ? '-' + variation : '');

                                // this object contains `position`, we want to preserve it along with
                                // any additional property we may add in the future
                                data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

                                data = runModifiers(data.instance.modifiers, data, 'flip');
                            }
                        });
                        return data;
                    }

                    /**
                     * @function
                     * @memberof Modifiers
                     * @argument {Object} data - The data object generated by update method
                     * @argument {Object} options - Modifiers configuration and options
                     * @returns {Object} The data object, properly modified
                     */
                    function keepTogether(data) {
                        var _data$offsets = data.offsets,
                            popper = _data$offsets.popper,
                            reference = _data$offsets.reference;

                        var placement = data.placement.split('-')[0];
                        var floor = Math.floor;
                        var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
                        var side = isVertical ? 'right' : 'bottom';
                        var opSide = isVertical ? 'left' : 'top';
                        var measurement = isVertical ? 'width' : 'height';

                        if (popper[side] < floor(reference[opSide])) {
                            data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
                        }
                        if (popper[opSide] > floor(reference[side])) {
                            data.offsets.popper[opSide] = floor(reference[side]);
                        }

                        return data;
                    }

                    /**
                     * Converts a string containing value + unit into a px value number
                     * @function
                     * @memberof {modifiers~offset}
                     * @private
                     * @argument {String} str - Value + unit string
                     * @argument {String} measurement - `height` or `width`
                     * @argument {Object} popperOffsets
                     * @argument {Object} referenceOffsets
                     * @returns {Number|String}
                     * Value in pixels, or original string if no values were extracted
                     */
                    function toValue(str, measurement, popperOffsets, referenceOffsets) {
                        // separate value from unit
                        var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
                        var value = +split[1];
                        var unit = split[2];

                        // If it's not a number it's an operator, I guess
                        if (!value) {
                            return str;
                        }

                        if (unit.indexOf('%') === 0) {
                            var element = void 0;
                            switch (unit) {
                                case '%p':
                                    element = popperOffsets;
                                    break;
                                case '%':
                                case '%r':
                                default:
                                    element = referenceOffsets;
                            }

                            var rect = getClientRect(element);
                            return rect[measurement] / 100 * value;
                        } else if (unit === 'vh' || unit === 'vw') {
                            // if is a vh or vw, we calculate the size based on the viewport
                            var size = void 0;
                            if (unit === 'vh') {
                                size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
                            } else {
                                size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
                            }
                            return size / 100 * value;
                        } else {
                            // if is an explicit pixel unit, we get rid of the unit and keep the value
                            // if is an implicit unit, it's px, and we return just the value
                            return value;
                        }
                    }

                    /**
                     * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
                     * @function
                     * @memberof {modifiers~offset}
                     * @private
                     * @argument {String} offset
                     * @argument {Object} popperOffsets
                     * @argument {Object} referenceOffsets
                     * @argument {String} basePlacement
                     * @returns {Array} a two cells array with x and y offsets in numbers
                     */
                    function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
                        var offsets = [0, 0];

                        // Use height if placement is left or right and index is 0 otherwise use width
                        // in this way the first offset will use an axis and the second one
                        // will use the other one
                        var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

                        // Split the offset string to obtain a list of values and operands
                        // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
                        var fragments = offset.split(/(\+|\-)/).map(function (frag) {
                            return frag.trim();
                        });

                        // Detect if the offset string contains a pair of values or a single one
                        // they could be separated by comma or space
                        var divider = fragments.indexOf(find(fragments, function (frag) {
                            return frag.search(/,|\s/) !== -1;
                        }));

                        if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
                            console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
                        }

                        // If divider is found, we divide the list of values and operands to divide
                        // them by ofset X and Y.
                        var splitRegex = /\s*,\s*|\s+/;
                        var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

                        // Convert the values with units to absolute pixels to allow our computations
                        ops = ops.map(function (op, index) {
                            // Most of the units rely on the orientation of the popper
                            var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
                            var mergeWithPrevious = false;
                            return op
                            // This aggregates any `+` or `-` sign that aren't considered operators
                            // e.g.: 10 + +5 => [10, +, +5]
                                .reduce(function (a, b) {
                                    if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
                                        a[a.length - 1] = b;
                                        mergeWithPrevious = true;
                                        return a;
                                    } else if (mergeWithPrevious) {
                                        a[a.length - 1] += b;
                                        mergeWithPrevious = false;
                                        return a;
                                    } else {
                                        return a.concat(b);
                                    }
                                }, [])
                                // Here we convert the string values into number values (in px)
                                .map(function (str) {
                                    return toValue(str, measurement, popperOffsets, referenceOffsets);
                                });
                        });

                        // Loop trough the offsets arrays and execute the operations
                        ops.forEach(function (op, index) {
                            op.forEach(function (frag, index2) {
                                if (isNumeric(frag)) {
                                    offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
                                }
                            });
                        });
                        return offsets;
                    }

                    /**
                     * @function
                     * @memberof Modifiers
                     * @argument {Object} data - The data object generated by update method
                     * @argument {Object} options - Modifiers configuration and options
                     * @argument {Number|String} options.offset=0
                     * The offset value as described in the modifier description
                     * @returns {Object} The data object, properly modified
                     */
                    function offset(data, _ref) {
                        var offset = _ref.offset;
                        var placement = data.placement,
                            _data$offsets = data.offsets,
                            popper = _data$offsets.popper,
                            reference = _data$offsets.reference;

                        var basePlacement = placement.split('-')[0];

                        var offsets = void 0;
                        if (isNumeric(+offset)) {
                            offsets = [+offset, 0];
                        } else {
                            offsets = parseOffset(offset, popper, reference, basePlacement);
                        }

                        if (basePlacement === 'left') {
                            popper.top += offsets[0];
                            popper.left -= offsets[1];
                        } else if (basePlacement === 'right') {
                            popper.top += offsets[0];
                            popper.left += offsets[1];
                        } else if (basePlacement === 'top') {
                            popper.left += offsets[0];
                            popper.top -= offsets[1];
                        } else if (basePlacement === 'bottom') {
                            popper.left += offsets[0];
                            popper.top += offsets[1];
                        }

                        data.popper = popper;
                        return data;
                    }

                    /**
                     * @function
                     * @memberof Modifiers
                     * @argument {Object} data - The data object generated by `update` method
                     * @argument {Object} options - Modifiers configuration and options
                     * @returns {Object} The data object, properly modified
                     */
                    function preventOverflow(data, options) {
                        var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

                        // If offsetParent is the reference element, we really want to
                        // go one step up and use the next offsetParent as reference to
                        // avoid to make this modifier completely useless and look like broken
                        if (data.instance.reference === boundariesElement) {
                            boundariesElement = getOffsetParent(boundariesElement);
                        }

                        // NOTE: DOM access here
                        // resets the popper's position so that the document size can be calculated excluding
                        // the size of the popper element itself
                        var transformProp = getSupportedPropertyName('transform');
                        var popperStyles = data.instance.popper.style; // assignment to help minification
                        var top = popperStyles.top,
                            left = popperStyles.left,
                            transform = popperStyles[transformProp];

                        popperStyles.top = '';
                        popperStyles.left = '';
                        popperStyles[transformProp] = '';

                        var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

                        // NOTE: DOM access here
                        // restores the original style properties after the offsets have been computed
                        popperStyles.top = top;
                        popperStyles.left = left;
                        popperStyles[transformProp] = transform;

                        options.boundaries = boundaries;

                        var order = options.priority;
                        var popper = data.offsets.popper;

                        var check = {
                            primary: function primary(placement) {
                                var value = popper[placement];
                                if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
                                    value = Math.max(popper[placement], boundaries[placement]);
                                }
                                return defineProperty({}, placement, value);
                            },
                            secondary: function secondary(placement) {
                                var mainSide = placement === 'right' ? 'left' : 'top';
                                var value = popper[mainSide];
                                if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
                                    value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
                                }
                                return defineProperty({}, mainSide, value);
                            }
                        };

                        order.forEach(function (placement) {
                            var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
                            popper = _extends({}, popper, check[side](placement));
                        });

                        data.offsets.popper = popper;

                        return data;
                    }

                    /**
                     * @function
                     * @memberof Modifiers
                     * @argument {Object} data - The data object generated by `update` method
                     * @argument {Object} options - Modifiers configuration and options
                     * @returns {Object} The data object, properly modified
                     */
                    function shift(data) {
                        var placement = data.placement;
                        var basePlacement = placement.split('-')[0];
                        var shiftvariation = placement.split('-')[1];

                        // if shift shiftvariation is specified, run the modifier
                        if (shiftvariation) {
                            var _data$offsets = data.offsets,
                                reference = _data$offsets.reference,
                                popper = _data$offsets.popper;

                            var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
                            var side = isVertical ? 'left' : 'top';
                            var measurement = isVertical ? 'width' : 'height';

                            var shiftOffsets = {
                                start: defineProperty({}, side, reference[side]),
                                end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
                            };

                            data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
                        }

                        return data;
                    }

                    /**
                     * @function
                     * @memberof Modifiers
                     * @argument {Object} data - The data object generated by update method
                     * @argument {Object} options - Modifiers configuration and options
                     * @returns {Object} The data object, properly modified
                     */
                    function hide(data) {
                        if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
                            return data;
                        }

                        var refRect = data.offsets.reference;
                        var bound = find(data.instance.modifiers, function (modifier) {
                            return modifier.name === 'preventOverflow';
                        }).boundaries;

                        if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
                            // Avoid unnecessary DOM access if visibility hasn't changed
                            if (data.hide === true) {
                                return data;
                            }

                            data.hide = true;
                            data.attributes['x-out-of-boundaries'] = '';
                        } else {
                            // Avoid unnecessary DOM access if visibility hasn't changed
                            if (data.hide === false) {
                                return data;
                            }

                            data.hide = false;
                            data.attributes['x-out-of-boundaries'] = false;
                        }

                        return data;
                    }

                    /**
                     * @function
                     * @memberof Modifiers
                     * @argument {Object} data - The data object generated by `update` method
                     * @argument {Object} options - Modifiers configuration and options
                     * @returns {Object} The data object, properly modified
                     */
                    function inner(data) {
                        var placement = data.placement;
                        var basePlacement = placement.split('-')[0];
                        var _data$offsets = data.offsets,
                            popper = _data$offsets.popper,
                            reference = _data$offsets.reference;

                        var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

                        var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

                        popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

                        data.placement = getOppositePlacement(placement);
                        data.offsets.popper = getClientRect(popper);

                        return data;
                    }

                    /**
                     * Modifier function, each modifier can have a function of this type assigned
                     * to its `fn` property.<br />
                     * These functions will be called on each update, this means that you must
                     * make sure they are performant enough to avoid performance bottlenecks.
                     *
                     * @function ModifierFn
                     * @argument {dataObject} data - The data object generated by `update` method
                     * @argument {Object} options - Modifiers configuration and options
                     * @returns {dataObject} The data object, properly modified
                     */

                    /**
                     * Modifiers are plugins used to alter the behavior of your poppers.<br />
                     * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
                     * needed by the library.
                     *
                     * Usually you don't want to override the `order`, `fn` and `onLoad` props.
                     * All the other properties are configurations that could be tweaked.
                     * @namespace modifiers
                     */
                    var modifiers = {
                        /**
                         * Modifier used to shift the popper on the start or end of its reference
                         * element.<br />
                         * It will read the variation of the `placement` property.<br />
                         * It can be one either `-end` or `-start`.
                         * @memberof modifiers
                         * @inner
                         */
                        shift: {
                            /** @prop {number} order=100 - Index used to define the order of execution */
                            order: 100,
                            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
                            enabled: true,
                            /** @prop {ModifierFn} */
                            fn: shift
                        },

                        /**
                         * The `offset` modifier can shift your popper on both its axis.
                         *
                         * It accepts the following units:
                         * - `px` or unitless, interpreted as pixels
                         * - `%` or `%r`, percentage relative to the length of the reference element
                         * - `%p`, percentage relative to the length of the popper element
                         * - `vw`, CSS viewport width unit
                         * - `vh`, CSS viewport height unit
                         *
                         * For length is intended the main axis relative to the placement of the popper.<br />
                         * This means that if the placement is `top` or `bottom`, the length will be the
                         * `width`. In case of `left` or `right`, it will be the height.
                         *
                         * You can provide a single value (as `Number` or `String`), or a pair of values
                         * as `String` divided by a comma or one (or more) white spaces.<br />
                         * The latter is a deprecated method because it leads to confusion and will be
                         * removed in v2.<br />
                         * Additionally, it accepts additions and subtractions between different units.
                         * Note that multiplications and divisions aren't supported.
                         *
                         * Valid examples are:
                         * ```
                         * 10
                         * '10%'
                         * '10, 10'
                         * '10%, 10'
                         * '10 + 10%'
                         * '10 - 5vh + 3%'
                         * '-10px + 5vh, 5px - 6%'
                         * ```
                         * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
                         * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
                         * > More on this [reading this issue](https://github.com/FezVrasta/popper.js/issues/373)
                         *
                         * @memberof modifiers
                         * @inner
                         */
                        offset: {
                            /** @prop {number} order=200 - Index used to define the order of execution */
                            order: 200,
                            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
                            enabled: true,
                            /** @prop {ModifierFn} */
                            fn: offset,
                            /** @prop {Number|String} offset=0
                             * The offset value as described in the modifier description
                             */
                            offset: 0
                        },

                        /**
                         * Modifier used to prevent the popper from being positioned outside the boundary.
                         *
                         * An scenario exists where the reference itself is not within the boundaries.<br />
                         * We can say it has "escaped the boundaries" — or just "escaped".<br />
                         * In this case we need to decide whether the popper should either:
                         *
                         * - detach from the reference and remain "trapped" in the boundaries, or
                         * - if it should ignore the boundary and "escape with its reference"
                         *
                         * When `escapeWithReference` is set to`true` and reference is completely
                         * outside its boundaries, the popper will overflow (or completely leave)
                         * the boundaries in order to remain attached to the edge of the reference.
                         *
                         * @memberof modifiers
                         * @inner
                         */
                        preventOverflow: {
                            /** @prop {number} order=300 - Index used to define the order of execution */
                            order: 300,
                            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
                            enabled: true,
                            /** @prop {ModifierFn} */
                            fn: preventOverflow,
                            /**
                             * @prop {Array} [priority=['left','right','top','bottom']]
                             * Popper will try to prevent overflow following these priorities by default,
                             * then, it could overflow on the left and on top of the `boundariesElement`
                             */
                            priority: ['left', 'right', 'top', 'bottom'],
                            /**
                             * @prop {number} padding=5
                             * Amount of pixel used to define a minimum distance between the boundaries
                             * and the popper this makes sure the popper has always a little padding
                             * between the edges of its container
                             */
                            padding: 5,
                            /**
                             * @prop {String|HTMLElement} boundariesElement='scrollParent'
                             * Boundaries used by the modifier, can be `scrollParent`, `window`,
                             * `viewport` or any DOM element.
                             */
                            boundariesElement: 'scrollParent'
                        },

                        /**
                         * Modifier used to make sure the reference and its popper stay near eachothers
                         * without leaving any gap between the two. Expecially useful when the arrow is
                         * enabled and you want to assure it to point to its reference element.
                         * It cares only about the first axis, you can still have poppers with margin
                         * between the popper and its reference element.
                         * @memberof modifiers
                         * @inner
                         */
                        keepTogether: {
                            /** @prop {number} order=400 - Index used to define the order of execution */
                            order: 400,
                            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
                            enabled: true,
                            /** @prop {ModifierFn} */
                            fn: keepTogether
                        },

                        /**
                         * This modifier is used to move the `arrowElement` of the popper to make
                         * sure it is positioned between the reference element and its popper element.
                         * It will read the outer size of the `arrowElement` node to detect how many
                         * pixels of conjuction are needed.
                         *
                         * It has no effect if no `arrowElement` is provided.
                         * @memberof modifiers
                         * @inner
                         */
                        arrow: {
                            /** @prop {number} order=500 - Index used to define the order of execution */
                            order: 500,
                            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
                            enabled: true,
                            /** @prop {ModifierFn} */
                            fn: arrow,
                            /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
                            element: '[x-arrow]'
                        },

                        /**
                         * Modifier used to flip the popper's placement when it starts to overlap its
                         * reference element.
                         *
                         * Requires the `preventOverflow` modifier before it in order to work.
                         *
                         * **NOTE:** this modifier will interrupt the current update cycle and will
                         * restart it if it detects the need to flip the placement.
                         * @memberof modifiers
                         * @inner
                         */
                        flip: {
                            /** @prop {number} order=600 - Index used to define the order of execution */
                            order: 600,
                            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
                            enabled: true,
                            /** @prop {ModifierFn} */
                            fn: flip,
                            /**
                             * @prop {String|Array} behavior='flip'
                             * The behavior used to change the popper's placement. It can be one of
                             * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
                             * placements (with optional variations).
                             */
                            behavior: 'flip',
                            /**
                             * @prop {number} padding=5
                             * The popper will flip if it hits the edges of the `boundariesElement`
                             */
                            padding: 5,
                            /**
                             * @prop {String|HTMLElement} boundariesElement='viewport'
                             * The element which will define the boundaries of the popper position,
                             * the popper will never be placed outside of the defined boundaries
                             * (except if keepTogether is enabled)
                             */
                            boundariesElement: 'viewport'
                        },

                        /**
                         * Modifier used to make the popper flow toward the inner of the reference element.
                         * By default, when this modifier is disabled, the popper will be placed outside
                         * the reference element.
                         * @memberof modifiers
                         * @inner
                         */
                        inner: {
                            /** @prop {number} order=700 - Index used to define the order of execution */
                            order: 700,
                            /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
                            enabled: false,
                            /** @prop {ModifierFn} */
                            fn: inner
                        },

                        /**
                         * Modifier used to hide the popper when its reference element is outside of the
                         * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
                         * be used to hide with a CSS selector the popper when its reference is
                         * out of boundaries.
                         *
                         * Requires the `preventOverflow` modifier before it in order to work.
                         * @memberof modifiers
                         * @inner
                         */
                        hide: {
                            /** @prop {number} order=800 - Index used to define the order of execution */
                            order: 800,
                            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
                            enabled: true,
                            /** @prop {ModifierFn} */
                            fn: hide
                        },

                        /**
                         * Computes the style that will be applied to the popper element to gets
                         * properly positioned.
                         *
                         * Note that this modifier will not touch the DOM, it just prepares the styles
                         * so that `applyStyle` modifier can apply it. This separation is useful
                         * in case you need to replace `applyStyle` with a custom implementation.
                         *
                         * This modifier has `850` as `order` value to maintain backward compatibility
                         * with previous versions of Popper.js. Expect the modifiers ordering method
                         * to change in future major versions of the library.
                         *
                         * @memberof modifiers
                         * @inner
                         */
                        computeStyle: {
                            /** @prop {number} order=850 - Index used to define the order of execution */
                            order: 850,
                            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
                            enabled: true,
                            /** @prop {ModifierFn} */
                            fn: computeStyle,
                            /**
                             * @prop {Boolean} gpuAcceleration=true
                             * If true, it uses the CSS 3d transformation to position the popper.
                             * Otherwise, it will use the `top` and `left` properties.
                             */
                            gpuAcceleration: true,
                            /**
                             * @prop {string} [x='bottom']
                             * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
                             * Change this if your popper should grow in a direction different from `bottom`
                             */
                            x: 'bottom',
                            /**
                             * @prop {string} [x='left']
                             * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
                             * Change this if your popper should grow in a direction different from `right`
                             */
                            y: 'right'
                        },

                        /**
                         * Applies the computed styles to the popper element.
                         *
                         * All the DOM manipulations are limited to this modifier. This is useful in case
                         * you want to integrate Popper.js inside a framework or view library and you
                         * want to delegate all the DOM manipulations to it.
                         *
                         * Note that if you disable this modifier, you must make sure the popper element
                         * has its position set to `absolute` before Popper.js can do its work!
                         *
                         * Just disable this modifier and define you own to achieve the desired effect.
                         *
                         * @memberof modifiers
                         * @inner
                         */
                        applyStyle: {
                            /** @prop {number} order=900 - Index used to define the order of execution */
                            order: 900,
                            /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
                            enabled: true,
                            /** @prop {ModifierFn} */
                            fn: applyStyle,
                            /** @prop {Function} */
                            onLoad: applyStyleOnLoad,
                            /**
                             * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
                             * @prop {Boolean} gpuAcceleration=true
                             * If true, it uses the CSS 3d transformation to position the popper.
                             * Otherwise, it will use the `top` and `left` properties.
                             */
                            gpuAcceleration: undefined
                        }
                    };

                    /**
                     * The `dataObject` is an object containing all the informations used by Popper.js
                     * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
                     * @name dataObject
                     * @property {Object} data.instance The Popper.js instance
                     * @property {String} data.placement Placement applied to popper
                     * @property {String} data.originalPlacement Placement originally defined on init
                     * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
                     * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.
                     * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
                     * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)
                     * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow, it expects the JavaScript nomenclature (eg. `marginBottom`)
                     * @property {Object} data.boundaries Offsets of the popper boundaries
                     * @property {Object} data.offsets The measurements of popper, reference and arrow elements.
                     * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
                     * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
                     * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
                     */

                    /**
                     * Default options provided to Popper.js constructor.<br />
                     * These can be overriden using the `options` argument of Popper.js.<br />
                     * To override an option, simply pass as 3rd argument an object with the same
                     * structure of this object, example:
                     * ```
                     * new Popper(ref, pop, {
                     *   modifiers: {
                     *     preventOverflow: { enabled: false }
                     *   }
                     * })
                     * ```
                     * @type {Object}
                     * @static
                     * @memberof Popper
                     */
                    var Defaults = {
                        /**
                         * Popper's placement
                         * @prop {Popper.placements} placement='bottom'
                         */
                        placement: 'bottom',

                        /**
                         * Set this to true if you want popper to position it self in 'fixed' mode
                         * @prop {Boolean} positionFixed=false
                         */
                        positionFixed: false,

                        /**
                         * Whether events (resize, scroll) are initially enabled
                         * @prop {Boolean} eventsEnabled=true
                         */
                        eventsEnabled: true,

                        /**
                         * Set to true if you want to automatically remove the popper when
                         * you call the `destroy` method.
                         * @prop {Boolean} removeOnDestroy=false
                         */
                        removeOnDestroy: false,

                        /**
                         * Callback called when the popper is created.<br />
                         * By default, is set to no-op.<br />
                         * Access Popper.js instance with `data.instance`.
                         * @prop {onCreate}
                         */
                        onCreate: function onCreate() {
                        },

                        /**
                         * Callback called when the popper is updated, this callback is not called
                         * on the initialization/creation of the popper, but only on subsequent
                         * updates.<br />
                         * By default, is set to no-op.<br />
                         * Access Popper.js instance with `data.instance`.
                         * @prop {onUpdate}
                         */
                        onUpdate: function onUpdate() {
                        },

                        /**
                         * List of modifiers used to modify the offsets before they are applied to the popper.
                         * They provide most of the functionalities of Popper.js
                         * @prop {modifiers}
                         */
                        modifiers: modifiers
                    };

                    /**
                     * @callback onCreate
                     * @param {dataObject} data
                     */

                    /**
                     * @callback onUpdate
                     * @param {dataObject} data
                     */

// Utils
// Methods
                    var Popper = function () {
                        /**
                         * Create a new Popper.js instance
                         * @class Popper
                         * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
                         * @param {HTMLElement} popper - The HTML element used as popper.
                         * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
                         * @return {Object} instance - The generated Popper.js instance
                         */
                        function Popper(reference, popper) {
                            var _this = this;

                            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                            classCallCheck(this, Popper);

                            this.scheduleUpdate = function () {
                                return requestAnimationFrame(_this.update);
                            };

                            // make update() debounced, so that it only runs at most once-per-tick
                            this.update = debounce(this.update.bind(this));

                            // with {} we create a new object with the options inside it
                            this.options = _extends({}, Popper.Defaults, options);

                            // init state
                            this.state = {
                                isDestroyed: false,
                                isCreated: false,
                                scrollParents: []
                            };

                            // get reference and popper elements (allow jQuery wrappers)
                            this.reference = reference && reference.jquery ? reference[0] : reference;
                            this.popper = popper && popper.jquery ? popper[0] : popper;

                            // Deep merge modifiers options
                            this.options.modifiers = {};
                            Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
                                _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
                            });

                            // Refactoring modifiers' list (Object => Array)
                            this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
                                return _extends({
                                    name: name
                                }, _this.options.modifiers[name]);
                            })
                            // sort the modifiers by order
                                .sort(function (a, b) {
                                    return a.order - b.order;
                                });

                            // modifiers have the ability to execute arbitrary code when Popper.js get inited
                            // such code is executed in the same order of its modifier
                            // they could add new properties to their options configuration
                            // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
                            this.modifiers.forEach(function (modifierOptions) {
                                if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
                                    modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
                                }
                            });

                            // fire the first update to position the popper in the right place
                            this.update();

                            var eventsEnabled = this.options.eventsEnabled;
                            if (eventsEnabled) {
                                // setup event listeners, they will take care of update the position in specific situations
                                this.enableEventListeners();
                            }

                            this.state.eventsEnabled = eventsEnabled;
                        }

                        // We can't use class properties because they don't get listed in the
                        // class prototype and break stuff like Sinon stubs


                        createClass(Popper, [{
                            key: 'update',
                            value: function update$$1() {
                                return update.call(this);
                            }
                        }, {
                            key: 'destroy',
                            value: function destroy$$1() {
                                return destroy.call(this);
                            }
                        }, {
                            key: 'enableEventListeners',
                            value: function enableEventListeners$$1() {
                                return enableEventListeners.call(this);
                            }
                        }, {
                            key: 'disableEventListeners',
                            value: function disableEventListeners$$1() {
                                return disableEventListeners.call(this);
                            }

                            /**
                             * Schedule an update, it will run on the next UI update available
                             * @method scheduleUpdate
                             * @memberof Popper
                             */


                            /**
                             * Collection of utilities useful when writing custom modifiers.
                             * Starting from version 1.7, this method is available only if you
                             * include `popper-utils.js` before `popper.js`.
                             *
                             * **DEPRECATION**: This way to access PopperUtils is deprecated
                             * and will be removed in v2! Use the PopperUtils module directly instead.
                             * Due to the high instability of the methods contained in Utils, we can't
                             * guarantee them to follow semver. Use them at your own risk!
                             * @static
                             * @private
                             * @type {Object}
                             * @deprecated since version 1.8
                             * @member Utils
                             * @memberof Popper
                             */

                        }]);
                        return Popper;
                    }();

                    /**
                     * The `referenceObject` is an object that provides an interface compatible with Popper.js
                     * and lets you use it as replacement of a real DOM node.<br />
                     * You can use this method to position a popper relatively to a set of coordinates
                     * in case you don't have a DOM node to use as reference.
                     *
                     * ```
                     * new Popper(referenceObject, popperNode);
                     * ```
                     *
                     * NB: This feature isn't supported in Internet Explorer 10
                     * @name referenceObject
                     * @property {Function} data.getBoundingClientRect
                     * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
                     * @property {number} data.clientWidth
                     * An ES6 getter that will return the width of the virtual reference element.
                     * @property {number} data.clientHeight
                     * An ES6 getter that will return the height of the virtual reference element.
                     */


                    Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
                    Popper.placements = placements;
                    Popper.Defaults = Defaults;

                    return Popper;

                })));


            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
        }, {}], 13: [function (require, module, exports) {
            'use strict';
            const strictUriEncode = require('strict-uri-encode');
            const decodeComponent = require('decode-uri-component');

            function encoderForArrayFormat(options) {
                switch (options.arrayFormat) {
                    case 'index':
                        return (key, value, index) => {
                            return value === null ? [
                                encode(key, options),
                                '[',
                                index,
                                ']'
                            ].join('') : [
                                encode(key, options),
                                '[',
                                encode(index, options),
                                ']=',
                                encode(value, options)
                            ].join('');
                        };
                    case 'bracket':
                        return (key, value) => {
                            return value === null ? [encode(key, options), '[]'].join('') : [
                                encode(key, options),
                                '[]=',
                                encode(value, options)
                            ].join('');
                        };
                    default:
                        return (key, value) => {
                            return value === null ? encode(key, options) : [
                                encode(key, options),
                                '=',
                                encode(value, options)
                            ].join('');
                        };
                }
            }

            function parserForArrayFormat(options) {
                let result;

                switch (options.arrayFormat) {
                    case 'index':
                        return (key, value, accumulator) => {
                            result = /\[(\d*)\]$/.exec(key);

                            key = key.replace(/\[\d*\]$/, '');

                            if (!result) {
                                accumulator[key] = value;
                                return;
                            }

                            if (accumulator[key] === undefined) {
                                accumulator[key] = {};
                            }

                            accumulator[key][result[1]] = value;
                        };
                    case 'bracket':
                        return (key, value, accumulator) => {
                            result = /(\[\])$/.exec(key);
                            key = key.replace(/\[\]$/, '');

                            if (!result) {
                                accumulator[key] = value;
                                return;
                            }

                            if (accumulator[key] === undefined) {
                                accumulator[key] = [value];
                                return;
                            }

                            accumulator[key] = [].concat(accumulator[key], value);
                        };
                    default:
                        return (key, value, accumulator) => {
                            if (accumulator[key] === undefined) {
                                accumulator[key] = value;
                                return;
                            }

                            accumulator[key] = [].concat(accumulator[key], value);
                        };
                }
            }

            function encode(value, options) {
                if (options.encode) {
                    return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
                }

                return value;
            }

            function decode(value, options) {
                if (options.decode) {
                    return decodeComponent(value);
                }

                return value;
            }

            function keysSorter(input) {
                if (Array.isArray(input)) {
                    return input.sort();
                }

                if (typeof input === 'object') {
                    return keysSorter(Object.keys(input))
                        .sort((a, b) => Number(a) - Number(b))
                        .map(key => input[key]);
                }

                return input;
            }

            function extract(input) {
                const queryStart = input.indexOf('?');
                if (queryStart === -1) {
                    return '';
                }

                return input.slice(queryStart + 1);
            }

            function parse(input, options) {
                options = Object.assign({decode: true, arrayFormat: 'none'}, options);

                const formatter = parserForArrayFormat(options);

                // Create an object with no prototype
                const ret = Object.create(null);

                if (typeof input !== 'string') {
                    return ret;
                }

                input = input.trim().replace(/^[?#&]/, '');

                if (!input) {
                    return ret;
                }

                for (const param of input.split('&')) {
                    let [key, value] = param.replace(/\+/g, ' ').split('=');

                    // Missing `=` should be `null`:
                    // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
                    value = value === undefined ? null : decode(value, options);

                    formatter(decode(key, options), value, ret);
                }

                return Object.keys(ret).sort().reduce((result, key) => {
                    const value = ret[key];
                    if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
                        // Sort object keys, not values
                        result[key] = keysSorter(value);
                    } else {
                        result[key] = value;
                    }

                    return result;
                }, Object.create(null));
            }

            exports.extract = extract;
            exports.parse = parse;

            exports.stringify = (obj, options) => {
                if (!obj) {
                    return '';
                }

                options = Object.assign({
                    encode: true,
                    strict: true,
                    arrayFormat: 'none'
                }, options);

                const formatter = encoderForArrayFormat(options);
                const keys = Object.keys(obj);

                if (options.sort !== false) {
                    keys.sort(options.sort);
                }

                return keys.map(key => {
                    const value = obj[key];

                    if (value === undefined) {
                        return '';
                    }

                    if (value === null) {
                        return encode(key, options);
                    }

                    if (Array.isArray(value)) {
                        const result = [];

                        for (const value2 of value.slice()) {
                            if (value2 === undefined) {
                                continue;
                            }

                            result.push(formatter(key, value2, result.length));
                        }

                        return result.join('&');
                    }

                    return encode(key, options) + '=' + encode(value, options);
                }).filter(x => x.length > 0).join('&');
            };

            exports.parseUrl = (input, options) => {
                const hashStart = input.indexOf('#');
                if (hashStart !== -1) {
                    input = input.slice(0, hashStart);
                }

                return {
                    url: input.split('?')[0] || '',
                    query: parse(extract(input), options)
                };
            };

        }, {"decode-uri-component": 9, "strict-uri-encode": 14}], 14: [function (require, module, exports) {
            'use strict';
            module.exports = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);

        }, {}], 15: [function (require, module, exports) {
            /**!
             * @fileOverview Kickass library to create and place poppers near their reference elements.
             * @version 1.2.0
             * @license
             * Copyright (c) 2016 Federico Zivolo and contributors
             *
             * Permission is hereby granted, free of charge, to any person obtaining a copy
             * of this software and associated documentation files (the "Software"), to deal
             * in the Software without restriction, including without limitation the rights
             * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
             * copies of the Software, and to permit persons to whom the Software is
             * furnished to do so, subject to the following conditions:
             *
             * The above copyright notice and this permission notice shall be included in all
             * copies or substantial portions of the Software.
             *
             * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
             * SOFTWARE.
             */
            (function (global, factory) {
                typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('popper.js')) :
                    typeof define === 'function' && define.amd ? define(['popper.js'], factory) :
                        (global.Tooltip = factory(global.Popper));
            }(this, (function (Popper) {
                'use strict';

                Popper = Popper && Popper.hasOwnProperty('default') ? Popper['default'] : Popper;

                /**
                 * Check if the given variable is a function
                 * @method
                 * @memberof Popper.Utils
                 * @argument {Any} functionToCheck - variable to check
                 * @returns {Boolean} answer to: is a function?
                 */
                function isFunction(functionToCheck) {
                    var getType = {};
                    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
                }

                var classCallCheck = function (instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                };

                var createClass = function () {
                    function defineProperties(target, props) {
                        for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable = descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ("value" in descriptor) descriptor.writable = true;
                            Object.defineProperty(target, descriptor.key, descriptor);
                        }
                    }

                    return function (Constructor, protoProps, staticProps) {
                        if (protoProps) defineProperties(Constructor.prototype, protoProps);
                        if (staticProps) defineProperties(Constructor, staticProps);
                        return Constructor;
                    };
                }();


                var _extends = Object.assign || function (target) {
                    for (var i = 1; i < arguments.length; i++) {
                        var source = arguments[i];

                        for (var key in source) {
                            if (Object.prototype.hasOwnProperty.call(source, key)) {
                                target[key] = source[key];
                            }
                        }
                    }

                    return target;
                };

                var DEFAULT_OPTIONS = {
                    container: false,
                    delay: 0,
                    html: false,
                    placement: 'top',
                    title: '',
                    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
                    trigger: 'hover focus',
                    offset: 0
                };

                var Tooltip = function () {
                    /**
                     * Create a new Tooltip.js instance
                     * @class Tooltip
                     * @param {HTMLElement} reference - The DOM node used as reference of the tooltip (it can be a jQuery element).
                     * @param {Object} options
                     * @param {String|PlacementFunction} options.placement=top
                     *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -end),
                     *      left(-start, -end)`
                     * @param {HTMLElement|String|false} options.container=false - Append the tooltip to a specific element.
                     * @param {Number|Object} options.delay=0
                     *      Delay showing and hiding the tooltip (ms) - does not apply to manual trigger type.
                     *      If a number is supplied, delay is applied to both hide/show.
                     *      Object structure is: `{ show: 500, hide: 100 }`
                     * @param {Boolean} options.html=false - Insert HTML into the tooltip. If false, the content will inserted with `textContent`.
                     * @param {String|PlacementFunction} options.placement='top' - One of the allowed placements, or a function returning one of them.
                     * @param {String} [options.template='<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>']
                     *      Base HTML to used when creating the tooltip.
                     *      The tooltip's `title` will be injected into the `.tooltip-inner` or `.tooltip__inner`.
                     *      `.tooltip-arrow` or `.tooltip__arrow` will become the tooltip's arrow.
                     *      The outermost wrapper element should have the `.tooltip` class.
                     * @param {String|HTMLElement|TitleFunction} options.title='' - Default title value if `title` attribute isn't present.
                     * @param {String} [options.trigger='hover focus']
                     *      How tooltip is triggered - click, hover, focus, manual.
                     *      You may pass multiple triggers; separate them with a space. `manual` cannot be combined with any other trigger.
                     * @param {String|HTMLElement} options.boundariesElement
                     *      The element used as boundaries for the tooltip. For more information refer to Popper.js'
                     *      [boundariesElement docs](https://popper.js.org/popper-documentation.html)
                     * @param {Number|String} options.offset=0 - Offset of the tooltip relative to its reference. For more information refer to Popper.js'
                     *      [offset docs](https://popper.js.org/popper-documentation.html)
                     * @param {Object} options.popperOptions={} - Popper options, will be passed directly to popper instance. For more information refer to Popper.js'
                     *      [options docs](https://popper.js.org/popper-documentation.html)
                     * @return {Object} instance - The generated tooltip instance
                     */
                    function Tooltip(reference, options) {
                        classCallCheck(this, Tooltip);

                        _initialiseProps.call(this);

                        // apply user options over default ones
                        options = _extends({}, DEFAULT_OPTIONS, options);

                        reference.jquery && (reference = reference[0]);

                        // cache reference and options
                        this.reference = reference;
                        this.options = options;

                        // get events list
                        var events = typeof options.trigger === 'string' ? options.trigger.split(' ').filter(function (trigger) {
                            return ['click', 'hover', 'focus'].indexOf(trigger) !== -1;
                        }) : [];

                        // set initial state
                        this._isOpen = false;
                        this._popperOptions = {};

                        // set event listeners
                        this._setEventListeners(reference, events, options);
                    }

                    //
                    // Public methods
                    //

                    /**
                     * Reveals an element's tooltip. This is considered a "manual" triggering of the tooltip.
                     * Tooltips with zero-length titles are never displayed.
                     * @method Tooltip#show
                     * @memberof Tooltip
                     */


                    /**
                     * Hides an element’s tooltip. This is considered a “manual” triggering of the tooltip.
                     * @method Tooltip#hide
                     * @memberof Tooltip
                     */


                    /**
                     * Hides and destroys an element’s tooltip.
                     * @method Tooltip#dispose
                     * @memberof Tooltip
                     */


                    /**
                     * Toggles an element’s tooltip. This is considered a “manual” triggering of the tooltip.
                     * @method Tooltip#toggle
                     * @memberof Tooltip
                     */


                    /**
                     * Updates the tooltip's title content
                     * @method Tooltip#updateTitleContent
                     * @memberof Tooltip
                     * @param {String|HTMLElement} title - The new content to use for the title
                     */


                    //
                    // Defaults
                    //


                    //
                    // Private methods
                    //

                    createClass(Tooltip, [{
                        key: '_create',


                        /**
                         * Creates a new tooltip node
                         * @memberof Tooltip
                         * @private
                         * @param {HTMLElement} reference
                         * @param {String} template
                         * @param {String|HTMLElement|TitleFunction} title
                         * @param {Boolean} allowHtml
                         * @return {HTMLElement} tooltipNode
                         */
                        value: function _create(reference, template, title, allowHtml) {
                            // create tooltip element
                            var tooltipGenerator = window.document.createElement('div');
                            tooltipGenerator.innerHTML = template.trim();
                            var tooltipNode = tooltipGenerator.childNodes[0];

                            // add unique ID to our tooltip (needed for accessibility reasons)
                            tooltipNode.id = 'tooltip_' + Math.random().toString(36).substr(2, 10);

                            // set initial `aria-hidden` state to `false` (it's visible!)
                            tooltipNode.setAttribute('aria-hidden', 'false');

                            // add title to tooltip
                            var titleNode = tooltipGenerator.querySelector(this.innerSelector);
                            this._addTitleContent(reference, title, allowHtml, titleNode);

                            // return the generated tooltip node
                            return tooltipNode;
                        }
                    }, {
                        key: '_addTitleContent',
                        value: function _addTitleContent(reference, title, allowHtml, titleNode) {
                            if (title.nodeType === 1 || title.nodeType === 11) {
                                // if title is a element node or document fragment, append it only if allowHtml is true
                                allowHtml && titleNode.appendChild(title);
                            } else if (isFunction(title)) {
                                // if title is a function, call it and set textContent or innerHtml depending by `allowHtml` value
                                var titleText = title.call(reference);
                                allowHtml ? titleNode.innerHTML = titleText : titleNode.textContent = titleText;
                            } else {
                                // if it's just a simple text, set textContent or innerHtml depending by `allowHtml` value
                                allowHtml ? titleNode.innerHTML = title : titleNode.textContent = title;
                            }
                        }
                    }, {
                        key: '_show',
                        value: function _show(reference, options) {
                            // don't show if it's already visible
                            // or if it's not being showed
                            if (this._isOpen && !this._isOpening) {
                                return this;
                            }
                            this._isOpen = true;

                            // if the tooltipNode already exists, just show it
                            if (this._tooltipNode) {
                                this._tooltipNode.style.display = '';
                                this._tooltipNode.setAttribute('aria-hidden', 'false');
                                this.popperInstance.update();
                                return this;
                            }

                            // get title
                            var title = reference.getAttribute('title') || options.title;

                            // don't show tooltip if no title is defined
                            if (!title) {
                                return this;
                            }

                            // create tooltip node
                            var tooltipNode = this._create(reference, options.template, title, options.html);

                            // Add `aria-describedby` to our reference element for accessibility reasons
                            reference.setAttribute('aria-describedby', tooltipNode.id);

                            // append tooltip to container
                            var container = this._findContainer(options.container, reference);

                            this._append(tooltipNode, container);

                            this._popperOptions = _extends({}, options.popperOptions, {
                                placement: options.placement
                            });

                            this._popperOptions.modifiers = _extends({}, this._popperOptions.modifiers, {
                                arrow: {
                                    element: this.arrowSelector
                                },
                                offset: {
                                    offset: options.offset
                                }
                            });

                            if (options.boundariesElement) {
                                this._popperOptions.modifiers.preventOverflow = {
                                    boundariesElement: options.boundariesElement
                                };
                            }

                            this.popperInstance = new Popper(reference, tooltipNode, this._popperOptions);

                            this._tooltipNode = tooltipNode;

                            return this;
                        }
                    }, {
                        key: '_hide',
                        value: function _hide() /*reference, options*/ {
                            // don't hide if it's already hidden
                            if (!this._isOpen) {
                                return this;
                            }

                            this._isOpen = false;

                            // hide tooltipNode
                            this._tooltipNode.style.display = 'none';
                            this._tooltipNode.setAttribute('aria-hidden', 'true');

                            return this;
                        }
                    }, {
                        key: '_dispose',
                        value: function _dispose() {
                            var _this = this;

                            // remove event listeners first to prevent any unexpected behaviour
                            this._events.forEach(function (_ref) {
                                var func = _ref.func,
                                    event = _ref.event;

                                _this.reference.removeEventListener(event, func);
                            });
                            this._events = [];

                            if (this._tooltipNode) {
                                this._hide();

                                // destroy instance
                                this.popperInstance.destroy();

                                // destroy tooltipNode if removeOnDestroy is not set, as popperInstance.destroy() already removes the element
                                if (!this.popperInstance.options.removeOnDestroy) {
                                    this._tooltipNode.parentNode.removeChild(this._tooltipNode);
                                    this._tooltipNode = null;
                                }
                            }
                            return this;
                        }
                    }, {
                        key: '_findContainer',
                        value: function _findContainer(container, reference) {
                            // if container is a query, get the relative element
                            if (typeof container === 'string') {
                                container = window.document.querySelector(container);
                            } else if (container === false) {
                                // if container is `false`, set it to reference parent
                                container = reference.parentNode;
                            }
                            return container;
                        }

                        /**
                         * Append tooltip to container
                         * @memberof Tooltip
                         * @private
                         * @param {HTMLElement} tooltipNode
                         * @param {HTMLElement|String|false} container
                         */

                    }, {
                        key: '_append',
                        value: function _append(tooltipNode, container) {
                            container.appendChild(tooltipNode);
                        }
                    }, {
                        key: '_setEventListeners',
                        value: function _setEventListeners(reference, events, options) {
                            var _this2 = this;

                            var directEvents = [];
                            var oppositeEvents = [];

                            events.forEach(function (event) {
                                switch (event) {
                                    case 'hover':
                                        directEvents.push('mouseenter');
                                        oppositeEvents.push('mouseleave');
                                        break;
                                    case 'focus':
                                        directEvents.push('focus');
                                        oppositeEvents.push('blur');
                                        break;
                                    case 'click':
                                        directEvents.push('click');
                                        oppositeEvents.push('click');
                                        break;
                                }
                            });

                            // schedule show tooltip
                            directEvents.forEach(function (event) {
                                var func = function func(evt) {
                                    if (_this2._isOpening === true) {
                                        return;
                                    }
                                    evt.usedByTooltip = true;
                                    _this2._scheduleShow(reference, options.delay, options, evt);
                                };
                                _this2._events.push({event: event, func: func});
                                reference.addEventListener(event, func);
                            });

                            // schedule hide tooltip
                            oppositeEvents.forEach(function (event) {
                                var func = function func(evt) {
                                    if (evt.usedByTooltip === true) {
                                        return;
                                    }
                                    _this2._scheduleHide(reference, options.delay, options, evt);
                                };
                                _this2._events.push({event: event, func: func});
                                reference.addEventListener(event, func);
                            });
                        }
                    }, {
                        key: '_scheduleShow',
                        value: function _scheduleShow(reference, delay, options /*, evt */) {
                            var _this3 = this;

                            this._isOpening = true;
                            // defaults to 0
                            var computedDelay = delay && delay.show || delay || 0;
                            this._showTimeout = window.setTimeout(function () {
                                return _this3._show(reference, options);
                            }, computedDelay);
                        }
                    }, {
                        key: '_scheduleHide',
                        value: function _scheduleHide(reference, delay, options, evt) {
                            var _this4 = this;

                            this._isOpening = false;
                            // defaults to 0
                            var computedDelay = delay && delay.hide || delay || 0;
                            window.setTimeout(function () {
                                window.clearTimeout(_this4._showTimeout);
                                if (_this4._isOpen === false) {
                                    return;
                                }
                                if (!document.body.contains(_this4._tooltipNode)) {
                                    return;
                                }

                                // if we are hiding because of a mouseleave, we must check that the new
                                // reference isn't the tooltip, because in this case we don't want to hide it
                                if (evt.type === 'mouseleave') {
                                    var isSet = _this4._setTooltipNodeEvent(evt, reference, delay, options);

                                    // if we set the new event, don't hide the tooltip yet
                                    // the new event will take care to hide it if necessary
                                    if (isSet) {
                                        return;
                                    }
                                }

                                _this4._hide(reference, options);
                            }, computedDelay);
                        }
                    }, {
                        key: '_updateTitleContent',
                        value: function _updateTitleContent(title) {
                            if (typeof this._tooltipNode === 'undefined') {
                                if (typeof this.options.title !== 'undefined') {
                                    this.options.title = title;
                                }
                                return;
                            }
                            var titleNode = this._tooltipNode.parentNode.querySelector(this.innerSelector);
                            this._clearTitleContent(titleNode, this.options.html, this.reference.getAttribute('title') || this.options.title);
                            this._addTitleContent(this.reference, title, this.options.html, titleNode);
                            this.options.title = title;
                            this.popperInstance.update();
                        }
                    }, {
                        key: '_clearTitleContent',
                        value: function _clearTitleContent(titleNode, allowHtml, lastTitle) {
                            if (lastTitle.nodeType === 1 || lastTitle.nodeType === 11) {
                                allowHtml && titleNode.removeChild(lastTitle);
                            } else {
                                allowHtml ? titleNode.innerHTML = '' : titleNode.textContent = '';
                            }
                        }
                    }]);
                    return Tooltip;
                }();

                /**
                 * Placement function, its context is the Tooltip instance.
                 * @memberof Tooltip
                 * @callback PlacementFunction
                 * @param {HTMLElement} tooltip - tooltip DOM node.
                 * @param {HTMLElement} reference - reference DOM node.
                 * @return {String} placement - One of the allowed placement options.
                 */

                /**
                 * Title function, its context is the Tooltip instance.
                 * @memberof Tooltip
                 * @callback TitleFunction
                 * @return {String} placement - The desired title.
                 */


                var _initialiseProps = function _initialiseProps() {
                    var _this5 = this;

                    this.show = function () {
                        return _this5._show(_this5.reference, _this5.options);
                    };

                    this.hide = function () {
                        return _this5._hide();
                    };

                    this.dispose = function () {
                        return _this5._dispose();
                    };

                    this.toggle = function () {
                        if (_this5._isOpen) {
                            return _this5.hide();
                        } else {
                            return _this5.show();
                        }
                    };

                    this.updateTitleContent = function (title) {
                        return _this5._updateTitleContent(title);
                    };

                    this.arrowSelector = '.tooltip-arrow, .tooltip__arrow';
                    this.innerSelector = '.tooltip-inner, .tooltip__inner';
                    this._events = [];

                    this._setTooltipNodeEvent = function (evt, reference, delay, options) {
                        var relatedreference = evt.relatedreference || evt.toElement || evt.relatedTarget;

                        var callback = function callback(evt2) {
                            var relatedreference2 = evt2.relatedreference || evt2.toElement || evt2.relatedTarget;

                            // Remove event listener after call
                            _this5._tooltipNode.removeEventListener(evt.type, callback);

                            // If the new reference is not the reference element
                            if (!reference.contains(relatedreference2)) {
                                // Schedule to hide tooltip
                                _this5._scheduleHide(reference, options.delay, options, evt2);
                            }
                        };

                        if (_this5._tooltipNode.contains(relatedreference)) {
                            // listen to mouseleave on the tooltip element to be able to hide the tooltip
                            _this5._tooltipNode.addEventListener(evt.type, callback);
                            return true;
                        }

                        return false;
                    };
                };

                return Tooltip;

            })));


        }, {"popper.js": 12}], 16: [function (require, module, exports) {
            (function (global) {
                /*!
 * weakmap-polyfill v2.0.0 - ECMAScript6 WeakMap polyfill
 * https://github.com/polygonplanet/weakmap-polyfill
 * Copyright (c) 2015-2016 polygon planet <polygon.planet.aqua@gmail.com>
 * @license MIT
 */
                (function (self) {
                    'use strict';

                    if (self.WeakMap) {
                        return;
                    }

                    var hasOwnProperty = Object.prototype.hasOwnProperty;
                    var defineProperty = function (object, name, value) {
                        if (Object.defineProperty) {
                            Object.defineProperty(object, name, {
                                configurable: true,
                                writable: true,
                                value: value
                            });
                        } else {
                            object[name] = value;
                        }
                    };

                    self.WeakMap = (function () {

                        // ECMA-262 23.3 WeakMap Objects
                        function WeakMap() {
                            if (this === void 0) {
                                throw new TypeError("Constructor WeakMap requires 'new'");
                            }

                            defineProperty(this, '_id', genId('_WeakMap'));

                            // ECMA-262 23.3.1.1 WeakMap([iterable])
                            if (arguments.length > 0) {
                                // Currently, WeakMap `iterable` argument is not supported
                                throw new TypeError('WeakMap iterable is not supported');
                            }
                        }

                        // ECMA-262 23.3.3.2 WeakMap.prototype.delete(key)
                        defineProperty(WeakMap.prototype, 'delete', function (key) {
                            checkInstance(this, 'delete');

                            if (!isObject(key)) {
                                return false;
                            }

                            var entry = key[this._id];
                            if (entry && entry[0] === key) {
                                delete key[this._id];
                                return true;
                            }

                            return false;
                        });

                        // ECMA-262 23.3.3.3 WeakMap.prototype.get(key)
                        defineProperty(WeakMap.prototype, 'get', function (key) {
                            checkInstance(this, 'get');

                            if (!isObject(key)) {
                                return void 0;
                            }

                            var entry = key[this._id];
                            if (entry && entry[0] === key) {
                                return entry[1];
                            }
                            return void 0;
                        });
                        // ECMA-262 23.3.3.4 WeakMap.prototype.has(key)
                        defineProperty(WeakMap.prototype, 'has', function (key) {
                            checkInstance(this, 'has');
                            if (!isObject(key)) {
                                return false;
                            }
                            var entry = key[this._id];
                            if (entry && entry[0] === key) {
                                return true;
                            }
                            return false;
                        });
                        // ECMA-262 23.3.3.5 WeakMap.prototype.set(key, value)
                        defineProperty(WeakMap.prototype, 'set', function (key, value) {
                            checkInstance(this, 'set');
                            if (!isObject(key)) {
                                throw new TypeError('Invalid value used as weak map key');
                            }
                            var entry = key[this._id];
                            if (entry && entry[0] === key) {
                                entry[1] = value;
                                return this;
                            }
                            defineProperty(key, this._id, [key, value]);
                            return this;
                        });

                        function checkInstance(x, methodName) {
                            if (!isObject(x) || !hasOwnProperty.call(x, '_id')) {
                                throw new TypeError(
                                    methodName + ' method called on incompatible receiver ' +
                                    typeof x
                                );
                            }
                        }

                        function genId(prefix) {
                            return prefix + '_' + rand() + '.' + rand();
                        }

                        function rand() {
                            return Math.random().toString().substring(2);
                        }

                        defineProperty(WeakMap, '_polyfill', true);
                        return WeakMap;
                    })();

                    function isObject(x) {
                        return Object(x) === x;
                    }
                })(
                    typeof self !== 'undefined' ? self :
                        typeof window !== 'undefined' ? window :
                            typeof global !== 'undefined' ? global : this
                );
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
        }, {}]
    }, {}, [5]);

</script>
</body>
</html>